/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "前端指南",
  "description": "前端技术学习指南",
  "base": "/",
  "headTags": [
    [
      "link",
      {
        "rel": "icon",
        "type": "image/jpg",
        "href": "/js-nation-square-blue.png"
      }
    ]
  ],
  "pages": [
    {
      "title": "归档",
      "frontmatter": {
        "archivesPage": true,
        "title": "归档",
        "permalink": "/archives/",
        "article": false
      },
      "regularPath": "/@pages/archivesPage.html",
      "relativePath": "@pages/archivesPage.md",
      "key": "v-5358e722",
      "path": "/archives/",
      "lastUpdated": "7/26/2021, 2:08:25 PM",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "标签",
      "frontmatter": {
        "tagsPage": true,
        "title": "标签",
        "permalink": "/tags/",
        "article": false
      },
      "regularPath": "/@pages/tagsPage.html",
      "relativePath": "@pages/tagsPage.md",
      "key": "v-2e8e39a2",
      "path": "/tags/",
      "lastUpdated": "7/26/2021, 2:08:25 PM",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "分类",
      "frontmatter": {
        "categoriesPage": true,
        "title": "分类",
        "permalink": "/categories/",
        "article": false
      },
      "regularPath": "/@pages/categoriesPage.html",
      "relativePath": "@pages/categoriesPage.md",
      "key": "v-0cebcc02",
      "path": "/categories/",
      "lastUpdated": "7/26/2021, 2:08:25 PM",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "Home",
      "frontmatter": {
        "home": true,
        "actionText": "→ 开始阅读 ←",
        "actionLink": "/note/typescript.md",
        "features": [
          {
            "title": "Ecosystem",
            "details": "精通 VS Code、NodeJS、Webpack、Lottie 等软件与工具包的安装与卸载，配套设施也是必不可少的。"
          },
          {
            "title": "JavaScript",
            "details": "熟练掌握 React、TypeScript、Rax（H5）等单词的拼写，熟练使用ES6语法编程，追求代码高质量可维护性。"
          },
          {
            "title": "Motto",
            "details": "程序就像女人的裙子，越短才越好"
          }
        ],
        "footer": "Powered By VuePress | 2021 ErDong"
      },
      "regularPath": "/",
      "relativePath": "README.md",
      "key": "v-f3fec70e",
      "path": "/",
      "lastUpdated": "10/28/2021, 10:36:24 PM",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "Integration",
      "frontmatter": {
        "title": "Integration",
        "date": "2021-09-07T23:03:17.000Z",
        "permalink": "/pages/27e97c/",
        "categories": [
          "interview"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/interview/Integration.html",
      "relativePath": "interview/Integration.md",
      "key": "v-8435e3fc",
      "path": "/pages/27e97c/",
      "headers": [
        {
          "level": 2,
          "title": "JavaScript",
          "slug": "javascript",
          "normalizedTitle": "javascript",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "react",
          "slug": "react",
          "normalizedTitle": "react",
          "charIndex": 672
        },
        {
          "level": 2,
          "title": "webpack",
          "slug": "webpack",
          "normalizedTitle": "webpack",
          "charIndex": 2134
        },
        {
          "level": 2,
          "title": "工程化",
          "slug": "gong-cheng-hua",
          "normalizedTitle": "工程化",
          "charIndex": 2554
        },
        {
          "level": 2,
          "title": "性能优化",
          "slug": "xing-neng-you-hua",
          "normalizedTitle": "性能优化",
          "charIndex": 2863
        },
        {
          "level": 2,
          "title": "移动端 H5",
          "slug": "yi-dong-duan-h5",
          "normalizedTitle": "移动端 h5",
          "charIndex": 3413
        },
        {
          "level": 2,
          "title": "TS",
          "slug": "ts",
          "normalizedTitle": "ts",
          "charIndex": 3621
        },
        {
          "level": 2,
          "title": "安全",
          "slug": "an-quan",
          "normalizedTitle": "安全",
          "charIndex": 3691
        },
        {
          "level": 2,
          "title": "手写",
          "slug": "shou-xie",
          "normalizedTitle": "手写",
          "charIndex": 3772
        },
        {
          "level": 2,
          "title": "杂项",
          "slug": "za-xiang",
          "normalizedTitle": "杂项",
          "charIndex": 4034
        }
      ],
      "lastUpdated": "9/17/2021, 10:21:49 PM",
      "headersStr": "JavaScript react webpack 工程化 性能优化 移动端 H5 TS 安全 手写 杂项",
      "content": "# JavaScript\n\n * 现代 JavaScript 教程 *\n   * https://zh.javascript.info/\n * 调用堆栈\n * 作用域闭包\n * this全面解析\n * 深浅拷贝原理\n * 原型Prototype\n * Async/Await原理\n * promise\n   * promise 实现 https://jelly.jd.com/article/5fec895f846cc00148ae4c75\n * Even Loop\n   * 宏任务与微任务 https://jelly.jd.com/article/5e79d307384e6201505fba93\n * V8\n   * 深入浅出 V8 引擎 https://jelly.jd.com/article/5f859a141d506201572828d7\n   * js 执行过程 https://www.zoo.team/article/the-process-of-executing-js-in-v8\n   * V8 引擎垃圾回收与内存分配 https://www.zoo.team/article/garbage-collection-about-v8\n * todo\n   * 循环遍历 https://www.zoo.team/article/cycle-in-js\n   * ECMAScript 2021 新特征 https://jelly.jd.com/article/5febdfbb846cc00148ae36d7\n\n\n# react\n\n# React Hook\n\n * React Hook实战 https://jelly.jd.com/article/5ecc89705ea1c6015178a212\n * 一文吃透react-hooks原理 https://juejin.cn/post/6944863057000529933\n * 易踩的坑 https://jelly.jd.com/article/608babe70e65470169d5bf9b\n * setState 的执行机制 https://juejin.cn/post/6844903781813993486\n\n# React Virtual DOM\n\n * 虚拟 DOM https://jelly.jd.com/article/60d82e8b78b202017b2949d1\n * 你不知道的 React Virtual DOM https://juejin.cn/post/6985058301184737287\n * 尤雨溪对于Virtual DOM的优势的回答 https://www.zhihu.com/question/31809713/answer/53544875\n\n# React Diff\n\n * diff 算法深入一下 https://juejin.cn/post/6997965021401579556\n\n# React Fiber\n\n * 走进React Fiber的世界 https://juejin.cn/post/6943896410987659277\n * 从中断机制看 React Fiber 技术 https://jelly.jd.com/article/603d96596d84e3013e885482\n * React Fiber 是如何实现更新过程可控的 https://www.zoo.team/article/about-react-fiber\n * 完全理解React Fiber http://www.ayqy.net/blog/dive-into-react-fiber/\n\n# React Router\n\n * React 中的一些 Router 必备知识点 https://www.zoo.team/article/react-router\n\n# redux\n\n * Immutable https://www.zoo.team/article/learn-about-immutable\n\n# TODO\n\n * React 入门 https://juejin.cn/post/6899243806214848519\n * React 17 http://www.ayqy.net/blog/react-17/\n * AST\n * AST 基本操作 https://jelly.jd.com/article/60a623e40801420171d9b090\n * react 源码 基础篇 未完 https://jelly.jd.com/article/60580a7f960312017f4b5231\n * 运用 hooks 实现 redux 的方案 https://jelly.jd.com/article/5e79aae2384e6201505fba2b\n * React代码共享最佳实践方式 https://jelly.jd.com/article/60653129960312017f4bb17f\n\n\n# webpack\n\n * webpack5 最佳实践\n   * 基础篇 https://jelly.jd.com/article/61074411df18aa019e8a2ea3\n   * 实践篇 https://jelly.jd.com/article/6107701c22a78f01a317cd05\n   * 优化篇 https://jelly.jd.com/article/61179aa26bea510187770aa3\n * webpack 最佳实践 https://juejin.cn/post/6982361231071903781\n * Webpack 原理浅析\n   * https://jelly.jd.com/article/5f0de6dad5205e015b87c128\n * Webpack Plugin\n   * https://www.zoo.team/article/webpack-plugin\n\n\n# 工程化\n\n * 构建前端工程\n   * 抛开脚手架，回归本源构建前端工程 https://jelly.jd.com/article/60cb0c9873fc6c016cdf3d7a\n   * 前端工程化（一）从零开始搭建组件库 https://jelly.jd.com/article/5fedb7af5918090150298dc0\n * ESLint\n   * https://jelly.jd.com/article/60644066d96486017129d14e\n * Vite\n   * Vite 特性和部分源码解析 https://www.zoo.team/article/about-vite\n\n\n# 性能优化\n\n * react 性能优化\n   * coding 小技巧 https://jelly.jd.com/article/6061c374d96486017129b585\n * 监控\n   * web 前端运行时动画性能监控 https://jelly.jd.com/article/601fc77d61dbb7014cff31b1\n * 性能优化手段\n   * https://alienzhou.com/projects/fe-performance-journey/\n * 白屏\n   * https://cloud.tencent.com/developer/article/1508941\n * 静态构建\n   * 构建时预渲染：网页首帧优化实践 https://tech.meituan.com/2018/11/15/first-contentful-paint-practice.html\n * SSR\n   * Vue SSR 性能优化实践 https://juejin.cn/post/6887884087915184141\n   * React SSR之原理篇 http://www.ayqy.net/blog/react-ssr-under-the-hood/\n\n\n# 移动端 H5\n\n * 移动真机调试\n   * https://jelly.jd.com/article/5feca536846cc00148ae4d10\n * H5 列表缓存\n   * https://www.zoo.team/article/h5-list-buffer\n * JSBridge\n   * JSBridge 初探 https://www.zoo.team/article/jsbridge\n\n\n# TS\n\n * TypeScript 高级用法 https://juejin.cn/post/6926794697553739784\n\n\n# 安全\n\n * XSS\n   * 浅谈 React 中的 XSS 攻击 https://www.zoo.team/article/xss-in-react\n\n\n# 手写\n\n * React\n   * 手写系列-实现一个铂金段位的 React https://jelly.jd.com/article/60d82ae9625de10174c73860\n   * 手写一个简单的 React https://jelly.jd.com/article/60aceb6b27393b0169c85231\n * promise\n   * 手写系列-这一次，彻底搞懂 Promise https://jelly.jd.com/article/60c806db73fc6c016cdeff90\n\n\n# 杂项\n\n * Chrome 调试技巧\n   * https://jelly.jd.com/article/605c8bf4960312017f4b7450\n * 高质量可维护代码：\n   * 程序范式 https://www.zoo.team/article/program-paradigm\n   * 优雅命名 https://www.zoo.team/article/good-name\n   * Awesome TypeScript https://www.zoo.team/article/awesome-typescript\n   * 组件的抽象与粒度 https://www.zoo.team/article/abstraction-and-granularity-of-component\n   * 注释 https://www.zoo.team/article/the-clean-annotation\n * 成长\n   * https://www.zoo.team/article/how-do-junior-engineers-grow-up\n * Chrome 扩展\n   * 如何从零开始开发一个 Chrome 扩展 https://juejin.cn/post/6932408873533833224\n * 快速构建 React 组件库\n   * https://jelly.jd.com/article/5f277f41645f82014b830390",
      "normalizedContent": "# javascript\n\n * 现代 javascript 教程 *\n   * https://zh.javascript.info/\n * 调用堆栈\n * 作用域闭包\n * this全面解析\n * 深浅拷贝原理\n * 原型prototype\n * async/await原理\n * promise\n   * promise 实现 https://jelly.jd.com/article/5fec895f846cc00148ae4c75\n * even loop\n   * 宏任务与微任务 https://jelly.jd.com/article/5e79d307384e6201505fba93\n * v8\n   * 深入浅出 v8 引擎 https://jelly.jd.com/article/5f859a141d506201572828d7\n   * js 执行过程 https://www.zoo.team/article/the-process-of-executing-js-in-v8\n   * v8 引擎垃圾回收与内存分配 https://www.zoo.team/article/garbage-collection-about-v8\n * todo\n   * 循环遍历 https://www.zoo.team/article/cycle-in-js\n   * ecmascript 2021 新特征 https://jelly.jd.com/article/5febdfbb846cc00148ae36d7\n\n\n# react\n\n# react hook\n\n * react hook实战 https://jelly.jd.com/article/5ecc89705ea1c6015178a212\n * 一文吃透react-hooks原理 https://juejin.cn/post/6944863057000529933\n * 易踩的坑 https://jelly.jd.com/article/608babe70e65470169d5bf9b\n * setstate 的执行机制 https://juejin.cn/post/6844903781813993486\n\n# react virtual dom\n\n * 虚拟 dom https://jelly.jd.com/article/60d82e8b78b202017b2949d1\n * 你不知道的 react virtual dom https://juejin.cn/post/6985058301184737287\n * 尤雨溪对于virtual dom的优势的回答 https://www.zhihu.com/question/31809713/answer/53544875\n\n# react diff\n\n * diff 算法深入一下 https://juejin.cn/post/6997965021401579556\n\n# react fiber\n\n * 走进react fiber的世界 https://juejin.cn/post/6943896410987659277\n * 从中断机制看 react fiber 技术 https://jelly.jd.com/article/603d96596d84e3013e885482\n * react fiber 是如何实现更新过程可控的 https://www.zoo.team/article/about-react-fiber\n * 完全理解react fiber http://www.ayqy.net/blog/dive-into-react-fiber/\n\n# react router\n\n * react 中的一些 router 必备知识点 https://www.zoo.team/article/react-router\n\n# redux\n\n * immutable https://www.zoo.team/article/learn-about-immutable\n\n# todo\n\n * react 入门 https://juejin.cn/post/6899243806214848519\n * react 17 http://www.ayqy.net/blog/react-17/\n * ast\n * ast 基本操作 https://jelly.jd.com/article/60a623e40801420171d9b090\n * react 源码 基础篇 未完 https://jelly.jd.com/article/60580a7f960312017f4b5231\n * 运用 hooks 实现 redux 的方案 https://jelly.jd.com/article/5e79aae2384e6201505fba2b\n * react代码共享最佳实践方式 https://jelly.jd.com/article/60653129960312017f4bb17f\n\n\n# webpack\n\n * webpack5 最佳实践\n   * 基础篇 https://jelly.jd.com/article/61074411df18aa019e8a2ea3\n   * 实践篇 https://jelly.jd.com/article/6107701c22a78f01a317cd05\n   * 优化篇 https://jelly.jd.com/article/61179aa26bea510187770aa3\n * webpack 最佳实践 https://juejin.cn/post/6982361231071903781\n * webpack 原理浅析\n   * https://jelly.jd.com/article/5f0de6dad5205e015b87c128\n * webpack plugin\n   * https://www.zoo.team/article/webpack-plugin\n\n\n# 工程化\n\n * 构建前端工程\n   * 抛开脚手架，回归本源构建前端工程 https://jelly.jd.com/article/60cb0c9873fc6c016cdf3d7a\n   * 前端工程化（一）从零开始搭建组件库 https://jelly.jd.com/article/5fedb7af5918090150298dc0\n * eslint\n   * https://jelly.jd.com/article/60644066d96486017129d14e\n * vite\n   * vite 特性和部分源码解析 https://www.zoo.team/article/about-vite\n\n\n# 性能优化\n\n * react 性能优化\n   * coding 小技巧 https://jelly.jd.com/article/6061c374d96486017129b585\n * 监控\n   * web 前端运行时动画性能监控 https://jelly.jd.com/article/601fc77d61dbb7014cff31b1\n * 性能优化手段\n   * https://alienzhou.com/projects/fe-performance-journey/\n * 白屏\n   * https://cloud.tencent.com/developer/article/1508941\n * 静态构建\n   * 构建时预渲染：网页首帧优化实践 https://tech.meituan.com/2018/11/15/first-contentful-paint-practice.html\n * ssr\n   * vue ssr 性能优化实践 https://juejin.cn/post/6887884087915184141\n   * react ssr之原理篇 http://www.ayqy.net/blog/react-ssr-under-the-hood/\n\n\n# 移动端 h5\n\n * 移动真机调试\n   * https://jelly.jd.com/article/5feca536846cc00148ae4d10\n * h5 列表缓存\n   * https://www.zoo.team/article/h5-list-buffer\n * jsbridge\n   * jsbridge 初探 https://www.zoo.team/article/jsbridge\n\n\n# ts\n\n * typescript 高级用法 https://juejin.cn/post/6926794697553739784\n\n\n# 安全\n\n * xss\n   * 浅谈 react 中的 xss 攻击 https://www.zoo.team/article/xss-in-react\n\n\n# 手写\n\n * react\n   * 手写系列-实现一个铂金段位的 react https://jelly.jd.com/article/60d82ae9625de10174c73860\n   * 手写一个简单的 react https://jelly.jd.com/article/60aceb6b27393b0169c85231\n * promise\n   * 手写系列-这一次，彻底搞懂 promise https://jelly.jd.com/article/60c806db73fc6c016cdeff90\n\n\n# 杂项\n\n * chrome 调试技巧\n   * https://jelly.jd.com/article/605c8bf4960312017f4b7450\n * 高质量可维护代码：\n   * 程序范式 https://www.zoo.team/article/program-paradigm\n   * 优雅命名 https://www.zoo.team/article/good-name\n   * awesome typescript https://www.zoo.team/article/awesome-typescript\n   * 组件的抽象与粒度 https://www.zoo.team/article/abstraction-and-granularity-of-component\n   * 注释 https://www.zoo.team/article/the-clean-annotation\n * 成长\n   * https://www.zoo.team/article/how-do-junior-engineers-grow-up\n * chrome 扩展\n   * 如何从零开始开发一个 chrome 扩展 https://juejin.cn/post/6932408873533833224\n * 快速构建 react 组件库\n   * https://jelly.jd.com/article/5f277f41645f82014b830390",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Question library",
      "frontmatter": {
        "title": "Question library",
        "date": "2021-10-28T21:54:19.000Z",
        "permalink": "/pages/50ebbe/",
        "categories": [
          "interview"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/interview/Library/Questionlibrary.html",
      "relativePath": "interview/Library/Questionlibrary.md",
      "key": "v-16de60e2",
      "path": "/pages/50ebbe/",
      "headers": [
        {
          "level": 2,
          "title": "有赞",
          "slug": "you-zan",
          "normalizedTitle": "有赞",
          "charIndex": 7
        },
        {
          "level": 3,
          "title": "一面电话 (1h)",
          "slug": "yi-mian-dian-hua-1h",
          "normalizedTitle": "一面电话 (1h)",
          "charIndex": 61
        },
        {
          "level": 3,
          "title": "一面视频 coding（45mins）",
          "slug": "yi-mian-shi-pin-coding-45mins",
          "normalizedTitle": "一面视频 coding（45mins）",
          "charIndex": 822
        },
        {
          "level": 3,
          "title": "二面现场（ 1h20mins）",
          "slug": "er-mian-xian-chang-1h20mins",
          "normalizedTitle": "二面现场（ 1h20mins）",
          "charIndex": 2341
        },
        {
          "level": 3,
          "title": "三面（50mins）",
          "slug": "san-mian-50mins",
          "normalizedTitle": "三面（50mins）",
          "charIndex": 3169
        },
        {
          "level": 3,
          "title": "四面（HR 40mins）",
          "slug": "si-mian-hr-40mins",
          "normalizedTitle": "四面（hr 40mins）",
          "charIndex": 3936
        }
      ],
      "lastUpdated": "10/28/2021, 10:36:24 PM",
      "headersStr": "有赞 一面电话 (1h) 一面视频 coding（45mins） 二面现场（ 1h20mins） 三面（50mins） 四面（HR 40mins）",
      "content": "题库\n\n\n# 有赞\n\n> https://juejin.cn/user/3386151545609837 @俊劫\n\n\n# 一面电话 (1h)\n\n 1.  讲讲最近写的项目\n 2.  讲讲自己写的打印插件，vue-iframe-print，和其他打印方式对比。分页问题，默认背景图如何显示（知道有 css，但是记不住是那个），自定义样式等等\n 3.  权限系统（RBAC），具体实现，接口权限校验。通用接口如何校验，可复用的业务接口如何校验\n 4.  讲一讲 OAuth\n 5.  微前端（项目在用） 为什么要用微前端，和 iframe 对比了一下。\n 6.  实现一个水平垂直居中？flex:1 含义? 一道场景题\n 7.  margin 塌陷？有没有遇到过其他 css 问题？\n 8.  vue 响应式原理\n 9.  组件 data 为什么是一个函数？\n 10. vue Object.defineProperty 缺陷？数组 7 个方法怎么重写的？\n 11. dep 依赖搜集与 watcher 派发更新流程？dep 是发布者还是订阅者？怎么知道每一个 watcher 要通知哪一个 dep？\n 12. keep-alive 原理？\n 13. 讲一讲虚拟 dom\n 14. 讲一讲 vue diff 算法\n 15. 为什么使用 key 能提升 diff 性能\n 16. this 指向的理解？声明时和运行时指向？箭头函数指向？修改 this 指向？\n 17. call,apply,bind 区别？讲一下实现一个 bind 的思路\n 18. 函数柯里化概念，常用场景？\n 19. 关于缓存的一些东西？如何提高缓存命中率？\n 20. 详细描述一下输入 URL 到页面打开的过程，尽量详细些？\n 21. 数组和链表在计算机中存储的方式？计算机中增加一个数组元素的方式？\n 22. 你有什么想问我的？\n\n然后约了二面，视频 coding\n\n\n# 一面视频 coding（45mins）\n\n/**\n * 1. 实现一个函数，判断两个变量值是否相等\n *\n * 注意\n * - 数据类型不限于示例，尽可能考虑边界\n * - function 引用相等即可\n */\nconst foo1 = {\n  a: 1,\n  b: '1',\n  c: NaN,\n  d: [\n    {\n      a: 1,\n      b: 2,\n    },\n  ],\n  f: {\n    a: 1,\n  },\n  g: null,\n};\n\nconst foo2 = {\n  a: 1,\n  b: '1',\n  c: NaN,\n  d: [\n    {\n      a: 1,\n      b: 2,\n    },\n  ],\n  f: {\n    a: 1,\n  },\n  g: null,\n};\n\nfunction isEqual(target1, target2) {}\nconsole.log(isEqual(foo1, foo2), 'isEqual');\n\n/**\n * 2. 实现 getValue 函数来获取path对应的值\n */\nvar object = { a: [{ b: { c: 3 } }] }; // path: 'a[0].b.c'\nvar array = [{ a: { b: [1] } }]; // path: '[0].a.b[0]'\n\nfunction getValue(target, valuePath, defaultValue) {}\n\nconsole.log(getValue(object, 'a[0].b.c', 0)); // 输出3\nconsole.log(getValue(array, '[0].a.b[0]', 12)); // 输出 1\nconsole.log(getValue(array, '[0].a.b[0].c', 12)); // 输出 12\n\n/**\n * 问题 3\n * 将一天24小时按每半小划分成48段，我们用一个位图表示选中的时间区间，例如`110000000000000000000000000000000000000000000000`，\n * 表示第一个半小时和第二个半小时被选中了，其余时间段都没有被选中，也就是对应00:00~01:00这个时间区间。一个位图中可能有多个不连续的\n * 时间区间被选中，例如`110010000000000000000000000000000000000000000000`，表示00:00-1:00和02:00-02:30这两个时间区间被选中了。\n *\n * 要求：写一个函数timeBitmapToRanges，将上述规则描述的时间位图转换成一个选中时间区间的数组。\n * 示例输入：`\"110010000000000000000000000000000000000000000000\"`\n * 示例输出：`[\"00:00~01:00\", \"02:00~02:30\"]`\n */\nfunction timeBitmapToRanges(str) {}\n\nconsole.log(\n  timeBitmapToRanges(\n    '110010000000000000000000000000000000000000000000',\n  ),\n);\nconsole.log(\n  timeBitmapToRanges(\n    '110011000000110000000000000000000000000000001111',\n  ),\n);\n复制代码;\n\n\n\n# 二面现场（ 1h20mins）\n\n 1.  大数相加: 给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。leetcode 415. 字符串相加\n 2.  写一个事件 Event 类，实现 on，off，emit，once 功能，同时 on 要支持 debounce。eg：on('click',function(){},500)\n 3.  介绍下让自己成长最大的项目？\n 4.  你觉得现在遇到的最难的问题是什么？\n 5.  为什么要做微前端？\n 6.  回到写的第二道题，说到了 setTimeout 设定的时间，函数能准确按时执行吗？setTimeout 怎么能做到准时？\n 7.  js 是单线程还是多线程？为什么？支不支持多线程？支持多线程的方式有哪些？node 端多线程知不知道？进程和线程的区别？进程内存计算机如何分配？线程资源如何分配？\n 8.  跨域的解决方案\n 9.  如何实现移动端 1px 边框\n 10. 什么是 html 可替换元素？\n 11. 一个图片对应多个 cdn 地址，如果第一个地址不能用了，需要换成下一个，怎么做？\n 12. vue 生命周期详细描述下？改变组件 data 里面的东西会触发什么生命周期？\n 13. vue2.x 响应式原理？Object.defineProperty 的一些参数？\n 14. for in 可以遍历出来那些东西？for in 可以遍历数组吗？可以遍历出那些东西？\n 15. vue 组件 scoped 作用？实现原理？其他的 css 隔离方案？\n 16. 怎么用 ES5 去实现 ES6 类的继承？\n 17. 你觉得 eslint 有哪些规则比较有用？\n 18. http1.1 和 http2 的区别？http1.1 中做了哪些项目优化？http1.1 中用的哪些优化手段，会在 http2 中失效？http2.0 还存在什么问题？http3 了解吗？\n\n\n# 三面（50mins）\n\n 1.  自我介绍\n 2.  说一说最近一年做的最好的业务？你觉得你做的最出彩的地方是哪里？\n 3.  处方打印，不同格式如何设置？\n 4.  离线缓存 存在什么问题？\n 5.  讲一讲权限系统？除了 RBAC，还了解哪些权限设计吗？RBAC 的优点？\n 6.  给你一个需求：除了预设角色，某个人可以单独做其他的事情，怎么办？\n 7.  讲一讲你们做的微前端？ 父应用如何加载多个子应用？ 路由整合是如何做的？\n 8.  讲一讲局部打印的实现？\n 9.  api-proxy 是如何实现的？业务越来越复杂，nginx 是不是每次都要改？怎么解决？怎么做一个全局代理？在本地如何调试线上代码？\n 10. 讲一下项目中定制化需求如何处理？更优雅的方式？面试官举了一个有赞的场景例子：关于不同商家后台，某个商家多了一个菜单？某个商家在通用页面 A 中有特殊的两个按钮？如何处理这种个性化的问题？深入一点，如何把个性化需求开放给其他商家自己开发？\n 11. 如果让你写一个 single-spa，你怎么做？两个子应用的 app.js 如何切换？js、css 如何隔离？作为攻击者，如何突破用 proxy 实现的一个沙箱环境，或者说子应用如何才能访问父应用的 window 对象？\n 12. 讲一讲项目中的全键盘操作？keyup 监听怎么做的？addEventListener 第三个参数?如何阻止冒泡事件？怎么阻止部分按键？\n 13. 讲一讲 oAuth 2.0\n 14. 你为什么想出来看机会？对下一份工作期望是怎么样的？你现在是怎么学习的？\n 15. 你有什么想问的？\n\n接着就让我等一下，估计是去讨论去了，自己也知道，接下来如果有 hr 来，就 80%过了。找个理由说 hr 不在的，基本就凉了。。。\n\n\n# 四面（HR 40mins）\n\n等待的时间是非常煎熬的~ 一会（忘记了是多久，差不多 10 分钟？），HR 小姐姐来了，换了个位置，开始面对面谈。\n\n 1. 刚刚聊下来感觉怎么样？\n 2. 对自己 1-3 年的规划\n 3. 前端方面有没有犯过比较大的故障？绩效好的情况下为什么要考虑机会？\n 4. 你觉得自己还能在现在的业务中成长多少？或者说你还能为现在的业务做什么？\n 5. 平时自己的学习方式？\n 6. 你希望自己 3 年以后能达到什么水平？你觉得自己和 P6 差距在哪？\n 7. 平时的工作节奏？\n 8. 你对加入有赞的一些期待是什么？薪资是怎么样的期待？有没有其他 offer？\n 9. 你有什么想问的？",
      "normalizedContent": "题库\n\n\n# 有赞\n\n> https://juejin.cn/user/3386151545609837 @俊劫\n\n\n# 一面电话 (1h)\n\n 1.  讲讲最近写的项目\n 2.  讲讲自己写的打印插件，vue-iframe-print，和其他打印方式对比。分页问题，默认背景图如何显示（知道有 css，但是记不住是那个），自定义样式等等\n 3.  权限系统（rbac），具体实现，接口权限校验。通用接口如何校验，可复用的业务接口如何校验\n 4.  讲一讲 oauth\n 5.  微前端（项目在用） 为什么要用微前端，和 iframe 对比了一下。\n 6.  实现一个水平垂直居中？flex:1 含义? 一道场景题\n 7.  margin 塌陷？有没有遇到过其他 css 问题？\n 8.  vue 响应式原理\n 9.  组件 data 为什么是一个函数？\n 10. vue object.defineproperty 缺陷？数组 7 个方法怎么重写的？\n 11. dep 依赖搜集与 watcher 派发更新流程？dep 是发布者还是订阅者？怎么知道每一个 watcher 要通知哪一个 dep？\n 12. keep-alive 原理？\n 13. 讲一讲虚拟 dom\n 14. 讲一讲 vue diff 算法\n 15. 为什么使用 key 能提升 diff 性能\n 16. this 指向的理解？声明时和运行时指向？箭头函数指向？修改 this 指向？\n 17. call,apply,bind 区别？讲一下实现一个 bind 的思路\n 18. 函数柯里化概念，常用场景？\n 19. 关于缓存的一些东西？如何提高缓存命中率？\n 20. 详细描述一下输入 url 到页面打开的过程，尽量详细些？\n 21. 数组和链表在计算机中存储的方式？计算机中增加一个数组元素的方式？\n 22. 你有什么想问我的？\n\n然后约了二面，视频 coding\n\n\n# 一面视频 coding（45mins）\n\n/**\n * 1. 实现一个函数，判断两个变量值是否相等\n *\n * 注意\n * - 数据类型不限于示例，尽可能考虑边界\n * - function 引用相等即可\n */\nconst foo1 = {\n  a: 1,\n  b: '1',\n  c: nan,\n  d: [\n    {\n      a: 1,\n      b: 2,\n    },\n  ],\n  f: {\n    a: 1,\n  },\n  g: null,\n};\n\nconst foo2 = {\n  a: 1,\n  b: '1',\n  c: nan,\n  d: [\n    {\n      a: 1,\n      b: 2,\n    },\n  ],\n  f: {\n    a: 1,\n  },\n  g: null,\n};\n\nfunction isequal(target1, target2) {}\nconsole.log(isequal(foo1, foo2), 'isequal');\n\n/**\n * 2. 实现 getvalue 函数来获取path对应的值\n */\nvar object = { a: [{ b: { c: 3 } }] }; // path: 'a[0].b.c'\nvar array = [{ a: { b: [1] } }]; // path: '[0].a.b[0]'\n\nfunction getvalue(target, valuepath, defaultvalue) {}\n\nconsole.log(getvalue(object, 'a[0].b.c', 0)); // 输出3\nconsole.log(getvalue(array, '[0].a.b[0]', 12)); // 输出 1\nconsole.log(getvalue(array, '[0].a.b[0].c', 12)); // 输出 12\n\n/**\n * 问题 3\n * 将一天24小时按每半小划分成48段，我们用一个位图表示选中的时间区间，例如`110000000000000000000000000000000000000000000000`，\n * 表示第一个半小时和第二个半小时被选中了，其余时间段都没有被选中，也就是对应00:00~01:00这个时间区间。一个位图中可能有多个不连续的\n * 时间区间被选中，例如`110010000000000000000000000000000000000000000000`，表示00:00-1:00和02:00-02:30这两个时间区间被选中了。\n *\n * 要求：写一个函数timebitmaptoranges，将上述规则描述的时间位图转换成一个选中时间区间的数组。\n * 示例输入：`\"110010000000000000000000000000000000000000000000\"`\n * 示例输出：`[\"00:00~01:00\", \"02:00~02:30\"]`\n */\nfunction timebitmaptoranges(str) {}\n\nconsole.log(\n  timebitmaptoranges(\n    '110010000000000000000000000000000000000000000000',\n  ),\n);\nconsole.log(\n  timebitmaptoranges(\n    '110011000000110000000000000000000000000000001111',\n  ),\n);\n复制代码;\n\n\n\n# 二面现场（ 1h20mins）\n\n 1.  大数相加: 给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。leetcode 415. 字符串相加\n 2.  写一个事件 event 类，实现 on，off，emit，once 功能，同时 on 要支持 debounce。eg：on('click',function(){},500)\n 3.  介绍下让自己成长最大的项目？\n 4.  你觉得现在遇到的最难的问题是什么？\n 5.  为什么要做微前端？\n 6.  回到写的第二道题，说到了 settimeout 设定的时间，函数能准确按时执行吗？settimeout 怎么能做到准时？\n 7.  js 是单线程还是多线程？为什么？支不支持多线程？支持多线程的方式有哪些？node 端多线程知不知道？进程和线程的区别？进程内存计算机如何分配？线程资源如何分配？\n 8.  跨域的解决方案\n 9.  如何实现移动端 1px 边框\n 10. 什么是 html 可替换元素？\n 11. 一个图片对应多个 cdn 地址，如果第一个地址不能用了，需要换成下一个，怎么做？\n 12. vue 生命周期详细描述下？改变组件 data 里面的东西会触发什么生命周期？\n 13. vue2.x 响应式原理？object.defineproperty 的一些参数？\n 14. for in 可以遍历出来那些东西？for in 可以遍历数组吗？可以遍历出那些东西？\n 15. vue 组件 scoped 作用？实现原理？其他的 css 隔离方案？\n 16. 怎么用 es5 去实现 es6 类的继承？\n 17. 你觉得 eslint 有哪些规则比较有用？\n 18. http1.1 和 http2 的区别？http1.1 中做了哪些项目优化？http1.1 中用的哪些优化手段，会在 http2 中失效？http2.0 还存在什么问题？http3 了解吗？\n\n\n# 三面（50mins）\n\n 1.  自我介绍\n 2.  说一说最近一年做的最好的业务？你觉得你做的最出彩的地方是哪里？\n 3.  处方打印，不同格式如何设置？\n 4.  离线缓存 存在什么问题？\n 5.  讲一讲权限系统？除了 rbac，还了解哪些权限设计吗？rbac 的优点？\n 6.  给你一个需求：除了预设角色，某个人可以单独做其他的事情，怎么办？\n 7.  讲一讲你们做的微前端？ 父应用如何加载多个子应用？ 路由整合是如何做的？\n 8.  讲一讲局部打印的实现？\n 9.  api-proxy 是如何实现的？业务越来越复杂，nginx 是不是每次都要改？怎么解决？怎么做一个全局代理？在本地如何调试线上代码？\n 10. 讲一下项目中定制化需求如何处理？更优雅的方式？面试官举了一个有赞的场景例子：关于不同商家后台，某个商家多了一个菜单？某个商家在通用页面 a 中有特殊的两个按钮？如何处理这种个性化的问题？深入一点，如何把个性化需求开放给其他商家自己开发？\n 11. 如果让你写一个 single-spa，你怎么做？两个子应用的 app.js 如何切换？js、css 如何隔离？作为攻击者，如何突破用 proxy 实现的一个沙箱环境，或者说子应用如何才能访问父应用的 window 对象？\n 12. 讲一讲项目中的全键盘操作？keyup 监听怎么做的？addeventlistener 第三个参数?如何阻止冒泡事件？怎么阻止部分按键？\n 13. 讲一讲 oauth 2.0\n 14. 你为什么想出来看机会？对下一份工作期望是怎么样的？你现在是怎么学习的？\n 15. 你有什么想问的？\n\n接着就让我等一下，估计是去讨论去了，自己也知道，接下来如果有 hr 来，就 80%过了。找个理由说 hr 不在的，基本就凉了。。。\n\n\n# 四面（hr 40mins）\n\n等待的时间是非常煎熬的~ 一会（忘记了是多久，差不多 10 分钟？），hr 小姐姐来了，换了个位置，开始面对面谈。\n\n 1. 刚刚聊下来感觉怎么样？\n 2. 对自己 1-3 年的规划\n 3. 前端方面有没有犯过比较大的故障？绩效好的情况下为什么要考虑机会？\n 4. 你觉得自己还能在现在的业务中成长多少？或者说你还能为现在的业务做什么？\n 5. 平时自己的学习方式？\n 6. 你希望自己 3 年以后能达到什么水平？你觉得自己和 p6 差距在哪？\n 7. 平时的工作节奏？\n 8. 你对加入有赞的一些期待是什么？薪资是怎么样的期待？有没有其他 offer？\n 9. 你有什么想问的？",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "List",
      "frontmatter": {
        "title": "List",
        "date": "2021-10-28T22:18:53.000Z",
        "permalink": "/pages/f86881/",
        "categories": [
          "interview",
          "Library"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/interview/Library/List.html",
      "relativePath": "interview/Library/List.md",
      "key": "v-145c61a4",
      "path": "/pages/f86881/",
      "headersStr": null,
      "content": "# 阿里同学整理的面试题 有深度\n\n * https://juejin.cn/post/6987549240436195364\n * https://juejin.cn/post/6996815121855021087\n * https://juejin.cn/post/6844904093425598471\n\n# 不错的面试整理 2021年10月28日\n\n * https://juejin.cn/post/7016593221815910408\n * https://juejin.cn/post/7021173142890479630\n\n# TODO\n\n * https://juejin.cn/post/7013953652578582558\n * https://juejin.cn/post/7004638318843412493\n * https://cloud.tencent.com/developer/article/1856568",
      "normalizedContent": "# 阿里同学整理的面试题 有深度\n\n * https://juejin.cn/post/6987549240436195364\n * https://juejin.cn/post/6996815121855021087\n * https://juejin.cn/post/6844904093425598471\n\n# 不错的面试整理 2021年10月28日\n\n * https://juejin.cn/post/7016593221815910408\n * https://juejin.cn/post/7021173142890479630\n\n# todo\n\n * https://juejin.cn/post/7013953652578582558\n * https://juejin.cn/post/7004638318843412493\n * https://cloud.tencent.com/developer/article/1856568",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "关于我",
      "frontmatter": {
        "title": "关于我",
        "date": "2021-07-26T13:44:36.000Z",
        "permalink": "/about/",
        "categories": [
          "about"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/about/",
      "relativePath": "about/README.md",
      "key": "v-34c9d17d",
      "path": "/about/",
      "headers": [
        {
          "level": 2,
          "title": "我自己",
          "slug": "wo-zi-ji",
          "normalizedTitle": "我自己",
          "charIndex": 14
        }
      ],
      "lastUpdated": "10/28/2021, 10:36:24 PM",
      "headersStr": "我自己",
      "content": "关于我（2021）\n\n\n# 我自己\n\n目前状态\n\n * 3 年前端学习与开发经验，2 年前端工作经验。\n * 技能\n   * 略懂点 JS\n     * 写过些功能、优化和修复\n     * 在公司主要负责 H5 频道开发\n * 学习中\n   * 修炼 TS\n   * 学习现代化、工程化前端开发\n * 其他\n   * 偶偶写写文章",
      "normalizedContent": "关于我（2021）\n\n\n# 我自己\n\n目前状态\n\n * 3 年前端学习与开发经验，2 年前端工作经验。\n * 技能\n   * 略懂点 js\n     * 写过些功能、优化和修复\n     * 在公司主要负责 h5 频道开发\n * 学习中\n   * 修炼 ts\n   * 学习现代化、工程化前端开发\n * 其他\n   * 偶偶写写文章",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "EventLoop",
      "frontmatter": {
        "title": "EventLoop",
        "date": "2021-10-27T22:19:47.000Z",
        "permalink": "/pages/7b89ea/",
        "categories": [
          "note",
          "Browser"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/Browser/EventLoop.html",
      "relativePath": "note/Browser/EventLoop.md",
      "key": "v-c45e9e0c",
      "path": "/pages/7b89ea/",
      "lastUpdated": "10/28/2021, 7:15:37 PM",
      "headersStr": null,
      "content": "Event-Loop",
      "normalizedContent": "event-loop",
      "charsets": {}
    },
    {
      "title": "V8",
      "frontmatter": {
        "title": "V8",
        "date": "2021-10-27T22:19:26.000Z",
        "permalink": "/pages/f6701f/",
        "categories": [
          "note",
          "Browser"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/Browser/V8.html",
      "relativePath": "note/Browser/V8.md",
      "key": "v-a71486fc",
      "path": "/pages/f6701f/",
      "lastUpdated": "10/28/2021, 7:15:37 PM",
      "headersStr": null,
      "content": "V8",
      "normalizedContent": "v8",
      "charsets": {}
    },
    {
      "title": "PlantUML",
      "frontmatter": {
        "title": "PlantUML",
        "date": "2021-09-07T20:53:43.000Z",
        "permalink": "/pages/plantUml/",
        "categories": [
          "note"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/Daily/PlantUML.html",
      "relativePath": "note/Daily/PlantUML.md",
      "key": "v-77a4e37c",
      "path": "/pages/plantUml/",
      "headers": [
        {
          "level": 2,
          "title": "Vuepress 增加 PlantUML 支持",
          "slug": "vuepress-zeng-jia-plantuml-zhi-chi",
          "normalizedTitle": "vuepress 增加 plantuml 支持",
          "charIndex": 2
        }
      ],
      "lastUpdated": "9/7/2021, 10:55:52 PM",
      "headersStr": "Vuepress 增加 PlantUML 支持",
      "content": "# Vuepress 增加 PlantUML 支持\n\n# 插件安装\n\nyarn add -D markdown-it-plantuml\n\n\n编辑Vuepress的配置文件.config.js，增加插件的配置：\n\nmodule.exports = {\n  ...\n  extendMarkdown: md => {\n    md.set({ breaks: true })\n    md.use(require('markdown-it-plantuml'))\n  },\n  ...\n}\n\n\n# 测试\n\n@startmindmap\n* root node\n\t* some first level node\n\t\t* second level node\n\t\t* another second level node\n\t* another first level node\n@endmindmap\n\n\n参考：https://plantuml.com/zh/mindmap-diagram",
      "normalizedContent": "# vuepress 增加 plantuml 支持\n\n# 插件安装\n\nyarn add -d markdown-it-plantuml\n\n\n编辑vuepress的配置文件.config.js，增加插件的配置：\n\nmodule.exports = {\n  ...\n  extendmarkdown: md => {\n    md.set({ breaks: true })\n    md.use(require('markdown-it-plantuml'))\n  },\n  ...\n}\n\n\n# 测试\n\n@startmindmap\n* root node\n\t* some first level node\n\t\t* second level node\n\t\t* another second level node\n\t* another first level node\n@endmindmap\n\n\n参考：https://plantuml.com/zh/mindmap-diagram",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "JavaScript Interview",
      "frontmatter": {
        "title": "JavaScript Interview",
        "date": "2021-10-28T19:50:51.000Z",
        "permalink": "/pages/2bcec2/",
        "categories": [
          "note",
          "JavaScript"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/interview/JavaScriptInterview.html",
      "relativePath": "interview/JavaScriptInterview.md",
      "key": "v-d3ab27fc",
      "path": "/pages/2bcec2/",
      "headers": [
        {
          "level": 2,
          "title": "第一篇: JS 数据类型之问——概念篇",
          "slug": "di-yi-pian-js-shu-ju-lei-xing-zhi-wen----gai-nian-pian",
          "normalizedTitle": "第一篇: js 数据类型之问——概念篇",
          "charIndex": 72
        },
        {
          "level": 3,
          "title": "1.JS 原始数据类型有哪些？引用数据类型有哪些？",
          "slug": "1.js-yuan-shi-shu-ju-lei-xing-you-na-xie-yin-yong-shu-ju-lei-xing-you-na-xie",
          "normalizedTitle": "1.js 原始数据类型有哪些？引用数据类型有哪些？",
          "charIndex": 96
        },
        {
          "level": 3,
          "title": "2.说出下面运行的结果，解释原因。",
          "slug": "2.shuo-chu-xia-mian-yun-xing-de-jie-guo-jie-shi-yuan-yin.",
          "normalizedTitle": "2.说出下面运行的结果，解释原因。",
          "charIndex": 314
        },
        {
          "level": 3,
          "title": "3.null 是对象吗？为什么？",
          "slug": "3.null-shi-dui-xiang-ma-wei-shi-me",
          "normalizedTitle": "3.null 是对象吗？为什么？",
          "charIndex": 781
        },
        {
          "level": 3,
          "title": "4.'1'.toString()为什么可以调用？",
          "slug": "4.-1-.tostring-wei-shi-me-ke-yi-diao-yong",
          "normalizedTitle": "4.'1'.tostring()为什么可以调用？",
          "charIndex": 958
        },
        {
          "level": 3,
          "title": "5.0.1+0.2 为什么不等于 0.3？",
          "slug": "5.0.1-0.2-wei-shi-me-bu-deng-yu-0.3",
          "normalizedTitle": "5.0.1+0.2 为什么不等于 0.3？",
          "charIndex": 1310
        },
        {
          "level": 3,
          "title": "6.如何理解 BigInt?",
          "slug": "6.ru-he-li-jie-bigint",
          "normalizedTitle": "6.如何理解 bigint?",
          "charIndex": 1451
        },
        {
          "level": 2,
          "title": "第二篇: JS 数据类型之问——检测篇",
          "slug": "di-er-pian-js-shu-ju-lei-xing-zhi-wen----jian-ce-pian",
          "normalizedTitle": "第二篇: js 数据类型之问——检测篇",
          "charIndex": 3180
        },
        {
          "level": 3,
          "title": "1. typeof 是否能正确判断类型？",
          "slug": "1.-typeof-shi-fou-neng-zheng-que-pan-duan-lei-xing",
          "normalizedTitle": "1. typeof 是否能正确判断类型？",
          "charIndex": 3204
        },
        {
          "level": 3,
          "title": "2. instanceof 能否判断基本数据类型？",
          "slug": "2.-instanceof-neng-fou-pan-duan-ji-ben-shu-ju-lei-xing",
          "normalizedTitle": "2. instanceof 能否判断基本数据类型？",
          "charIndex": 3844
        },
        {
          "level": 3,
          "title": "3. 能不能手动实现一下 instanceof 的功能？",
          "slug": "3.-neng-bu-neng-shou-dong-shi-xian-yi-xia-instanceof-de-gong-neng",
          "normalizedTitle": "3. 能不能手动实现一下 instanceof 的功能？",
          "charIndex": 4168
        },
        {
          "level": 3,
          "title": "4. Object.is 和===的区别？",
          "slug": "4.-object.is-he-de-qu-bie",
          "normalizedTitle": "4. object.is 和===的区别？",
          "charIndex": 4743
        },
        {
          "level": 2,
          "title": "第三篇: JS 数据类型之问——转换篇",
          "slug": "di-san-pian-js-shu-ju-lei-xing-zhi-wen----zhuan-huan-pian",
          "normalizedTitle": "第三篇: js 数据类型之问——转换篇",
          "charIndex": 5132
        },
        {
          "level": 3,
          "title": "1. [] == ![]结果是什么？为什么？",
          "slug": "1.-jie-guo-shi-shi-me-wei-shi-me",
          "normalizedTitle": "1. [] == ![]结果是什么？为什么？",
          "charIndex": 5156
        },
        {
          "level": 3,
          "title": "2. JS 中类型转换有哪几种？",
          "slug": "2.-js-zhong-lei-xing-zhuan-huan-you-na-ji-zhong",
          "normalizedTitle": "2. js 中类型转换有哪几种？",
          "charIndex": 5316
        },
        {
          "level": 3,
          "title": "3. == 和 ===有什么区别？",
          "slug": "3.-he-you-shi-me-qu-bie",
          "normalizedTitle": "3. == 和 ===有什么区别？",
          "charIndex": 5436
        },
        {
          "level": 3,
          "title": "4. 对象转原始类型是根据什么流程运行的？",
          "slug": "4.-dui-xiang-zhuan-yuan-shi-lei-xing-shi-gen-ju-shi-me-liu-cheng-yun-xing-de",
          "normalizedTitle": "4. 对象转原始类型是根据什么流程运行的？",
          "charIndex": 5960
        },
        {
          "level": 3,
          "title": "5. 如何让 if(a == 1 && a == 2)条件成立？",
          "slug": "5.-ru-he-rang-if-a-1-a-2-tiao-jian-cheng-li",
          "normalizedTitle": "5. 如何让 if(a == 1 &amp;&amp; a == 2)条件成立？",
          "charIndex": null
        },
        {
          "level": 2,
          "title": "第四篇: 谈谈你对闭包的理解",
          "slug": "di-si-pian-tan-tan-ni-dui-bi-bao-de-li-jie",
          "normalizedTitle": "第四篇: 谈谈你对闭包的理解",
          "charIndex": 6526
        },
        {
          "level": 3,
          "title": "什么是闭包？",
          "slug": "shi-me-shi-bi-bao",
          "normalizedTitle": "什么是闭包？",
          "charIndex": 6545
        },
        {
          "level": 3,
          "title": "闭包产生的原因?",
          "slug": "bi-bao-chan-sheng-de-yuan-yin",
          "normalizedTitle": "闭包产生的原因?",
          "charIndex": 6712
        },
        {
          "level": 3,
          "title": "闭包有哪些表现形式?",
          "slug": "bi-bao-you-na-xie-biao-xian-xing-shi",
          "normalizedTitle": "闭包有哪些表现形式?",
          "charIndex": 7675
        },
        {
          "level": 3,
          "title": "如何解决下面的循环输出问题？",
          "slug": "ru-he-jie-jue-xia-mian-de-xun-huan-shu-chu-wen-ti",
          "normalizedTitle": "如何解决下面的循环输出问题？",
          "charIndex": 8309
        },
        {
          "level": 2,
          "title": "第五篇: 谈谈你对原型链的理解",
          "slug": "di-wu-pian-tan-tan-ni-dui-yuan-xing-lian-de-li-jie",
          "normalizedTitle": "第五篇: 谈谈你对原型链的理解",
          "charIndex": 9345
        },
        {
          "level": 3,
          "title": "1.原型对象和构造函数有何关系？",
          "slug": "1.yuan-xing-dui-xiang-he-gou-zao-han-shu-you-he-guan-xi",
          "normalizedTitle": "1.原型对象和构造函数有何关系？",
          "charIndex": 9365
        },
        {
          "level": 3,
          "title": "2.能不能描述一下原型链？",
          "slug": "2.neng-bu-neng-miao-shu-yi-xia-yuan-xing-lian",
          "normalizedTitle": "2.能不能描述一下原型链？",
          "charIndex": 9534
        },
        {
          "level": 2,
          "title": "第六篇: JS 如何实现继承？",
          "slug": "di-liu-pian-js-ru-he-shi-xian-ji-cheng",
          "normalizedTitle": "第六篇: js 如何实现继承？",
          "charIndex": 9713
        },
        {
          "level": 3,
          "title": "第一种: 借助 call",
          "slug": "di-yi-zhong-jie-zhu-call",
          "normalizedTitle": "第一种: 借助 call",
          "charIndex": 9733
        },
        {
          "level": 3,
          "title": "第二种: 借助原型链",
          "slug": "di-er-zhong-jie-zhu-yuan-xing-lian",
          "normalizedTitle": "第二种: 借助原型链",
          "charIndex": 9961
        },
        {
          "level": 3,
          "title": "第三种：将前两种组合",
          "slug": "di-san-zhong-jiang-qian-liang-zhong-zu-he",
          "normalizedTitle": "第三种：将前两种组合",
          "charIndex": 10392
        },
        {
          "level": 3,
          "title": "第四种: 组合继承的优化 1",
          "slug": "di-si-zhong-zu-he-ji-cheng-de-you-hua-1",
          "normalizedTitle": "第四种: 组合继承的优化 1",
          "charIndex": 10804
        },
        {
          "level": 3,
          "title": "第五种(最推荐使用): 组合继承的优化 1",
          "slug": "di-wu-zhong-zui-tui-jian-shi-yong-zu-he-ji-cheng-de-you-hua-1",
          "normalizedTitle": "第五种(最推荐使用): 组合继承的优化 1",
          "charIndex": 11178
        },
        {
          "level": 3,
          "title": "ES6 的 extends 被编译后的 JavaScript 代码",
          "slug": "es6-de-extends-bei-bian-yi-hou-de-javascript-dai-ma",
          "normalizedTitle": "es6 的 extends 被编译后的 javascript 代码",
          "charIndex": 11480
        },
        {
          "level": 3,
          "title": "从设计思想上谈谈继承本身的问题",
          "slug": "cong-she-ji-si-xiang-shang-tan-tan-ji-cheng-ben-shen-de-wen-ti",
          "normalizedTitle": "从设计思想上谈谈继承本身的问题",
          "charIndex": 12836
        },
        {
          "level": 2,
          "title": "第七篇: 函数的 arguments 为什么不是数组？如何转化成数组？",
          "slug": "di-qi-pian-han-shu-de-arguments-wei-shi-me-bu-shi-shu-zu-ru-he-zhuan-hua-cheng-shu-zu",
          "normalizedTitle": "第七篇: 函数的 arguments 为什么不是数组？如何转化成数组？",
          "charIndex": 13829
        },
        {
          "level": 3,
          "title": "1. Array.prototype.slice.call()",
          "slug": "1.-array.prototype.slice.call",
          "normalizedTitle": "1. array.prototype.slice.call()",
          "charIndex": 14121
        },
        {
          "level": 3,
          "title": "2. Array.from()",
          "slug": "2.-array.from",
          "normalizedTitle": "2. array.from()",
          "charIndex": 14327
        },
        {
          "level": 3,
          "title": "3. ES6 展开运算符",
          "slug": "3.-es6-zhan-kai-yun-suan-fu",
          "normalizedTitle": "3. es6 展开运算符",
          "charIndex": 14527
        },
        {
          "level": 3,
          "title": "4. 利用 concat+apply",
          "slug": "4.-li-yong-concat-apply",
          "normalizedTitle": "4. 利用 concat+apply",
          "charIndex": 14691
        },
        {
          "level": 2,
          "title": "第八篇: forEach 中 return 有效果吗？如何中断 forEach 循环？",
          "slug": "di-ba-pian-foreach-zhong-return-you-xiao-guo-ma-ru-he-zhong-duan-foreach-xun-huan",
          "normalizedTitle": "第八篇: foreach 中 return 有效果吗？如何中断 foreach 循环？",
          "charIndex": 14966
        },
        {
          "level": 2,
          "title": "第九篇: JS 判断数组中是否包含某个值",
          "slug": "di-jiu-pian-js-pan-duan-shu-zu-zhong-shi-fou-bao-han-mou-ge-zhi",
          "normalizedTitle": "第九篇: js 判断数组中是否包含某个值",
          "charIndex": 15277
        },
        {
          "level": 3,
          "title": "方法一：array.indexOf",
          "slug": "fang-fa-yi-array.indexof",
          "normalizedTitle": "方法一：array.indexof",
          "charIndex": 15302
        },
        {
          "level": 3,
          "title": "方法二：array.includes(searcElement[,fromIndex])",
          "slug": "fang-fa-er-array.includes-searcelement-fromindex",
          "normalizedTitle": "方法二：array.includes(searcelement[,fromindex])",
          "charIndex": 15447
        },
        {
          "level": 3,
          "title": "方法三：array.find(callback[,thisArg])",
          "slug": "fang-fa-san-array.find-callback-thisarg",
          "normalizedTitle": "方法三：array.find(callback[,thisarg])",
          "charIndex": 15635
        },
        {
          "level": 3,
          "title": "方法四：array.findeIndex(callback[,thisArg])",
          "slug": "fang-fa-si-array.findeindex-callback-thisarg",
          "normalizedTitle": "方法四：array.findeindex(callback[,thisarg])",
          "charIndex": 15823
        },
        {
          "level": 2,
          "title": "第十篇: JS 中 flat---数组扁平化",
          "slug": "di-shi-pian-js-zhong-flat---shu-zu-bian-ping-hua",
          "normalizedTitle": "第十篇: js 中 flat---数组扁平化",
          "charIndex": 16056
        },
        {
          "level": 3,
          "title": "1. 调用 ES6 中的 flat 方法",
          "slug": "1.-diao-yong-es6-zhong-de-flat-fang-fa",
          "normalizedTitle": "1. 调用 es6 中的 flat 方法",
          "charIndex": 16285
        },
        {
          "level": 3,
          "title": "2. replace + split",
          "slug": "2.-replace-split",
          "normalizedTitle": "2. replace + split",
          "charIndex": 16344
        },
        {
          "level": 3,
          "title": "3. replace + JSON.parse",
          "slug": "3.-replace-json.parse",
          "normalizedTitle": "3. replace + json.parse",
          "charIndex": 16421
        },
        {
          "level": 3,
          "title": "4. 普通递归",
          "slug": "4.-pu-tong-di-gui",
          "normalizedTitle": "4. 普通递归",
          "charIndex": 16538
        },
        {
          "level": 3,
          "title": "5. 利用 reduce 函数迭代",
          "slug": "5.-li-yong-reduce-han-shu-die-dai",
          "normalizedTitle": "5. 利用 reduce 函数迭代",
          "charIndex": 16764
        },
        {
          "level": 3,
          "title": "6：扩展运算符",
          "slug": "6-kuo-zhan-yun-suan-fu",
          "normalizedTitle": "6：扩展运算符",
          "charIndex": 17009
        },
        {
          "level": 2,
          "title": "第十一篇: JS 数组的高阶函数——基础篇",
          "slug": "di-shi-yi-pian-js-shu-zu-de-gao-jie-han-shu----ji-chu-pian",
          "normalizedTitle": "第十一篇: js 数组的高阶函数——基础篇",
          "charIndex": 17143
        },
        {
          "level": 3,
          "title": "1.什么是高阶函数",
          "slug": "1.shi-me-shi-gao-jie-han-shu",
          "normalizedTitle": "1.什么是高阶函数",
          "charIndex": 17169
        },
        {
          "level": 3,
          "title": "2.数组中的高阶函数",
          "slug": "2.shu-zu-zhong-de-gao-jie-han-shu",
          "normalizedTitle": "2.数组中的高阶函数",
          "charIndex": 17257
        },
        {
          "level": 2,
          "title": "第十二篇: 能不能实现数组 map 方法 ?",
          "slug": "di-shi-er-pian-neng-bu-neng-shi-xian-shu-zu-map-fang-fa",
          "normalizedTitle": "第十二篇: 能不能实现数组 map 方法 ?",
          "charIndex": 18667
        },
        {
          "level": 2,
          "title": "第十三篇: 能不能实现数组 reduce 方法 ?",
          "slug": "di-shi-san-pian-neng-bu-neng-shi-xian-shu-zu-reduce-fang-fa",
          "normalizedTitle": "第十三篇: 能不能实现数组 reduce 方法 ?",
          "charIndex": 20691
        },
        {
          "level": 2,
          "title": "第十四篇: 能不能实现数组 push、pop 方法 ?",
          "slug": "di-shi-si-pian-neng-bu-neng-shi-xian-shu-zu-push-pop-fang-fa",
          "normalizedTitle": "第十四篇: 能不能实现数组 push、pop 方法 ?",
          "charIndex": 22905
        },
        {
          "level": 2,
          "title": "第十五篇: 能不能实现数组 filter 方法 ?",
          "slug": "di-shi-wu-pian-neng-bu-neng-shi-xian-shu-zu-filter-fang-fa",
          "normalizedTitle": "第十五篇: 能不能实现数组 filter 方法 ?",
          "charIndex": 23814
        },
        {
          "level": 2,
          "title": "第十六篇: 能不能实现数组 splice 方法 ?",
          "slug": "di-shi-liu-pian-neng-bu-neng-shi-xian-shu-zu-splice-fang-fa",
          "normalizedTitle": "第十六篇: 能不能实现数组 splice 方法 ?",
          "charIndex": 24579
        },
        {
          "level": 3,
          "title": "初步实现",
          "slug": "chu-bu-shi-xian",
          "normalizedTitle": "初步实现",
          "charIndex": 24964
        },
        {
          "level": 3,
          "title": "优化一: 参数的边界情况",
          "slug": "you-hua-yi-can-shu-de-bian-jie-qing-kuang",
          "normalizedTitle": "优化一: 参数的边界情况",
          "charIndex": 27553
        },
        {
          "level": 3,
          "title": "优化二: 数组为密封对象或冻结对象",
          "slug": "you-hua-er-shu-zu-wei-mi-feng-dui-xiang-huo-dong-jie-dui-xiang",
          "normalizedTitle": "优化二: 数组为密封对象或冻结对象",
          "charIndex": 28573
        },
        {
          "level": 2,
          "title": "第十七篇: 能不能实现数组 sort 方法？",
          "slug": "di-shi-qi-pian-neng-bu-neng-shi-xian-shu-zu-sort-fang-fa",
          "normalizedTitle": "第十七篇: 能不能实现数组 sort 方法？",
          "charIndex": 32471
        },
        {
          "level": 3,
          "title": "V8 引擎的思路分析",
          "slug": "v8-yin-qing-de-si-lu-fen-xi",
          "normalizedTitle": "v8 引擎的思路分析",
          "charIndex": 32715
        },
        {
          "level": 3,
          "title": "插入排序及优化",
          "slug": "cha-ru-pai-xu-ji-you-hua",
          "normalizedTitle": "插入排序及优化",
          "charIndex": 33488
        },
        {
          "level": 3,
          "title": "寻找哨兵元素",
          "slug": "xun-zhao-shao-bing-yuan-su",
          "normalizedTitle": "寻找哨兵元素",
          "charIndex": 34151
        },
        {
          "level": 3,
          "title": "完成快排",
          "slug": "wan-cheng-kuai-pai",
          "normalizedTitle": "完成快排",
          "charIndex": 35662
        },
        {
          "level": 3,
          "title": "测试结果",
          "slug": "ce-shi-jie-guo",
          "normalizedTitle": "测试结果",
          "charIndex": 37269
        },
        {
          "level": 2,
          "title": "第十八篇: 能不能模拟实现一个 new 的效果？",
          "slug": "di-shi-ba-pian-neng-bu-neng-mo-ni-shi-xian-yi-ge-new-de-xiao-guo",
          "normalizedTitle": "第十八篇: 能不能模拟实现一个 new 的效果？",
          "charIndex": 40900
        },
        {
          "level": 2,
          "title": "第十九篇: 能不能模拟实现一个 bind 的效果？",
          "slug": "di-shi-jiu-pian-neng-bu-neng-mo-ni-shi-xian-yi-ge-bind-de-xiao-guo",
          "normalizedTitle": "第十九篇: 能不能模拟实现一个 bind 的效果？",
          "charIndex": 41435
        },
        {
          "level": 2,
          "title": "第二十篇: 能不能实现一个 call/apply 函数？",
          "slug": "di-er-shi-pian-neng-bu-neng-shi-xian-yi-ge-call-apply-han-shu",
          "normalizedTitle": "第二十篇: 能不能实现一个 call/apply 函数？",
          "charIndex": 42584
        },
        {
          "level": 2,
          "title": "第二十一篇: 谈谈你对 JS 中 this 的理解。",
          "slug": "di-er-shi-yi-pian-tan-tan-ni-dui-js-zhong-this-de-li-jie.",
          "normalizedTitle": "第二十一篇: 谈谈你对 js 中 this 的理解。",
          "charIndex": 43462
        },
        {
          "level": 3,
          "title": "1. 全局上下文",
          "slug": "1.-quan-ju-shang-xia-wen",
          "normalizedTitle": "1. 全局上下文",
          "charIndex": 43622
        },
        {
          "level": 3,
          "title": "2. 直接调用函数",
          "slug": "2.-zhi-jie-diao-yong-han-shu",
          "normalizedTitle": "2. 直接调用函数",
          "charIndex": 43632
        },
        {
          "level": 3,
          "title": "3. 对象.方法的形式调用",
          "slug": "3.-dui-xiang.fang-fa-de-xing-shi-diao-yong",
          "normalizedTitle": "3. 对象.方法的形式调用",
          "charIndex": 43643
        },
        {
          "level": 3,
          "title": "4. DOM 事件绑定",
          "slug": "4.-dom-shi-jian-bang-ding",
          "normalizedTitle": "4. dom 事件绑定",
          "charIndex": 43658
        },
        {
          "level": 3,
          "title": "5. new+构造函数",
          "slug": "5.-new-gou-zao-han-shu",
          "normalizedTitle": "5. new+构造函数",
          "charIndex": 44091
        },
        {
          "level": 3,
          "title": "6. 箭头函数？",
          "slug": "6.-jian-tou-han-shu",
          "normalizedTitle": "6. 箭头函数？",
          "charIndex": 44130
        },
        {
          "level": 2,
          "title": "第二十二篇: JS 中浅拷贝的手段有哪些？",
          "slug": "di-er-shi-er-pian-js-zhong-qian-kao-bei-de-shou-duan-you-na-xie",
          "normalizedTitle": "第二十二篇: js 中浅拷贝的手段有哪些？",
          "charIndex": 44431
        },
        {
          "level": 3,
          "title": "重要: 什么是拷贝？",
          "slug": "chong-yao-shi-me-shi-kao-bei",
          "normalizedTitle": "重要: 什么是拷贝？",
          "charIndex": 44457
        },
        {
          "level": 3,
          "title": "1. 手动实现",
          "slug": "1.-shou-dong-shi-xian",
          "normalizedTitle": "1. 手动实现",
          "charIndex": 45218
        },
        {
          "level": 3,
          "title": "2. Object.assign",
          "slug": "2.-object.assign",
          "normalizedTitle": "2. object.assign",
          "charIndex": 45574
        },
        {
          "level": 3,
          "title": "3. concat 浅拷贝数组",
          "slug": "3.-concat-qian-kao-bei-shu-zu",
          "normalizedTitle": "3. concat 浅拷贝数组",
          "charIndex": 45786
        },
        {
          "level": 3,
          "title": "4. slice 浅拷贝",
          "slug": "4.-slice-qian-kao-bei",
          "normalizedTitle": "4. slice 浅拷贝",
          "charIndex": 45911
        },
        {
          "level": 3,
          "title": "5. ...展开运算符",
          "slug": "5.-...zhan-kai-yun-suan-fu",
          "normalizedTitle": "5. ...展开运算符",
          "charIndex": 45943
        },
        {
          "level": 2,
          "title": "第二十三篇: 能不能写一个完整的深拷贝？",
          "slug": "di-er-shi-san-pian-neng-bu-neng-xie-yi-ge-wan-zheng-de-shen-kao-bei",
          "normalizedTitle": "第二十三篇: 能不能写一个完整的深拷贝？",
          "charIndex": 46032
        },
        {
          "level": 3,
          "title": "1. 简易版及问题",
          "slug": "1.-jian-yi-ban-ji-wen-ti",
          "normalizedTitle": "1. 简易版及问题",
          "charIndex": 46095
        },
        {
          "level": 3,
          "title": "2. 解决循环引用",
          "slug": "2.-jie-jue-xun-huan-yin-yong",
          "normalizedTitle": "2. 解决循环引用",
          "charIndex": 46819
        },
        {
          "level": 3,
          "title": "3. 拷贝特殊对象",
          "slug": "3.-kao-bei-te-shu-dui-xiang",
          "normalizedTitle": "3. 拷贝特殊对象",
          "charIndex": 48217
        },
        {
          "level": 3,
          "title": "4. 拷贝函数",
          "slug": "4.-kao-bei-han-shu",
          "normalizedTitle": "4. 拷贝函数",
          "charIndex": 50321
        },
        {
          "level": 3,
          "title": "5. 小小的 bug",
          "slug": "5.-xiao-xiao-de-bug",
          "normalizedTitle": "5. 小小的 bug",
          "charIndex": 51071
        },
        {
          "level": 3,
          "title": "6. 完整代码展示",
          "slug": "6.-wan-zheng-dai-ma-zhan-shi",
          "normalizedTitle": "6. 完整代码展示",
          "charIndex": 52066
        },
        {
          "level": 2,
          "title": "第 24 篇: JavaScript 内存机制之问——数据是如何存储的？",
          "slug": "di-24-pian-javascript-nei-cun-ji-zhi-zhi-wen----shu-ju-shi-ru-he-cun-chu-de",
          "normalizedTitle": "第 24 篇: javascript 内存机制之问——数据是如何存储的？",
          "charIndex": 55018
        },
        {
          "level": 2,
          "title": "第 25 篇：V8 引擎如何进行垃圾内存的回收？",
          "slug": "di-25-pian-v8-yin-qing-ru-he-jin-xing-la-ji-nei-cun-de-hui-shou",
          "normalizedTitle": "第 25 篇：v8 引擎如何进行垃圾内存的回收？",
          "charIndex": 56020
        },
        {
          "level": 3,
          "title": "V8 内存限制",
          "slug": "v8-nei-cun-xian-zhi",
          "normalizedTitle": "v8 内存限制",
          "charIndex": 56224
        },
        {
          "level": 3,
          "title": "新生代内存的回收",
          "slug": "xin-sheng-dai-nei-cun-de-hui-shou",
          "normalizedTitle": "新生代内存的回收",
          "charIndex": 57192
        },
        {
          "level": 3,
          "title": "老生代内存的回收",
          "slug": "lao-sheng-dai-nei-cun-de-hui-shou",
          "normalizedTitle": "老生代内存的回收",
          "charIndex": 58077
        },
        {
          "level": 3,
          "title": "增量标记",
          "slug": "zeng-liang-biao-ji",
          "normalizedTitle": "增量标记",
          "charIndex": 58654
        },
        {
          "level": 2,
          "title": "第 26 篇: 描述一下 V8 执行一段 JS 代码的过程？",
          "slug": "di-26-pian-miao-shu-yi-xia-v8-zhi-xing-yi-duan-js-dai-ma-de-guo-cheng",
          "normalizedTitle": "第 26 篇: 描述一下 v8 执行一段 js 代码的过程？",
          "charIndex": 59031
        },
        {
          "level": 3,
          "title": "1.生成 AST",
          "slug": "1.sheng-cheng-ast",
          "normalizedTitle": "1.生成 ast",
          "charIndex": 59623
        },
        {
          "level": 3,
          "title": "2. 生成字节码",
          "slug": "2.-sheng-cheng-zi-jie-ma",
          "normalizedTitle": "2. 生成字节码",
          "charIndex": 60197
        },
        {
          "level": 3,
          "title": "3. 执行代码",
          "slug": "3.-zhi-xing-dai-ma",
          "normalizedTitle": "3. 执行代码",
          "charIndex": 60609
        },
        {
          "level": 2,
          "title": "第 28 篇：如何理解 EventLoop——宏任务和微任务篇",
          "slug": "di-28-pian-ru-he-li-jie-eventloop----hong-ren-wu-he-wei-ren-wu-pian",
          "normalizedTitle": "第 28 篇：如何理解 eventloop——宏任务和微任务篇",
          "charIndex": 61142
        },
        {
          "level": 3,
          "title": "宏任务(MacroTask)引入",
          "slug": "hong-ren-wu-macrotask-yin-ru",
          "normalizedTitle": "宏任务(macrotask)引入",
          "charIndex": 61178
        },
        {
          "level": 3,
          "title": "微任务(MicroTask)引入",
          "slug": "wei-ren-wu-microtask-yin-ru",
          "normalizedTitle": "微任务(microtask)引入",
          "charIndex": 61760
        },
        {
          "level": 2,
          "title": "第 29 篇: 如何理解 EventLoop——浏览器篇",
          "slug": "di-29-pian-ru-he-li-jie-eventloop----liu-lan-qi-pian",
          "normalizedTitle": "第 29 篇: 如何理解 eventloop——浏览器篇",
          "charIndex": 62275
        },
        {
          "level": 2,
          "title": "第 30 篇: 如何理解 EventLoop——nodejs 篇",
          "slug": "di-30-pian-ru-he-li-jie-eventloop----nodejs-pian",
          "normalizedTitle": "第 30 篇: 如何理解 eventloop——nodejs 篇",
          "charIndex": 63418
        },
        {
          "level": 3,
          "title": "1. 三大关键阶段",
          "slug": "1.-san-da-guan-jian-jie-duan",
          "normalizedTitle": "1. 三大关键阶段",
          "charIndex": 63617
        },
        {
          "level": 3,
          "title": "2. 完善",
          "slug": "2.-wan-shan",
          "normalizedTitle": "2. 完善",
          "charIndex": 64263
        },
        {
          "level": 3,
          "title": "3. 实例演示",
          "slug": "3.-shi-li-yan-shi",
          "normalizedTitle": "3. 实例演示",
          "charIndex": 64626
        },
        {
          "level": 3,
          "title": "4.nodejs 和 浏览器关于 eventLoop 的主要区别",
          "slug": "4.nodejs-he-liu-lan-qi-guan-yu-eventloop-de-zhu-yao-qu-bie",
          "normalizedTitle": "4.nodejs 和 浏览器关于 eventloop 的主要区别",
          "charIndex": 65215
        },
        {
          "level": 3,
          "title": "5.关于 process.nextTick 的一点说明",
          "slug": "5.guan-yu-process.nexttick-de-yi-dian-shuo-ming",
          "normalizedTitle": "5.关于 process.nexttick 的一点说明",
          "charIndex": 65313
        },
        {
          "level": 2,
          "title": "第 31 篇: nodejs 中的异步、非阻塞 I/O 是如何实现的？",
          "slug": "di-31-pian-nodejs-zhong-de-yi-bu-fei-zu-sai-i-o-shi-ru-he-shi-xian-de",
          "normalizedTitle": "第 31 篇: nodejs 中的异步、非阻塞 i/o 是如何实现的？",
          "charIndex": 65442
        },
        {
          "level": 3,
          "title": "什么是 I/O？",
          "slug": "shi-me-shi-i-o",
          "normalizedTitle": "什么是 i/o？",
          "charIndex": 65587
        },
        {
          "level": 3,
          "title": "阻塞和非阻塞 I/O",
          "slug": "zu-sai-he-fei-zu-sai-i-o",
          "normalizedTitle": "阻塞和非阻塞 i/o",
          "charIndex": 65803
        },
        {
          "level": 3,
          "title": "异步 I/O 的本质",
          "slug": "yi-bu-i-o-de-ben-zhi",
          "normalizedTitle": "异步 i/o 的本质",
          "charIndex": 66596
        },
        {
          "level": 2,
          "title": "第 32 篇：JS 异步编程有哪些方案？为什么会出现这些方案？",
          "slug": "di-32-pian-js-yi-bu-bian-cheng-you-na-xie-fang-an-wei-shi-me-hui-chu-xian-zhe-xie-fang-an",
          "normalizedTitle": "第 32 篇：js 异步编程有哪些方案？为什么会出现这些方案？",
          "charIndex": 68659
        },
        {
          "level": 3,
          "title": "回调函数时代",
          "slug": "hui-diao-han-shu-shi-dai",
          "normalizedTitle": "回调函数时代",
          "charIndex": 68887
        },
        {
          "level": 3,
          "title": "Promise 时代",
          "slug": "promise-shi-dai",
          "normalizedTitle": "promise 时代",
          "charIndex": 69369
        },
        {
          "level": 3,
          "title": "co + Generator 方式",
          "slug": "co-generator-fang-shi",
          "normalizedTitle": "co + generator 方式",
          "charIndex": 69708
        },
        {
          "level": 3,
          "title": "async + await 方式",
          "slug": "async-await-fang-shi",
          "normalizedTitle": "async + await 方式",
          "charIndex": 70003
        },
        {
          "level": 2,
          "title": "第 33 篇: 能不能简单实现一下 node 中回调函数的机制？",
          "slug": "di-33-pian-neng-bu-neng-jian-dan-shi-xian-yi-xia-node-zhong-hui-diao-han-shu-de-ji-zhi",
          "normalizedTitle": "第 33 篇: 能不能简单实现一下 node 中回调函数的机制？",
          "charIndex": 70461
        },
        {
          "level": 2,
          "title": "第 34 篇: Promise 之问(一)——Promise 凭借什么消灭了回调地狱？",
          "slug": "di-34-pian-promise-zhi-wen-yi-----promise-ping-jie-shi-me-xiao-mie-liao-hui-diao-di-yu",
          "normalizedTitle": "第 34 篇: promise 之问(一)——promise 凭借什么消灭了回调地狱？",
          "charIndex": 73463
        },
        {
          "level": 3,
          "title": "问题",
          "slug": "wen-ti",
          "normalizedTitle": "问题",
          "charIndex": 1638
        },
        {
          "level": 3,
          "title": "解决方法",
          "slug": "jie-jue-fang-fa",
          "normalizedTitle": "解决方法",
          "charIndex": 8619
        },
        {
          "level": 3,
          "title": "解决效果",
          "slug": "jie-jue-xiao-guo",
          "normalizedTitle": "解决效果",
          "charIndex": 75008
        },
        {
          "level": 2,
          "title": "第 35 篇: Promise 之问(二)——为什么 Promise 要引入微任务？",
          "slug": "di-35-pian-promise-zhi-wen-er-----wei-shi-me-promise-yao-yin-ru-wei-ren-wu",
          "normalizedTitle": "第 35 篇: promise 之问(二)——为什么 promise 要引入微任务？",
          "charIndex": 75082
        },
        {
          "level": 3,
          "title": "解决方式",
          "slug": "jie-jue-fang-shi",
          "normalizedTitle": "解决方式",
          "charIndex": 58573
        },
        {
          "level": 3,
          "title": "优劣对比",
          "slug": "you-lie-dui-bi",
          "normalizedTitle": "优劣对比",
          "charIndex": 75458
        },
        {
          "level": 2,
          "title": "第 36 篇: Promise 之问(三)——Promise 如何实现链式调用？",
          "slug": "di-36-pian-promise-zhi-wen-san-----promise-ru-he-shi-xian-lian-shi-diao-yong",
          "normalizedTitle": "第 36 篇: promise 之问(三)——promise 如何实现链式调用？",
          "charIndex": 75917
        },
        {
          "level": 3,
          "title": "简易版实现",
          "slug": "jian-yi-ban-shi-xian",
          "normalizedTitle": "简易版实现",
          "charIndex": 76016
        },
        {
          "level": 3,
          "title": "设置回调数组",
          "slug": "she-zhi-hui-diao-shu-zu",
          "normalizedTitle": "设置回调数组",
          "charIndex": 77375
        },
        {
          "level": 3,
          "title": "链式调用完成",
          "slug": "lian-shi-diao-yong-wan-cheng",
          "normalizedTitle": "链式调用完成",
          "charIndex": 78587
        },
        {
          "level": 3,
          "title": "错误捕获及冒泡机制分析",
          "slug": "cuo-wu-bu-huo-ji-mou-pao-ji-zhi-fen-xi",
          "normalizedTitle": "错误捕获及冒泡机制分析",
          "charIndex": 82502
        },
        {
          "level": 2,
          "title": "第 37 篇: Promise 之问(四)——实现 Promise 的 resolve、reject 和 finally",
          "slug": "di-37-pian-promise-zhi-wen-si-----shi-xian-promise-de-resolve-reject-he-finally",
          "normalizedTitle": "第 37 篇: promise 之问(四)——实现 promise 的 resolve、reject 和 finally",
          "charIndex": 83132
        },
        {
          "level": 3,
          "title": "实现 Promise.resolve",
          "slug": "shi-xian-promise.resolve",
          "normalizedTitle": "实现 promise.resolve",
          "charIndex": 83197
        },
        {
          "level": 3,
          "title": "实现 Promise.reject",
          "slug": "shi-xian-promise.reject",
          "normalizedTitle": "实现 promise.reject",
          "charIndex": 83741
        },
        {
          "level": 3,
          "title": "实现 Promise.prototype.finally",
          "slug": "shi-xian-promise.prototype.finally",
          "normalizedTitle": "实现 promise.prototype.finally",
          "charIndex": 83931
        },
        {
          "level": 2,
          "title": "第 38 篇: Promise 之问(五)——实现 Promise 的 all 和 race",
          "slug": "di-38-pian-promise-zhi-wen-wu-----shi-xian-promise-de-all-he-race",
          "normalizedTitle": "第 38 篇: promise 之问(五)——实现 promise 的 all 和 race",
          "charIndex": 84328
        },
        {
          "level": 3,
          "title": "实现 Promise.all",
          "slug": "shi-xian-promise.all",
          "normalizedTitle": "实现 promise.all",
          "charIndex": 84379
        },
        {
          "level": 3,
          "title": "实现 Promise.race",
          "slug": "shi-xian-promise.race",
          "normalizedTitle": "实现 promise.race",
          "charIndex": 85131
        },
        {
          "level": 2,
          "title": "第 39 篇: 谈谈你对生成器以及协程的理解。",
          "slug": "di-39-pian-tan-tan-ni-dui-sheng-cheng-qi-yi-ji-xie-cheng-de-li-jie.",
          "normalizedTitle": "第 39 篇: 谈谈你对生成器以及协程的理解。",
          "charIndex": 85709
        },
        {
          "level": 3,
          "title": "生成器执行流程",
          "slug": "sheng-cheng-qi-zhi-xing-liu-cheng",
          "normalizedTitle": "生成器执行流程",
          "charIndex": 85816
        },
        {
          "level": 3,
          "title": "yield*",
          "slug": "yield",
          "normalizedTitle": "yield*",
          "charIndex": 86548
        },
        {
          "level": 3,
          "title": "生成器实现机制——协程",
          "slug": "sheng-cheng-qi-shi-xian-ji-zhi----xie-cheng",
          "normalizedTitle": "生成器实现机制——协程",
          "charIndex": 86828
        },
        {
          "level": 2,
          "title": "第 40 篇: 如何让 Generator 的异步代码按顺序执行完毕？",
          "slug": "di-40-pian-ru-he-rang-generator-de-yi-bu-dai-ma-an-shun-xu-zhi-xing-wan-bi",
          "normalizedTitle": "第 40 篇: 如何让 generator 的异步代码按顺序执行完毕？",
          "charIndex": 87677
        },
        {
          "level": 3,
          "title": "thunk 函数",
          "slug": "thunk-han-shu",
          "normalizedTitle": "thunk 函数",
          "charIndex": 87783
        },
        {
          "level": 3,
          "title": "Generator 和 异步",
          "slug": "generator-he-yi-bu",
          "normalizedTitle": "generator 和 异步",
          "charIndex": 88895
        },
        {
          "level": 3,
          "title": "采用 co 库",
          "slug": "cai-yong-co-ku",
          "normalizedTitle": "采用 co 库",
          "charIndex": 91093
        },
        {
          "level": 2,
          "title": "第 41 篇: 解释一下 async/await 的运行机制。",
          "slug": "di-41-pian-jie-shi-yi-xia-async-await-de-yun-xing-ji-zhi.",
          "normalizedTitle": "第 41 篇: 解释一下 async/await 的运行机制。",
          "charIndex": 91450
        },
        {
          "level": 3,
          "title": "async",
          "slug": "async",
          "normalizedTitle": "async",
          "charIndex": 70003
        },
        {
          "level": 3,
          "title": "await",
          "slug": "await",
          "normalizedTitle": "await",
          "charIndex": 70011
        },
        {
          "level": 2,
          "title": "第 42 篇: forEach 中用 await 会产生什么问题?怎么解决这个问题？",
          "slug": "di-42-pian-foreach-zhong-yong-await-hui-chan-sheng-shi-me-wen-ti-zen-me-jie-jue-zhe-ge-wen-ti",
          "normalizedTitle": "第 42 篇: foreach 中用 await 会产生什么问题?怎么解决这个问题？",
          "charIndex": 92974
        },
        {
          "level": 3,
          "title": "问题",
          "slug": "wen-ti-2",
          "normalizedTitle": "问题",
          "charIndex": 1638
        },
        {
          "level": 3,
          "title": "问题原因",
          "slug": "wen-ti-yuan-yin",
          "normalizedTitle": "问题原因",
          "charIndex": 93446
        },
        {
          "level": 3,
          "title": "解决方案",
          "slug": "jie-jue-fang-an",
          "normalizedTitle": "解决方案",
          "charIndex": 70433
        },
        {
          "level": 3,
          "title": "解决原理——Iterator",
          "slug": "jie-jue-yuan-li----iterator",
          "normalizedTitle": "解决原理——iterator",
          "charIndex": 93917
        },
        {
          "level": 3,
          "title": "重新认识生成器",
          "slug": "chong-xin-ren-shi-sheng-cheng-qi",
          "normalizedTitle": "重新认识生成器",
          "charIndex": 94846
        }
      ],
      "lastUpdated": "10/28/2021, 10:36:24 PM",
      "headersStr": "第一篇: JS 数据类型之问——概念篇 1.JS 原始数据类型有哪些？引用数据类型有哪些？ 2.说出下面运行的结果，解释原因。 3.null 是对象吗？为什么？ 4.'1'.toString()为什么可以调用？ 5.0.1+0.2 为什么不等于 0.3？ 6.如何理解 BigInt? 第二篇: JS 数据类型之问——检测篇 1. typeof 是否能正确判断类型？ 2. instanceof 能否判断基本数据类型？ 3. 能不能手动实现一下 instanceof 的功能？ 4. Object.is 和===的区别？ 第三篇: JS 数据类型之问——转换篇 1. [] == ![]结果是什么？为什么？ 2. JS 中类型转换有哪几种？ 3. == 和 ===有什么区别？ 4. 对象转原始类型是根据什么流程运行的？ 5. 如何让 if(a == 1 && a == 2)条件成立？ 第四篇: 谈谈你对闭包的理解 什么是闭包？ 闭包产生的原因? 闭包有哪些表现形式? 如何解决下面的循环输出问题？ 第五篇: 谈谈你对原型链的理解 1.原型对象和构造函数有何关系？ 2.能不能描述一下原型链？ 第六篇: JS 如何实现继承？ 第一种: 借助 call 第二种: 借助原型链 第三种：将前两种组合 第四种: 组合继承的优化 1 第五种(最推荐使用): 组合继承的优化 1 ES6 的 extends 被编译后的 JavaScript 代码 从设计思想上谈谈继承本身的问题 第七篇: 函数的 arguments 为什么不是数组？如何转化成数组？ 1. Array.prototype.slice.call() 2. Array.from() 3. ES6 展开运算符 4. 利用 concat+apply 第八篇: forEach 中 return 有效果吗？如何中断 forEach 循环？ 第九篇: JS 判断数组中是否包含某个值 方法一：array.indexOf 方法二：array.includes(searcElement[,fromIndex]) 方法三：array.find(callback[,thisArg]) 方法四：array.findeIndex(callback[,thisArg]) 第十篇: JS 中 flat---数组扁平化 1. 调用 ES6 中的 flat 方法 2. replace + split 3. replace + JSON.parse 4. 普通递归 5. 利用 reduce 函数迭代 6：扩展运算符 第十一篇: JS 数组的高阶函数——基础篇 1.什么是高阶函数 2.数组中的高阶函数 第十二篇: 能不能实现数组 map 方法 ? 第十三篇: 能不能实现数组 reduce 方法 ? 第十四篇: 能不能实现数组 push、pop 方法 ? 第十五篇: 能不能实现数组 filter 方法 ? 第十六篇: 能不能实现数组 splice 方法 ? 初步实现 优化一: 参数的边界情况 优化二: 数组为密封对象或冻结对象 第十七篇: 能不能实现数组 sort 方法？ V8 引擎的思路分析 插入排序及优化 寻找哨兵元素 完成快排 测试结果 第十八篇: 能不能模拟实现一个 new 的效果？ 第十九篇: 能不能模拟实现一个 bind 的效果？ 第二十篇: 能不能实现一个 call/apply 函数？ 第二十一篇: 谈谈你对 JS 中 this 的理解。 1. 全局上下文 2. 直接调用函数 3. 对象.方法的形式调用 4. DOM 事件绑定 5. new+构造函数 6. 箭头函数？ 第二十二篇: JS 中浅拷贝的手段有哪些？ 重要: 什么是拷贝？ 1. 手动实现 2. Object.assign 3. concat 浅拷贝数组 4. slice 浅拷贝 5. ...展开运算符 第二十三篇: 能不能写一个完整的深拷贝？ 1. 简易版及问题 2. 解决循环引用 3. 拷贝特殊对象 4. 拷贝函数 5. 小小的 bug 6. 完整代码展示 第 24 篇: JavaScript 内存机制之问——数据是如何存储的？ 第 25 篇：V8 引擎如何进行垃圾内存的回收？ V8 内存限制 新生代内存的回收 老生代内存的回收 增量标记 第 26 篇: 描述一下 V8 执行一段 JS 代码的过程？ 1.生成 AST 2. 生成字节码 3. 执行代码 第 28 篇：如何理解 EventLoop——宏任务和微任务篇 宏任务(MacroTask)引入 微任务(MicroTask)引入 第 29 篇: 如何理解 EventLoop——浏览器篇 第 30 篇: 如何理解 EventLoop——nodejs 篇 1. 三大关键阶段 2. 完善 3. 实例演示 4.nodejs 和 浏览器关于 eventLoop 的主要区别 5.关于 process.nextTick 的一点说明 第 31 篇: nodejs 中的异步、非阻塞 I/O 是如何实现的？ 什么是 I/O？ 阻塞和非阻塞 I/O 异步 I/O 的本质 第 32 篇：JS 异步编程有哪些方案？为什么会出现这些方案？ 回调函数时代 Promise 时代 co + Generator 方式 async + await 方式 第 33 篇: 能不能简单实现一下 node 中回调函数的机制？ 第 34 篇: Promise 之问(一)——Promise 凭借什么消灭了回调地狱？ 问题 解决方法 解决效果 第 35 篇: Promise 之问(二)——为什么 Promise 要引入微任务？ 解决方式 优劣对比 第 36 篇: Promise 之问(三)——Promise 如何实现链式调用？ 简易版实现 设置回调数组 链式调用完成 错误捕获及冒泡机制分析 第 37 篇: Promise 之问(四)——实现 Promise 的 resolve、reject 和 finally 实现 Promise.resolve 实现 Promise.reject 实现 Promise.prototype.finally 第 38 篇: Promise 之问(五)——实现 Promise 的 all 和 race 实现 Promise.all 实现 Promise.race 第 39 篇: 谈谈你对生成器以及协程的理解。 生成器执行流程 yield* 生成器实现机制——协程 第 40 篇: 如何让 Generator 的异步代码按顺序执行完毕？ thunk 函数 Generator 和 异步 采用 co 库 第 41 篇: 解释一下 async/await 的运行机制。 async await 第 42 篇: forEach 中用 await 会产生什么问题?怎么解决这个问题？ 问题 问题原因 解决方案 解决原理——Iterator 重新认识生成器",
      "content": "JavaScript Interview\n\n> https://juejin.cn/user/430664257382462 @神三元\n\n\n# 第一篇: JS 数据类型之问——概念篇\n\n\n# 1.JS 原始数据类型有哪些？引用数据类型有哪些？\n\n在 JS 中，存在着 7 种原始值，分别是：\n\n * boolean\n * null\n * undefined\n * number\n * string\n * symbol\n * bigint\n\n引用数据类型: 对象 Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）\n\n\n# 2.说出下面运行的结果，解释原因。\n\nfunction test(person) {\n  person.age = 26;\n  person = {\n    name: 'hzj',\n    age: 18,\n  };\n  return person;\n}\nconst p1 = {\n  name: 'fyq',\n  age: 19,\n};\nconst p2 = test(p1);\nconsole.log(p1); // -> ?\nconsole.log(p2); // -> ?\n复制代码;\n\n\n结果:\n\np1：{name: “fyq”, age: 26}\np2：{name: “hzj”, age: 18}\n复制代码\n\n\n> 原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test 函数中的实参 person 是 p1 对象的内存地址，通过调用 person.age = 26 确实改变了 p1 的值，但随后 person 变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了 p2。\n\n\n# 3.null 是对象吗？为什么？\n\n结论: null 不是对象。\n\n解释: 虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。\n\n\n# 4.'1'.toString()为什么可以调用？\n\n其实在这个语句运行的过程中做了这样几件事情：\n\nvar s = new Object('1');\ns.toString();\ns = null;\n复制代码;\n\n\n第一步: 创建 Object 类实例。注意为什么不是 String ？ 由于 Symbol 和 BigInt 的出现，对它们调用 new 都会报错，目前 ES6 规范也不建议用 new 来创建基本类型的包装类。\n\n第二步: 调用实例方法。\n\n第三步: 执行完方法立即销毁这个实例。\n\n整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括 Boolean, Number 和 String。\n\n> 参考:《JavaScript 高级程序设计(第三版)》P118\n\n\n# 5.0.1+0.2 为什么不等于 0.3？\n\n0.1 和 0.2 在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成 0.30000000000000004。\n\n\n# 6.如何理解 BigInt?\n\n# 什么是 BigInt?\n\n> BigInt 是一种新的数据类型，用于当整数值大于 Number 数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数 id，等等，而不需要使用库。\n\n# 为什么需要 BigInt?\n\n在 JS 中，所有的数字都以双精度 64 位浮点格式表示，那这会带来什么问题呢？\n\n这导致 JS 中的 Number 无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS 中的 Number 类型只能安全地表示-9007199254740991(-(2^53-1))和 9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。\n\nconsole.log(999999999999999); //=>10000000000000000\n复制代码;\n\n\n同时也会有一定的安全性问题:\n\n9007199254740992 === 9007199254740993; // → true 居然是true!\n复制代码;\n\n\n# 如何创建并使用 BigInt？\n\n要创建 BigInt，只需要在数字末尾追加 n 即可。\n\nconsole.log(9007199254740995n); // → 9007199254740995n\nconsole.log(9007199254740995); // → 9007199254740996\n复制代码;\n\n\n另一种创建 BigInt 的方法是用 BigInt()构造函数、\n\nBigInt('9007199254740995'); // → 9007199254740995n\n复制代码;\n\n\n简单使用如下:\n\n10n + 20n; // → 30n\n10n - 20n; // → -10n\n+10n; // → TypeError: Cannot convert a BigInt value to a number\n-10n; // → -10n\n10n * 20n; // → 200n\n20n / 10n; // → 2n\n23n % 10n; // → 3n\n10n ** 3n; // → 1000n\n\nconst x = 10n;\n++x; // → 11n\n--x; // → 9n\nconsole.log(typeof x); //\"bigint\"\n复制代码;\n\n\n# 值得警惕的点\n\n 1. BigInt 不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js 代码。\n 2. 因为隐式类型转换可能丢失信息，所以不允许在 bigint 和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由 BigInt 或 Number 精确表示。\n\n10 + 10n; // → TypeError\n复制代码;\n\n\n 1. 不能将 BigInt 传递给 Web api 和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报 TypeError 错误。\n\nMath.max(2n, 4n, 6n); // → TypeError\n复制代码;\n\n\n 1. 当 Boolean 类型与 BigInt 类型相遇时，BigInt 的处理方式与 Number 类似，换句话说，只要不是 0n，BigInt 就被视为 truthy 的值。\n\nif (0n) {\n  //条件判断为false\n}\nif (3n) {\n  //条件为true\n}\n复制代码;\n\n\n 1. 元素都为 BigInt 的数组可以进行 sort。\n 2. BigInt 可以正常地进行位运算，如|、&、<<、>>和^\n\n# 浏览器兼容性\n\ncaniuse 的结果:\n\n\n\n其实现在的兼容性并不怎么好，只有 chrome67、firefox、Opera 这些主流实现，要正式成为规范，其实还有很长的路要走。\n\n我们期待 BigInt 的光明前途！\n\n\n# 第二篇: JS 数据类型之问——检测篇\n\n\n# 1. typeof 是否能正确判断类型？\n\n对于原始类型来说，除了 null 都可以调用 typeof 显示正确的类型。\n\ntypeof 1; // 'number'\ntypeof '1'; // 'string'\ntypeof undefined; // 'undefined'\ntypeof true; // 'boolean'\ntypeof Symbol(); // 'symbol'\n复制代码;\n\n\n但对于引用数据类型，除了函数之外，都会显示\"object\"。\n\ntypeof []; // 'object'\ntypeof {}; // 'object'\ntypeof console.log; // 'function'\n复制代码;\n\n\n因此采用 typeof 判断对象数据类型是不合适的，采用 instanceof 会更好，instanceof 的原理是基于原型链的查询，只要处于原型链中，判断永远为 true\n\nconst Person = function() {};\nconst p1 = new Person();\np1 instanceof Person; // true\n\nvar str1 = 'hello world';\nstr1 instanceof String; // false\n\nvar str2 = new String('hello world');\nstr2 instanceof String; // true\n复制代码;\n\n\n\n# 2. instanceof 能否判断基本数据类型？\n\n能。比如下面这种方式:\n\nclass PrimitiveNumber {\n  static [Symbol.hasInstance](x) {\n    return typeof x === 'number';\n  }\n}\nconsole.log(111 instanceof PrimitiveNumber); // true\n复制代码;\n\n\n如果你不知道 Symbol，可以看看MDN 上关于 hasInstance 的解释。\n\n其实就是自定义 instanceof 行为的一种方式，这里将原有的 instanceof 方法重定义，换成了 typeof，因此能够判断基本数据类型。\n\n\n# 3. 能不能手动实现一下 instanceof 的功能？\n\n核心: 原型链的向上查找。\n\nfunction myInstanceof(left, right) {\n  //基本数据类型直接返回false\n  if (typeof left !== 'object' || left === null)\n    return false;\n  //getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象\n  let proto = Object.getPrototypeOf(left);\n  while (true) {\n    //查找到尽头，还没找到\n    if (proto == null) return false;\n    //找到相同的原型对象\n    if (proto == right.prototype) return true;\n    proto = Object.getPrototypeOf(proto);\n  }\n}\n\n复制代码;\n\n\n测试:\n\nconsole.log(myInstanceof('111', String)); //false\nconsole.log(myInstanceof(new String('111'), String)); //true\n复制代码;\n\n\n\n# 4. Object.is 和===的区别？\n\nObject 在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0 和-0，NaN 和 NaN。 源码如下：\n\nfunction is(x, y) {\n  if (x === y) {\n    //运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    //NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理\n    //两个都是NaN的时候返回true\n    return x !== x && y !== y;\n  }\n\n\n复制代码\n\n\n\n# 第三篇: JS 数据类型之问——转换篇\n\n\n# 1. [] == ![]结果是什么？为什么？\n\n解析:\n\n== 中，左右两边都需要转换为数字然后进行比较。\n\n[]转换为数字为 0。\n\n![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为 true,\n\n因此![]为 false，进而在转换成数字，变为 0。\n\n0 == 0 ， 结果为 true\n\n\n# 2. JS 中类型转换有哪几种？\n\nJS 中，类型转换只有三种：\n\n * 转换成数字\n * 转换成布尔值\n * 转换成字符串\n\n转换具体规则如下:\n\n> 注意\"Boolean 转字符串\"这行结果指的是 true 转字符串的例子\n\n\n\n\n# 3. == 和 ===有什么区别？\n\n===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如'1'===1的结果是false，因为一边是string，另一边是number。\n复制代码\n\n\n==不像===那样严格，对于一般情况，只要值相等，就返回 true，但==还涉及一些类型转换，它的转换规则如下：\n\n * 两边的类型是否相同，相同的话就比较值的大小，例如 1==2，返回 false\n * 判断的是否是 null 和 undefined，是的话就返回 true\n * 判断的类型是否是 String 和 Number，是的话，把 String 类型转换成 Number，再进行比较\n * 判断其中一方是否是 Boolean，是的话就把 Boolean 转换成 Number，再进行比较\n * 如果其中一方为 Object，且另一方为 String、Number 或者 Symbol，会将 Object 转换成字符串，再进行比较\n\nconsole.log({ a: 1 } == true); //false\nconsole.log({ a: 1 } == '[object Object]'); //true\n复制代码;\n\n\n\n# 4. 对象转原始类型是根据什么流程运行的？\n\n对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：\n\n 1. 如果 Symbol.toPrimitive()方法，优先调用再返回\n 2. 调用 valueOf()，如果转换为原始类型，则返回\n 3. 调用 toString()，如果转换为原始类型，则返回\n 4. 如果都没有返回原始类型，会报错\n\nvar obj = {\n  value: 3,\n  valueOf() {\n    return 4;\n  },\n  toString() {\n    return '5';\n  },\n  [Symbol.toPrimitive]() {\n    return 6;\n  },\n};\nconsole.log(obj + 1); // 输出7\n复制代码;\n\n\n\n# 5. 如何让 if(a == 1 && a == 2)条件成立？\n\n其实就是上一个问题的应用。\n\nvar a = {\n  value: 0,\n  valueOf: function() {\n    this.value++;\n    return this.value;\n  },\n};\nconsole.log(a == 1 && a == 2); //true\n复制代码;\n\n\n\n# 第四篇: 谈谈你对闭包的理解\n\n\n# 什么是闭包？\n\n红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，\n复制代码\nMDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。\n\n（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）\n复制代码\n\n\n\n# 闭包产生的原因?\n\n首先要明白作用域链的概念，其实很简单，在 ES5 中只存在两种作用域————全局作用域和函数作用域，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。 比如:\n\nvar a = 1;\nfunction f1() {\n  var a = 2;\n  function f2() {\n    var a = 3;\n    console.log(a); //3\n  }\n}\n复制代码;\n\n\n在这段代码中，f1 的作用域指向有全局作用域(window)和它本身，而 f2 的作用域指向全局作用域(window)、f1 和它本身。而且作用域是从最底层向上找，直到找到全局作用域 window 为止，如果全局还没有的话就会报错。就这么简单一件事情！\n\n闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:\n\nfunction f1() {\n  var a = 2;\n  function f2() {\n    console.log(a); //2\n  }\n  return f2;\n}\nvar x = f1();\nx();\n复制代码;\n\n\n这里 x 会拿到父级作用域中的变量，输出 2。因为在当前环境中，含有对 f2 的引用，f2 恰恰引用了 window、f1 和 f2 的作用域。因此 f2 可以访问到 f1 的作用域的变量。\n\n那是不是只有返回函数才算是产生了闭包呢？、\n\n回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：\n\nvar f3;\nfunction f1() {\n  var a = 2;\n  f3 = function() {\n    console.log(a);\n  };\n}\nf1();\nf3();\n复制代码;\n\n\n让 f1 执行，给 f3 赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了 a,因此输出 2。\n\n在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。\n\n\n# 闭包有哪些表现形式?\n\n明白了本质之后，我们就来看看，在真实的场景中，究竟在哪些地方能体现闭包的存在？\n\n 1. 返回一个函数。刚刚已经举例。\n 2. 作为函数参数传递\n\nvar a = 1;\nfunction foo() {\n  var a = 2;\n  function baz() {\n    console.log(a);\n  }\n  bar(baz);\n}\nfunction bar(fn) {\n  // 这就是闭包\n  fn();\n}\n// 输出2，而不是1\nfoo();\n复制代码;\n\n\n 1. 在定时器、事件监听、Ajax 请求、跨窗口通信、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。\n\n以下的闭包保存的仅仅是 window 和当前作用域。\n\n// 定时器\nsetTimeout(function timeHandler(){\n  console.log('111');\n}，100)\n\n// 事件监听\n$('#app').click(function(){\n  console.log('DOM Listener');\n})\n复制代码\n\n\n 1. IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。\n\nvar a = 2;\n(function IIFE() {\n  // 输出2\n  console.log(a);\n})();\n复制代码;\n\n\n\n# 如何解决下面的循环输出问题？\n\nfor (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i);\n  }, 0);\n}\n复制代码;\n\n\n为什么会全部输出 6？如何改进，让它输出 1，2，3，4，5？(方法越多越好)\n\n因为 setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行，但输出 i 的时候当前作用域没有，往上一级再找，发现了 i,此时循环已经结束，i 变成了 6。因此会全部输出 6。\n\n解决方法：\n\n1、利用 IIFE(立即执行函数表达式)当每次 for 循环时，把此时的 i 变量传递到定时器中\n\nfor (var i = 1; i <= 5; i++) {\n  (function(j) {\n    setTimeout(function timer() {\n      console.log(j);\n    }, 0);\n  })(i);\n}\n复制代码;\n\n\n2、给定时器传入第三个参数, 作为 timer 函数的第一个函数参数\n\nfor (var i = 1; i <= 5; i++) {\n  setTimeout(\n    function timer(j) {\n      console.log(j);\n    },\n    0,\n    i,\n  );\n}\n复制代码;\n\n\n3、使用 ES6 中的 let\n\nfor (let i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i);\n  }, 0);\n}\n复制代码;\n\n\nlet 使 JS 发生革命性的变化，让 JS 有函数作用域变为了块级作用域，用 let 后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:\n\n// i = 1\n{\n  setTimeout(function timer(){\n    console.log(1)\n  },0)\n}\n// i = 2\n{\n  setTimeout(function timer(){\n    console.log(2)\n  },0)\n}\n// i = 3\n...\n复制代码\n\n\n因此能输出正确的结果。\n\n\n# 第五篇: 谈谈你对原型链的理解\n\n\n# 1.原型对象和构造函数有何关系？\n\n在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象。\n\n当函数经过 new 调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个proto属性，指向构造函数的原型对象。\n\n\n\n\n# 2.能不能描述一下原型链？\n\nJavaScript 对象通过proto 指向父类对象，直到指向 Object 对象为止，这样就形成了一个原型指向的链条, 即原型链。\n\n\n\n * 对象的 hasOwnProperty() 来检查对象自身中是否含有该属性\n * 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true\n\n\n# 第六篇: JS 如何实现继承？\n\n\n# 第一种: 借助 call\n\nfunction Parent1() {\n  this.name = 'parent1';\n}\nfunction Child1() {\n  Parent1.call(this);\n  this.type = 'child1';\n}\nconsole.log(new Child1());\n复制代码;\n\n\n这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。\n\n\n# 第二种: 借助原型链\n\nfunction Parent2() {\n  this.name = 'parent2';\n  this.play = [1, 2, 3];\n}\nfunction Child2() {\n  this.type = 'child2';\n}\nChild2.prototype = new Parent2();\n\nconsole.log(new Child2());\n复制代码;\n\n\n看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：\n\nvar s1 = new Child2();\nvar s2 = new Child2();\ns1.play.push(4);\nconsole.log(s1.play, s2.play);\n复制代码;\n\n\n可以看到控制台：\n\n\n\n明明我只改变了 s1 的 play 属性，为什么 s2 也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。\n\n那么还有更好的方式么？\n\n\n# 第三种：将前两种组合\n\nfunction Parent3() {\n  this.name = 'parent3';\n  this.play = [1, 2, 3];\n}\nfunction Child3() {\n  Parent3.call(this);\n  this.type = 'child3';\n}\nChild3.prototype = new Parent3();\nvar s3 = new Child3();\nvar s4 = new Child3();\ns3.play.push(4);\nconsole.log(s3.play, s4.play);\n复制代码;\n\n\n可以看到控制台：\n\n\n\n之前的问题都得以解决。但是这里又徒增了一个新问题，那就是 Parent3 的构造函数会多执行了一次（Child3.prototype = new Parent3();）。这是我们不愿看到的。那么如何解决这个问题？\n\n\n# 第四种: 组合继承的优化 1\n\nfunction Parent4() {\n  this.name = 'parent4';\n  this.play = [1, 2, 3];\n}\nfunction Child4() {\n  Parent4.call(this);\n  this.type = 'child4';\n}\nChild4.prototype = Parent4.prototype;\n复制代码;\n\n\n这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：\n\nvar s3 = new Child4();\nvar s4 = new Child4();\nconsole.log(s3);\n复制代码;\n\n\n\n\n子类实例的构造函数是 Parent4，显然这是不对的，应该是 Child4。\n\n\n# 第五种(最推荐使用): 组合继承的优化 1\n\nfunction Parent5() {\n  this.name = 'parent5';\n  this.play = [1, 2, 3];\n}\nfunction Child5() {\n  Parent5.call(this);\n  this.type = 'child5';\n}\nChild5.prototype = Object.create(Parent5.prototype);\nChild5.prototype.constructor = Child5;\n复制代码;\n\n\n这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。\n\n\n# ES6 的 extends 被编译后的 JavaScript 代码\n\nES6 的代码最后都是要在浏览器上能够跑起来的，这中间就利用了 babel 这个编译工具，将 ES6 的代码编译成 ES5 让一些不支持新语法的浏览器也能运行。\n\n那最后编译成了什么样子呢？\n\nfunction _possibleConstructorReturn(self, call) {\n  // ...\n  return call &&\n    (typeof call === 'object' || typeof call === 'function')\n    ? call\n    : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  // ...\n  //看到没有\n  subClass.prototype = Object.create(\n    superClass && superClass.prototype,\n    {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true,\n      },\n    },\n  );\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass);\n}\n\nvar Parent = function Parent() {\n  // 验证是否是 Parent 构造出来的 this\n  _classCallCheck(this, Parent);\n};\n\nvar Child = (function(_Parent) {\n  _inherits(Child, _Parent);\n\n  function Child() {\n    _classCallCheck(this, Child);\n\n    return _possibleConstructorReturn(\n      this,\n      (\n        Child.__proto__ || Object.getPrototypeOf(Child)\n      ).apply(this, arguments),\n    );\n  }\n\n  return Child;\n})(Parent);\n复制代码;\n\n\n核心是_inherits 函数，可以看到它采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个 Object.setPrototypeOf(subClass, superClass)，这是用来干啥的呢？\n\n答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。\n\n追问: 面向对象的设计一定是好的设计吗？\n复制代码\n\n\n不一定。从继承的角度说，这一设计是存在巨大隐患的。\n\n\n# 从设计思想上谈谈继承本身的问题\n\n假如现在有不同品牌的车，每辆车都有 drive、music、addOil 这三个方法。\n\nclass Car {\n  constructor(id) {\n    this.id = id;\n  }\n  drive() {\n    console.log('wuwuwu!');\n  }\n  music() {\n    console.log('lalala!');\n  }\n  addOil() {\n    console.log('哦哟！');\n  }\n}\nclass otherCar extends Car {}\n复制代码;\n\n\n现在可以实现车的功能，并且以此去扩展不同的车。\n\n但是问题来了，新能源汽车也是车，但是它并不需要 addOil(加油)。\n\n如果让新能源汽车的类继承 Car 的话，也是有问题的，俗称\"大猩猩和香蕉\"的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。\n\n> 继承的最大问题在于：无法决定继承哪些属性，所有属性都得继承。\n\n当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，代码势必会大量重复，另一方面一旦子类有所变动，父类也要进行相应的更新，代码的耦合性太高，维护性不好。\n\n那如何来解决继承的诸多问题呢？\n\n用组合，这也是当今编程语法发展的趋势，比如 golang 完全采用的是面向组合的设计方式。\n\n顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。\n\nfunction drive() {\n  console.log('wuwuwu!');\n}\nfunction music() {\n  console.log('lalala!');\n}\nfunction addOil() {\n  console.log('哦哟！');\n}\n\nlet car = compose(drive, music, addOil);\nlet newEnergyCar = compose(drive, music);\n复制代码;\n\n\n代码干净，复用性也很好。这就是面向组合的设计方式。\n\n\n# 第七篇: 函数的 arguments 为什么不是数组？如何转化成数组？\n\n因为 arguments 本身并不能调用数组方法，它是一个另外一种对象类型，只不过属性从 0 开始排，依次为 0，1，2...最后还有 callee 和 length 属性。我们也把这样的对象称为类数组。\n\n常见的类数组还有：\n\n * 1. 用 getElementsByTagName/ClassName()获得的 HTMLCollection\n * 1. 用 querySelector 获得的 nodeList\n\n那这导致很多数组的方法就不能用了，必要时需要我们将它们转换成数组，有哪些方法呢？\n\n\n# 1. Array.prototype.slice.call()\n\nfunction sum(a, b) {\n  let args = Array.prototype.slice.call(arguments);\n  console.log(args.reduce((sum, cur) => sum + cur)); //args可以调用数组原生的方法啦\n}\nsum(1, 2); //3\n复制代码;\n\n\n\n# 2. Array.from()\n\nfunction sum(a, b) {\n  let args = Array.from(arguments);\n  console.log(args.reduce((sum, cur) => sum + cur)); //args可以调用数组原生的方法啦\n}\nsum(1, 2); //3\n复制代码;\n\n\n这种方法也可以用来转换 Set 和 Map 哦！\n\n\n# 3. ES6 展开运算符\n\nfunction sum(a, b) {\n  let args = [...arguments];\n  console.log(args.reduce((sum, cur) => sum + cur)); //args可以调用数组原生的方法啦\n}\nsum(1, 2); //3\n复制代码;\n\n\n\n# 4. 利用 concat+apply\n\nfunction sum(a, b) {\n  let args = Array.prototype.concat.apply([], arguments); //apply方法会把第二个参数展开\n  console.log(args.reduce((sum, cur) => sum + cur)); //args可以调用数组原生的方法啦\n}\nsum(1, 2); //3\n复制代码;\n\n\n当然，最原始的方法就是再创建一个数组，用 for 循环把类数组的每个属性值放在里面，过于简单，就不浪费篇幅了。\n\n\n# 第八篇: forEach 中 return 有效果吗？如何中断 forEach 循环？\n\n在 forEach 中用 return 不会返回，函数会继续执行。\n\nlet nums = [1, 2, 3];\nnums.forEach((item, index) => {\n  return; //无效\n});\n复制代码;\n\n\n中断方法：\n\n 1. 使用 try 监视代码块，在需要中断的地方抛出异常。\n 2. 官方推荐方法（替换方法）：用 every 和 some 替代 forEach 函数。every 在碰到 return false 的时候，中止循环。some 在碰到 return true 的时候，中止循环\n\n\n# 第九篇: JS 判断数组中是否包含某个值\n\n\n# 方法一：array.indexOf\n\n> 此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。\n\nvar arr = [1, 2, 3, 4];\nvar index = arr.indexOf(3);\nconsole.log(index);\n复制代码;\n\n\n\n# 方法二：array.includes(searcElement[,fromIndex])\n\n> 此方法判断数组中是否存在某个值，如果存在返回 true，否则返回 false\n\nvar arr = [1, 2, 3, 4];\nif (arr.includes(3)) console.log('存在');\nelse console.log('不存在');\n复制代码;\n\n\n\n# 方法三：array.find(callback[,thisArg])\n\n> 返回数组中满足条件的第一个元素的值，如果没有，返回 undefined\n\nvar arr = [1, 2, 3, 4];\nvar result = arr.find((item) => {\n  return item > 3;\n});\nconsole.log(result);\n复制代码;\n\n\n\n# 方法四：array.findeIndex(callback[,thisArg])\n\n> 返回数组中满足条件的第一个元素的下标，如果没有找到，返回-1]\n\nvar arr = [1, 2, 3, 4];\nvar result = arr.findIndex((item) => {\n  return item > 3;\n});\nconsole.log(result);\n复制代码;\n\n\n当然，for 循环当然是没有问题的，这里讨论的是数组方法，就不再展开了。\n\n\n# 第十篇: JS 中 flat---数组扁平化\n\n对于前端项目开发过程中，偶尔会出现层叠数据结构的数组，我们需要将多层级数组转化为一级数组（即提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。那么该如何去实现呢？\n\n需求:多维数组=>一维数组\n\nlet ary = [1, [2, [3, [4, 5]]], 6]; // -> [1, 2, 3, 4, 5, 6]\nlet str = JSON.stringify(ary);\n复制代码;\n\n\n\n# 1. 调用 ES6 中的 flat 方法\n\nary = ary.flat(Infinity);\n复制代码;\n\n\n\n# 2. replace + split\n\nary = str.replace(/(\\[|\\])/g, '').split(',');\n复制代码;\n\n\n\n# 3. replace + JSON.parse\n\nstr = str.replace(/(\\[|\\])/g, '');\nstr = '[' + str + ']';\nary = JSON.parse(str);\n复制代码;\n\n\n\n# 4. 普通递归\n\nlet result = [];\nlet fn = function(ary) {\n  for (let i = 0; i < ary.length; i++) {\n    let item = ary[i];\n    if (Array.isArray(ary[i])) {\n      fn(item);\n    } else {\n      result.push(item);\n    }\n  }\n};\n复制代码;\n\n\n\n# 5. 利用 reduce 函数迭代\n\nfunction flatten(ary) {\n  return ary.reduce((pre, cur) => {\n    return pre.concat(\n      Array.isArray(cur) ? flatten(cur) : cur,\n    );\n  }, []);\n}\nlet ary = [1, 2, [3, 4], [5, [6, 7]]];\nconsole.log(flatten(ary));\n复制代码;\n\n\n\n# 6：扩展运算符\n\n//只要有一个元素有数组，那么循环继续\nwhile (ary.some(Array.isArray)) {\n  ary = [].concat(...ary);\n}\n复制代码;\n\n\n这是一个比较实用而且很容易被问到的问题，欢迎大家交流补充。\n\n\n# 第十一篇: JS 数组的高阶函数——基础篇\n\n\n# 1.什么是高阶函数\n\n概念非常简单，如下:\n\n> 一个函数就可以接收另一个函数作为参数或者返回值为一个函数，这种函数就称之为高阶函数。\n\n那对应到数组中有哪些方法呢？\n\n\n# 2.数组中的高阶函数\n\n# 1.map\n\n * 参数:接受两个参数，一个是回调函数，一个是回调函数的 this 值(可选)。\n\n其中，回调函数被默认传入三个值，依次为当前元素、当前索引、整个数组。\n\n * 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果\n * 对原来的数组没有影响\n\nlet nums = [1, 2, 3];\nlet obj = { val: 5 };\nlet newNums = nums.map(function(item, index, array) {\n  return item + index + array[index] + this.val;\n  //对第一个元素，1 + 0 + 1 + 5 = 7\n  //对第二个元素，2 + 1 + 2 + 5 = 10\n  //对第三个元素，3 + 2 + 3 + 5 = 13\n}, obj);\nconsole.log(newNums); //[7, 10, 13]\n复制代码;\n\n\n当然，后面的参数都是可选的 ，不用的话可以省略。\n\n# 2. reduce\n\n * 参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中四个默认参数，依次为积累值、当前值、当前索引和整个数组。\n\nlet nums = [1, 2, 3];\n// 多个数的加和\nlet newNums = nums.reduce(function(\n  preSum,\n  curVal,\n  currentIndex,\n  array,\n) {\n  return preSum + curVal;\n},\n0);\nconsole.log(newNums); //6\n复制代码;\n\n\n不传默认值会怎样？\n\n不传默认值会自动以第一个元素为初始值，然后从第二个元素开始依次累计。\n\n# 3. filter\n\n参数: 一个函数参数。这个函数接受一个默认参数，就是当前元素。这个作为参数的函数返回值为一个布尔类型，决定元素是否保留。\n\nfilter 方法返回值为一个新的数组，这个数组里面包含参数里面所有被保留的项。\n\nlet nums = [1, 2, 3];\n// 保留奇数项\nlet oddNums = nums.filter((item) => item % 2);\nconsole.log(oddNums);\n复制代码;\n\n\n# 4. sort\n\n参数: 一个用于比较的函数，它有两个默认参数，分别是代表比较的两个元素。\n\n举个例子:\n\nlet nums = [2, 3, 1];\n//两个比较的元素分别为a, b\nnums.sort(function(a, b) {\n  if (a > b) return 1;\n  else if (a < b) return -1;\n  else if (a == b) return 0;\n});\n复制代码;\n\n\n当比较函数返回值大于 0，则 a 在 b 的后面，即 a 的下标应该比 b 大。\n\n反之，则 a 在 b 的后面，即 a 的下标比 b 小。\n\n整个过程就完成了一次升序的排列。\n\n当然还有一个需要注意的情况，就是比较函数不传的时候，是如何进行排序的？\n\n> 答案是将数字转换为字符串，然后根据字母 unicode 值进行升序排序，也就是根据字符串的比较规则进行升序排序。\n\n\n# 第十二篇: 能不能实现数组 map 方法 ?\n\n依照 ecma262 草案，实现的 map 的规范如下:\n\n\n\n下面根据草案的规定一步步来模拟实现 map 函数:\n\nArray.prototype.map = function(callbackFn, thisArg) {\n  // 处理数组类型异常\n  if (this === null || this === undefined) {\n    throw new TypeError(\n      \"Cannot read property 'map' of null or undefined\",\n    );\n  }\n  // 处理回调类型异常\n  if (\n    Object.prototype.toString.call(callbackfn) !=\n    '[object Function]'\n  ) {\n    throw new TypeError(callbackfn + ' is not a function');\n  }\n  // 草案中提到要先转换为对象\n  let O = Object(this);\n  let T = thisArg;\n\n  let len = O.length >>> 0;\n  let A = new Array(len);\n  for (let k = 0; k < len; k++) {\n    // 还记得原型链那一节提到的 in 吗？in 表示在原型链查找\n    // 如果用 hasOwnProperty 是有问题的，它只能找私有属性\n    if (k in O) {\n      let kValue = O[k];\n      // 依次传入this, 当前项，当前索引，整个数组\n      let mappedValue = callbackfn.call(T, KValue, k, O);\n      A[k] = mappedValue;\n    }\n  }\n  return A;\n};\n复制代码;\n\n\n这里解释一下, length >>> 0, 字面意思是指\"右移 0 位\"，但实际上是把前面的空位用 0 填充，这里的作用是保证 len 为数字且为整数。\n\n举几个特例：\n\nnull >>> 0  //0\n\nundefined >>> 0  //0\n\nvoid(0) >>> 0  //0\n\nfunction a (){};  a >>> 0  //0\n\n[] >>> 0  //0\n\nvar a = {}; a >>> 0  //0\n\n123123 >>> 0  //123123\n\n45.2 >>> 0  //45\n\n0 >>> 0  //0\n\n-0 >>> 0  //0\n\n-1 >>> 0  //4294967295\n\n-1212 >>> 0  //4294966084\n复制代码\n\n\n总体实现起来并没那么难，需要注意的就是使用 in 来进行原型链查找。同时，如果没有找到就不处理，能有效处理稀疏数组的情况。\n\n最后给大家奉上 V8 源码，参照源码检查一下，其实还是实现得很完整了。\n\nfunction ArrayMap(f, receiver) {\n  CHECK_OBJECT_COERCIBLE(this, 'Array.prototype.map');\n\n  // Pull out the length so that modifications to the length in the\n  // loop will not affect the looping and side effects are visible.\n  var array = TO_OBJECT(this);\n  var length = TO_LENGTH(array.length);\n  if (!IS_CALLABLE(f))\n    throw %make_type_error(kCalledNonCallable, f);\n  var result = ArraySpeciesCreate(array, length);\n  for (var i = 0; i < length; i++) {\n    if (i in array) {\n      var element = array[i];\n      %CreateDataProperty(\n        result,\n        i,\n        %_Call(f, receiver, element, i, array),\n      );\n    }\n  }\n  return result;\n}\n复制代码;\n\n\n参考:\n\nV8 源码\n\nArray 原型方法源码实现大揭秘\n\necma262 草案\n\n\n# 第十三篇: 能不能实现数组 reduce 方法 ?\n\n依照 ecma262 草案，实现的 reduce 的规范如下:\n\n\n\n其中有几个核心要点:\n\n1、初始值不传怎么处理\n\n2、回调函数的参数有哪些，返回值如何处理。\n\nArray.prototype.reduce = function(\n  callbackfn,\n  initialValue,\n) {\n  // 异常处理，和 map 一样\n  // 处理数组类型异常\n  if (this === null || this === undefined) {\n    throw new TypeError(\n      \"Cannot read property 'reduce' of null or undefined\",\n    );\n  }\n  // 处理回调类型异常\n  if (\n    Object.prototype.toString.call(callbackfn) !=\n    '[object Function]'\n  ) {\n    throw new TypeError(callbackfn + ' is not a function');\n  }\n  let O = Object(this);\n  let len = O.length >>> 0;\n  let k = 0;\n  let accumulator = initialValue;\n  if (accumulator === undefined) {\n    for (; k < len; k++) {\n      // 查找原型链\n      if (k in O) {\n        accumulator = O[k];\n        k++;\n        break;\n      }\n    }\n  }\n  // 表示数组全为空\n  if (k === len && accumulator === undefined)\n    throw new Error('Each element of the array is empty');\n  for (; k < len; k++) {\n    if (k in O) {\n      // 注意，核心！\n      accumulator = callbackfn.call(\n        undefined,\n        accumulator,\n        O[k],\n        k,\n        O,\n      );\n    }\n  }\n  return accumulator;\n};\n复制代码;\n\n\n其实是从最后一项开始遍历，通过原型链查找跳过空项。\n\n最后给大家奉上 V8 源码，以供大家检查:\n\nfunction ArrayReduce(callback, current) {\n  CHECK_OBJECT_COERCIBLE(this, 'Array.prototype.reduce');\n\n  // Pull out the length so that modifications to the length in the\n  // loop will not affect the looping and side effects are visible.\n  var array = TO_OBJECT(this);\n  var length = TO_LENGTH(array.length);\n  return InnerArrayReduce(\n    callback,\n    current,\n    array,\n    length,\n    arguments.length,\n  );\n}\n\nfunction InnerArrayReduce(\n  callback,\n  current,\n  array,\n  length,\n  argumentsLength,\n) {\n  if (!IS_CALLABLE(callback)) {\n    throw %make_type_error(kCalledNonCallable, callback);\n  }\n\n  var i = 0;\n  find_initial: if (argumentsLength < 2) {\n    for (; i < length; i++) {\n      if (i in array) {\n        current = array[i++];\n        break find_initial;\n      }\n    }\n    throw %make_type_error(kReduceNoInitial);\n  }\n\n  for (; i < length; i++) {\n    if (i in array) {\n      var element = array[i];\n      current = callback(current, element, i, array);\n    }\n  }\n  return current;\n}\n复制代码;\n\n\n参考:\n\nV8 源码\n\necma262 草案\n\n\n# 第十四篇: 能不能实现数组 push、pop 方法 ?\n\n参照 ecma262 草案的规定，关于 push 和 pop 的规范如下图所示:\n\n\n\n\n\n首先来实现一下 push 方法:\n\nArray.prototype.push = function(...items) {\n  let O = Object(this);\n  let len = this.length >>> 0;\n  let argCount = items.length >>> 0;\n  // 2 ** 53 - 1 为JS能表示的最大正整数\n  if (len + argCount > 2 ** 53 - 1) {\n    throw new TypeError(\n      'The number of array is over the max value restricted!',\n    );\n  }\n  for (let i = 0; i < argCount; i++) {\n    O[len + i] = items[i];\n  }\n  let newLength = len + argCount;\n  O.length = newLength;\n  return newLength;\n};\n复制代码;\n\n\n亲测已通过 MDN 上所有测试用例。MDN 链接\n\n然后来实现 pop 方法:\n\nArray.prototype.pop = function() {\n  let O = Object(this);\n  let len = this.length >>> 0;\n  if (len === 0) {\n    O.length = 0;\n    return undefined;\n  }\n  len--;\n  let value = O[len];\n  delete O[len];\n  O.length = len;\n  return value;\n};\n复制代码;\n\n\n亲测已通过 MDN 上所有测试用例。MDN 链接\n\n参考链接:\n\nV8 数组源码\n\necma262 规范草案\n\nMDN 文档\n\n\n# 第十五篇: 能不能实现数组 filter 方法 ?\n\n\n\n代码如下:\n\nArray.prototype.filter = function(callbackfn, thisArg) {\n  // 处理数组类型异常\n  if (this === null || this === undefined) {\n    throw new TypeError(\n      \"Cannot read property 'filter' of null or undefined\",\n    );\n  }\n  // 处理回调类型异常\n  if (\n    Object.prototype.toString.call(callbackfn) !=\n    '[object Function]'\n  ) {\n    throw new TypeError(callbackfn + ' is not a function');\n  }\n  let O = Object(this);\n  let len = O.length >>> 0;\n  let resLen = 0;\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    if (i in O) {\n      let element = O[i];\n      if (callbackfn.call(thisArg, O[i], i, O)) {\n        res[resLen++] = element;\n      }\n    }\n  }\n  return res;\n};\n复制代码;\n\n\nMDN 上所有测试用例亲测通过。\n\n参考:\n\nV8 数组部分源码第 1025 行\n\nMDN 中 filter 文档\n\n\n# 第十六篇: 能不能实现数组 splice 方法 ?\n\nsplice 可以说是最受欢迎的数组方法之一，api 灵活，使用方便。现在来梳理一下用法:\n\n * 1. splice(position, count) 表示从 position 索引的位置开始，删除 count 个元素\n * 1. splice(position, 0, ele1, ele2, ...) 表示从 position 索引的元素后面插入一系列的元素\n * 1. splice(postion, count, ele1, ele2, ...) 表示从 position 索引的位置开始，删除 count 个元素，然后再插入一系列的元素\n * 1. 返回值为被删除元素组成的数组。\n\n接下来我们实现这个方法。\n\n参照 ecma262 草案的规定，详情请点击。\n\n首先我们梳理一下实现的思路。\n\n\n\n\n# 初步实现\n\nArray.prototype.splice = function(\n  startIndex,\n  deleteCount,\n  ...addElements\n) {\n  let argumentsLen = arguments.length;\n  let array = Object(this);\n  let len = array.length;\n  let deleteArr = new Array(deleteCount);\n\n  // 拷贝删除的元素\n  sliceDeleteElements(\n    array,\n    startIndex,\n    deleteCount,\n    deleteArr,\n  );\n  // 移动删除元素后面的元素\n  movePostElements(\n    array,\n    startIndex,\n    len,\n    deleteCount,\n    addElements,\n  );\n  // 插入新元素\n  for (let i = 0; i < addElements.length; i++) {\n    array[startIndex + i] = addElements[i];\n  }\n  array.length = len - deleteCount + addElements.length;\n  return deleteArr;\n};\n复制代码;\n\n\n先拷贝删除的元素，如下所示:\n\nconst sliceDeleteElements = (\n  array,\n  startIndex,\n  deleteCount,\n  deleteArr,\n) => {\n  for (let i = 0; i < deleteCount; i++) {\n    let index = startIndex + i;\n    if (index in array) {\n      let current = array[index];\n      deleteArr[i] = current;\n    }\n  }\n};\n复制代码;\n\n\n然后对删除元素后面的元素进行挪动, 挪动分为三种情况:\n\n 1. 添加的元素和删除的元素个数相等\n 2. 添加的元素个数小于删除的元素\n 3. 添加的元素个数大于删除的元素\n\n当两者相等时，\n\nconst movePostElements = (\n  array,\n  startIndex,\n  len,\n  deleteCount,\n  addElements,\n) => {\n  if (deleteCount === addElements.length) return;\n};\n复制代码;\n\n\n当添加的元素个数小于删除的元素时, 如图所示:\n\n\n\nconst movePostElements = (\n  array,\n  startIndex,\n  len,\n  deleteCount,\n  addElements,\n) => {\n  //...\n  // 如果添加的元素和删除的元素个数不相等，则移动后面的元素\n  if (deleteCount > addElements.length) {\n    // 删除的元素比新增的元素多，那么后面的元素整体向前挪动\n    // 一共需要挪动 len - startIndex - deleteCount 个元素\n    for (let i = startIndex + deleteCount; i < len; i++) {\n      let fromIndex = i;\n      // 将要挪动到的目标位置\n      let toIndex = i - (deleteCount - addElements.length);\n      if (fromIndex in array) {\n        array[toIndex] = array[fromIndex];\n      } else {\n        delete array[toIndex];\n      }\n    }\n    // 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素\n    // 目前长度为 len + addElements - deleteCount\n    for (\n      let i = len - 1;\n      i >= len + addElements.length - deleteCount;\n      i--\n    ) {\n      delete array[i];\n    }\n  }\n};\n复制代码;\n\n\n当添加的元素个数大于删除的元素时, 如图所示:\n\n\n\nconst movePostElements = (\n  array,\n  startIndex,\n  len,\n  deleteCount,\n  addElements,\n) => {\n  //...\n  if (deleteCount < addElements.length) {\n    // 删除的元素比新增的元素少，那么后面的元素整体向后挪动\n    // 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？\n    for (\n      let i = len - 1;\n      i >= startIndex + deleteCount;\n      i--\n    ) {\n      let fromIndex = i;\n      // 将要挪动到的目标位置\n      let toIndex = i + (addElements.length - deleteCount);\n      if (fromIndex in array) {\n        array[toIndex] = array[fromIndex];\n      } else {\n        delete array[toIndex];\n      }\n    }\n  }\n};\n复制代码;\n\n\n\n# 优化一: 参数的边界情况\n\n当用户传来非法的 startIndex 和 deleteCount 或者负索引的时候，需要我们做出特殊的处理。\n\nconst computeStartIndex = (startIndex, len) => {\n  // 处理索引负数的情况\n  if (startIndex < 0) {\n    return startIndex + len > 0 ? startIndex + len : 0;\n  }\n  return startIndex >= len ? len : startIndex;\n};\n\nconst computeDeleteCount = (\n  startIndex,\n  len,\n  deleteCount,\n  argumentsLen,\n) => {\n  // 删除数目没有传，默认删除startIndex及后面所有的\n  if (argumentsLen === 1) return len - startIndex;\n  // 删除数目过小\n  if (deleteCount < 0) return 0;\n  // 删除数目过大\n  if (deleteCount > len - startIndex)\n    return len - startIndex;\n  return deleteCount;\n};\n\nArray.prototype.splice = function(\n  startIndex,\n  deleteCount,\n  ...addElements\n) {\n  //,...\n  let deleteArr = new Array(deleteCount);\n\n  // 下面参数的清洗工作\n  startIndex = computeStartIndex(startIndex, len);\n  deleteCount = computeDeleteCount(\n    startIndex,\n    len,\n    deleteCount,\n    argumentsLen,\n  );\n\n  // 拷贝删除的元素\n  sliceDeleteElements(\n    array,\n    startIndex,\n    deleteCount,\n    deleteArr,\n  );\n  //...\n};\n复制代码;\n\n\n\n# 优化二: 数组为密封对象或冻结对象\n\n什么是密封对象?\n\n> 密封对象是不可扩展的对象，而且已有成员的[[Configurable]]属性被设置为 false，这意味着不能添加、删除方法和属性。但是属性值是可以修改的。\n\n什么是冻结对象？\n\n> 冻结对象是最严格的防篡改级别，除了包含密封对象的限制外，还不能修改属性值。\n\n接下来，我们来把这两种情况一一排除。\n\n// 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象\nif (\n  Object.isSealed(array) &&\n  deleteCount !== addElements.length\n) {\n  throw new TypeError('the object is a sealed object!');\n} else if (\n  Object.isFrozen(array) &&\n  (deleteCount > 0 || addElements.length > 0)\n) {\n  throw new TypeError('the object is a frozen object!');\n}\n复制代码;\n\n\n好了，现在就写了一个比较完整的 splice，如下:\n\nconst sliceDeleteElements = (\n  array,\n  startIndex,\n  deleteCount,\n  deleteArr,\n) => {\n  for (let i = 0; i < deleteCount; i++) {\n    let index = startIndex + i;\n    if (index in array) {\n      let current = array[index];\n      deleteArr[i] = current;\n    }\n  }\n};\n\nconst movePostElements = (\n  array,\n  startIndex,\n  len,\n  deleteCount,\n  addElements,\n) => {\n  // 如果添加的元素和删除的元素个数相等，相当于元素的替换，数组长度不变，被删除元素后面的元素不需要挪动\n  if (deleteCount === addElements.length) return;\n  // 如果添加的元素和删除的元素个数不相等，则移动后面的元素\n  else if (deleteCount > addElements.length) {\n    // 删除的元素比新增的元素多，那么后面的元素整体向前挪动\n    // 一共需要挪动 len - startIndex - deleteCount 个元素\n    for (let i = startIndex + deleteCount; i < len; i++) {\n      let fromIndex = i;\n      // 将要挪动到的目标位置\n      let toIndex = i - (deleteCount - addElements.length);\n      if (fromIndex in array) {\n        array[toIndex] = array[fromIndex];\n      } else {\n        delete array[toIndex];\n      }\n    }\n    // 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素\n    // 目前长度为 len + addElements - deleteCount\n    for (\n      let i = len - 1;\n      i >= len + addElements.length - deleteCount;\n      i--\n    ) {\n      delete array[i];\n    }\n  } else if (deleteCount < addElements.length) {\n    // 删除的元素比新增的元素少，那么后面的元素整体向后挪动\n    // 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？\n    for (\n      let i = len - 1;\n      i >= startIndex + deleteCount;\n      i--\n    ) {\n      let fromIndex = i;\n      // 将要挪动到的目标位置\n      let toIndex = i + (addElements.length - deleteCount);\n      if (fromIndex in array) {\n        array[toIndex] = array[fromIndex];\n      } else {\n        delete array[toIndex];\n      }\n    }\n  }\n};\n\nconst computeStartIndex = (startIndex, len) => {\n  // 处理索引负数的情况\n  if (startIndex < 0) {\n    return startIndex + len > 0 ? startIndex + len : 0;\n  }\n  return startIndex >= len ? len : startIndex;\n};\n\nconst computeDeleteCount = (\n  startIndex,\n  len,\n  deleteCount,\n  argumentsLen,\n) => {\n  // 删除数目没有传，默认删除startIndex及后面所有的\n  if (argumentsLen === 1) return len - startIndex;\n  // 删除数目过小\n  if (deleteCount < 0) return 0;\n  // 删除数目过大\n  if (deleteCount > len - startIndex)\n    return len - startIndex;\n  return deleteCount;\n};\n\nArray.prototype.splice = function(\n  startIndex,\n  deleteCount,\n  ...addElements\n) {\n  let argumentsLen = arguments.length;\n  let array = Object(this);\n  let len = array.length >>> 0;\n  let deleteArr = new Array(deleteCount);\n\n  startIndex = computeStartIndex(startIndex, len);\n  deleteCount = computeDeleteCount(\n    startIndex,\n    len,\n    deleteCount,\n    argumentsLen,\n  );\n\n  // 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象\n  if (\n    Object.isSealed(array) &&\n    deleteCount !== addElements.length\n  ) {\n    throw new TypeError('the object is a sealed object!');\n  } else if (\n    Object.isFrozen(array) &&\n    (deleteCount > 0 || addElements.length > 0)\n  ) {\n    throw new TypeError('the object is a frozen object!');\n  }\n\n  // 拷贝删除的元素\n  sliceDeleteElements(\n    array,\n    startIndex,\n    deleteCount,\n    deleteArr,\n  );\n  // 移动删除元素后面的元素\n  movePostElements(\n    array,\n    startIndex,\n    len,\n    deleteCount,\n    addElements,\n  );\n\n  // 插入新元素\n  for (let i = 0; i < addElements.length; i++) {\n    array[startIndex + i] = addElements[i];\n  }\n\n  array.length = len - deleteCount + addElements.length;\n\n  return deleteArr;\n};\n复制代码;\n\n\n以上代码对照MDN 文档中的所有测试用例亲测通过。\n\n相关测试代码请前往: 传送门\n\n最后给大家奉上 V8 源码，供大家检查： V8 数组 splice 源码第 660 行\n\n\n# 第十七篇: 能不能实现数组 sort 方法？\n\n估计大家对 JS 数组的 sort 方法已经不陌生了，之前也对它的用法做了详细的总结。那，它的内部是如何来实现的呢？如果说我们能够进入它的内部去看一看， 理解背后的设计，会使我们的思维和素养得到不错的提升。\n\nsort 方法在 V8 内部相对与其他方法而言是一个比较高深的算法，对于很多边界情况做了反复的优化，但是这里我们不会直接拿源码来干讲。我们会来根据源码的思路，实现一个 跟引擎性能一样的排序算法，并且一步步拆解其中的奥秘。\n\n\n# V8 引擎的思路分析\n\n首先大概梳理一下源码中排序的思路:\n\n设要排序的元素个数是 n：\n\n * 当 n <= 10 时，采用插入排序\n\n * 当 n > 10 时，采用\n   \n   三路快速排序\n   \n   \n   * 10 < n <= 1000, 采用中位数作为哨兵元素\n   * n > 1000, 每隔 200~215 个元素挑出一个元素，放到一个新数组，然后对它排序，找到中间位置的数，以此作为中位数\n\n在动手之前，我觉得我们有必要为什么这么做搞清楚。\n\n第一、为什么元素个数少的时候要采用插入排序？\n\n虽然插入排序理论上说是 O(n^2)的算法，快速排序是一个 O(nlogn)级别的算法。但是别忘了，这只是理论上的估算，在实际情况中两者的算法复杂度前面都会有一个系数的， 当 n 足够小的时候，快速排序nlogn的优势会越来越小，倘若插入排序 O(n^2)前面的系数足够小，那么就会超过快排。而事实上正是如此，插入排序经过优化以后对于小数据集的排序会有非常优越的性能，很多时候甚至会超过快排。\n\n因此，对于很小的数据量，应用插入排序是一个非常不错的选择。\n\n第二、为什么要花这么大的力气选择哨兵元素？\n\n因为快速排序的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行 partition(一边是小于哨兵的元素，另一边是大于哨兵的元素)时，就会有一边是空的，那么这么排下去，递归的层数就达到了 n, 而每一层的复杂度是 O(n)，因此快排这时候会退化成 O(n^2)级别。\n\n这种情况是要尽力避免的！如果来避免？\n\n就是让哨兵元素进可能地处于数组的中间位置，让最大或者最小的情况尽可能少。这时候，你就能理解 V8 里面所做的种种优化了。\n\n接下来，我们来一步步实现的这样的官方排序算法。\n\n\n# 插入排序及优化\n\n最初的插入排序可能是这样写的:\n\nconst insertSort = (arr, start = 0, end) => {\n  end = end || arr.length;\n  for (let i = start; i < end; i++) {\n    let j;\n    for (j = i; j > start && arr[j - 1] > arr[j]; j--) {\n      let temp = arr[j];\n      arr[j] = arr[j - 1];\n      arr[j - 1] = temp;\n    }\n  }\n  return;\n};\n复制代码;\n\n\n看似可以正确的完成排序，但实际上交换元素会有相当大的性能消耗，我们完全可以用变量覆盖的方式来完成，如图所示:\n\n\n\n优化后代码如下:\n\nconst insertSort = (arr, start = 0, end) => {\n  end = end || arr.length;\n  for (let i = start; i < end; i++) {\n    let e = arr[i];\n    let j;\n    for (j = i; j > start && arr[j - 1] > e; j--)\n      arr[j] = arr[j - 1];\n    arr[j] = e;\n  }\n  return;\n};\n复制代码;\n\n\n接下来正式进入到 sort 方法。\n\n\n# 寻找哨兵元素\n\nsort 的骨架大致如下:\n\nArray.prototype.sort = (comparefn) => {\n  let array = Object(this);\n  let length = array.length >>> 0;\n  return InnerArraySort(array, length, comparefn);\n};\n\nconst InnerArraySort = (array, length, comparefn) => {\n  // 比较函数未传入\n  if (\n    Object.prototype.toString.call(callbackfn) !==\n    '[object Function]'\n  ) {\n    comparefn = function(x, y) {\n      if (x === y) return 0;\n      x = x.toString();\n      y = y.toString();\n      if (x == y) return 0;\n      else return x < y ? -1 : 1;\n    };\n  }\n  const insertSort = () => {\n    //...\n  };\n  const getThirdIndex = (a, from, to) => {\n    // 元素个数大于1000时寻找哨兵元素\n  };\n  const quickSort = (a, from, to) => {\n    //哨兵位置\n    let thirdIndex = 0;\n    while (true) {\n      if (to - from <= 10) {\n        insertSort(a, from, to);\n        return;\n      }\n      if (to - from > 1000) {\n        thirdIndex = getThirdIndex(a, from, to);\n      } else {\n        // 小于1000 直接取中点\n        thirdIndex = from + ((to - from) >> 2);\n      }\n    }\n    //下面开始快排\n  };\n};\n复制代码;\n\n\n我们先来把求取哨兵位置的代码实现一下:\n\nconst getThirdIndex = (a, from, to) => {\n  let tmpArr = [];\n  // 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的\n  let increment = 200 + ((to - from) & 15);\n  let j = 0;\n  from += 1;\n  to -= 1;\n  for (let i = from; i < to; i += increment) {\n    tmpArr[j] = [i, a[i]];\n    j++;\n  }\n  // 把临时数组排序，取中间的值，确保哨兵的值接近平均位置\n  tmpArr.sort(function(a, b) {\n    return comparefn(a[1], b[1]);\n  });\n  let thirdIndex = tmpArr[tmpArr.length >> 1][0];\n  return thirdIndex;\n};\n复制代码;\n\n\n\n# 完成快排\n\n接下来我们来完成快排的具体代码：\n\nconst _sort = (a, b, c) => {\n  let arr = [a, b, c];\n  insertSort(arr, 0, 3);\n  return arr;\n};\n\nconst quickSort = (a, from, to) => {\n  //...\n  // 上面我们拿到了thirdIndex\n  // 现在我们拥有三个元素，from, thirdIndex, to\n  // 为了再次确保 thirdIndex 不是最值，把这三个值排序\n  [a[from], a[thirdIndex], a[to - 1]] = _sort(\n    a[from],\n    a[thirdIndex],\n    a[to - 1],\n  );\n  // 现在正式把 thirdIndex 作为哨兵\n  let pivot = a[thirdIndex];\n  // 正式进入快排\n  let lowEnd = from + 1;\n  let highStart = to - 1;\n  // 现在正式把 thirdIndex 作为哨兵, 并且lowEnd和thirdIndex交换\n  let pivot = a[thirdIndex];\n  a[thirdIndex] = a[lowEnd];\n  a[lowEnd] = pivot;\n\n  // [lowEnd, i)的元素是和pivot相等的\n  // [i, highStart) 的元素是需要处理的\n  for (let i = lowEnd + 1; i < highStart; i++) {\n    let element = a[i];\n    let order = comparefn(element, pivot);\n    if (order < 0) {\n      a[i] = a[lowEnd];\n      a[lowEnd] = element;\n      lowEnd++;\n    } else if (order > 0) {\n      do {\n        highStart--;\n        if (highStart === i) break;\n        order = comparefn(a[highStart], pivot);\n      } while (order > 0);\n      // 现在 a[highStart] <= pivot\n      // a[i] > pivot\n      // 两者交换\n      a[i] = a[highStart];\n      a[highStart] = element;\n      if (order < 0) {\n        // a[i] 和 a[lowEnd] 交换\n        element = a[i];\n        a[i] = a[lowEnd];\n        a[lowEnd] = element;\n        lowEnd++;\n      }\n    }\n  }\n  // 永远切分大区间\n  if (lowEnd - from > to - highStart) {\n    // 继续切分lowEnd ~ from 这个区间\n    to = lowEnd;\n    // 单独处理小区间\n    quickSort(a, highStart, to);\n  } else if (lowEnd - from <= to - highStart) {\n    from = highStart;\n    quickSort(a, from, lowEnd);\n  }\n};\n复制代码;\n\n\n\n# 测试结果\n\n测试结果如下:\n\n一万条数据:\n\n\n\n十万条数据:\n\n\n\n一百万条数据:\n\n\n\n一千万条数据:\n\n\n\n结果仅供大家参考，因为不同的 node 版本对于部分细节的实现可能不一样，我现在的版本是 v10.15。\n\n从结果可以看到，目前版本的 node 对于有序程度较高的数据是处理的不够好的，而我们刚刚实现的排序通过反复确定哨兵的位置就能 有效的规避快排在这一场景下的劣势。\n\n最后给大家完整版的 sort 代码:\n\nconst sort = (arr, comparefn) => {\n  let array = Object(arr);\n  let length = array.length >>> 0;\n  return InnerArraySort(array, length, comparefn);\n};\n\nconst InnerArraySort = (array, length, comparefn) => {\n  // 比较函数未传入\n  if (\n    Object.prototype.toString.call(comparefn) !==\n    '[object Function]'\n  ) {\n    comparefn = function(x, y) {\n      if (x === y) return 0;\n      x = x.toString();\n      y = y.toString();\n      if (x == y) return 0;\n      else return x < y ? -1 : 1;\n    };\n  }\n  const insertSort = (arr, start = 0, end) => {\n    end = end || arr.length;\n    for (let i = start; i < end; i++) {\n      let e = arr[i];\n      let j;\n      for (\n        j = i;\n        j > start && comparefn(arr[j - 1], e) > 0;\n        j--\n      )\n        arr[j] = arr[j - 1];\n      arr[j] = e;\n    }\n    return;\n  };\n  const getThirdIndex = (a, from, to) => {\n    let tmpArr = [];\n    // 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的\n    let increment = 200 + ((to - from) & 15);\n    let j = 0;\n    from += 1;\n    to -= 1;\n    for (let i = from; i < to; i += increment) {\n      tmpArr[j] = [i, a[i]];\n      j++;\n    }\n    // 把临时数组排序，取中间的值，确保哨兵的值接近平均位置\n    tmpArr.sort(function(a, b) {\n      return comparefn(a[1], b[1]);\n    });\n    let thirdIndex = tmpArr[tmpArr.length >> 1][0];\n    return thirdIndex;\n  };\n\n  const _sort = (a, b, c) => {\n    let arr = [];\n    arr.push(a, b, c);\n    insertSort(arr, 0, 3);\n    return arr;\n  };\n\n  const quickSort = (a, from, to) => {\n    //哨兵位置\n    let thirdIndex = 0;\n    while (true) {\n      if (to - from <= 10) {\n        insertSort(a, from, to);\n        return;\n      }\n      if (to - from > 1000) {\n        thirdIndex = getThirdIndex(a, from, to);\n      } else {\n        // 小于1000 直接取中点\n        thirdIndex = from + ((to - from) >> 2);\n      }\n      let tmpArr = _sort(a[from], a[thirdIndex], a[to - 1]);\n      a[from] = tmpArr[0];\n      a[thirdIndex] = tmpArr[1];\n      a[to - 1] = tmpArr[2];\n      // 现在正式把 thirdIndex 作为哨兵\n      let pivot = a[thirdIndex];\n      [a[from], a[thirdIndex]] = [a[thirdIndex], a[from]];\n      // 正式进入快排\n      let lowEnd = from + 1;\n      let highStart = to - 1;\n      a[thirdIndex] = a[lowEnd];\n      a[lowEnd] = pivot;\n      // [lowEnd, i)的元素是和pivot相等的\n      // [i, highStart) 的元素是需要处理的\n      for (let i = lowEnd + 1; i < highStart; i++) {\n        let element = a[i];\n        let order = comparefn(element, pivot);\n        if (order < 0) {\n          a[i] = a[lowEnd];\n          a[lowEnd] = element;\n          lowEnd++;\n        } else if (order > 0) {\n          do {\n            highStart--;\n            if (highStart === i) break;\n            order = comparefn(a[highStart], pivot);\n          } while (order > 0);\n          // 现在 a[highStart] <= pivot\n          // a[i] > pivot\n          // 两者交换\n          a[i] = a[highStart];\n          a[highStart] = element;\n          if (order < 0) {\n            // a[i] 和 a[lowEnd] 交换\n            element = a[i];\n            a[i] = a[lowEnd];\n            a[lowEnd] = element;\n            lowEnd++;\n          }\n        }\n      }\n      // 永远切分大区间\n      if (lowEnd - from > to - highStart) {\n        // 单独处理小区间\n        quickSort(a, highStart, to);\n        // 继续切分lowEnd ~ from 这个区间\n        to = lowEnd;\n      } else if (lowEnd - from <= to - highStart) {\n        quickSort(a, from, lowEnd);\n        from = highStart;\n      }\n    }\n  };\n  quickSort(array, 0, length);\n};\n复制代码;\n\n\n参考链接:\n\nV8 sort 源码(点开第 997 行)\n\n冴羽排序源码专题\n\n\n# 第十八篇: 能不能模拟实现一个 new 的效果？\n\nnew被调用后做了三件事情:\n\n 1. 让实例可以访问到私有属性\n 2. 让实例可以访问构造函数原型(constructor.prototype)所在原型链上的属性\n 3. 如果构造函数返回的结果不是引用数据类型\n\nfunction newOperator(ctor, ...args) {\n    if(typeof ctor !== 'function'){\n      throw 'newOperator function the first param must be a function';\n    }\n    let obj = Object.create(ctor.prototype);\n    let res = ctor.apply(obj, args);\n\n    let isObject = typeof res === 'object' && res !== null;\n    let isFunction = typoof res === 'function';\n    return isObect || isFunction ? res : obj;\n};\n复制代码\n\n\n\n# 第十九篇: 能不能模拟实现一个 bind 的效果？\n\n实现 bind 之前，我们首先要知道它做了哪些事情。\n\n 1. 对于普通函数，绑定 this 指向\n 2. 对于构造函数，要保证原函数的原型对象上的属性不能丢失\n\nFunction.prototype.bind = function(context, ...args) {\n  // 异常处理\n  if (typeof this !== 'function') {\n    throw new Error(\n      'Function.prototype.bind - what is trying to be bound is not callable',\n    );\n  }\n  // 保存this的值，它代表调用 bind 的函数\n  var self = this;\n  var fNOP = function() {};\n\n  var fbound = function() {\n    self.apply(\n      this instanceof self ? this : context,\n      args.concat(Array.prototype.slice.call(arguments)),\n    );\n  };\n\n  fNOP.prototype = this.prototype;\n  fbound.prototype = new fNOP();\n\n  return fbound;\n};\n复制代码;\n\n\n也可以这么用 Object.create 来处理原型:\n\nFunction.prototype.bind = function(context, ...args) {\n  if (typeof this !== 'function') {\n    throw new Error(\n      'Function.prototype.bind - what is trying to be bound is not callable',\n    );\n  }\n\n  var self = this;\n\n  var fbound = function() {\n    self.apply(\n      this instanceof self ? this : context,\n      args.concat(Array.prototype.slice.call(arguments)),\n    );\n  };\n\n  fbound.prototype = Object.create(self.prototype);\n\n  return fbound;\n};\n复制代码;\n\n\n\n# 第二十篇: 能不能实现一个 call/apply 函数？\n\n引自冴羽大佬的代码，可以说比较完整了。\n\nFunction.prototype.call = function(context) {\n  let context = context || window;\n  let fn = Symbol('fn');\n  context.fn = this;\n\n  let args = [];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    args.push('arguments[' + i + ']');\n  }\n\n  let result = eval('context.fn(' + args + ')');\n\n  delete context.fn;\n  return result;\n};\n复制代码;\n\n\n不过我认为换成 ES6 的语法会更精炼一些:\n\nFunction.prototype.call = function(context, ...args) {\n  let context = context || window;\n  let fn = Symbol('fn');\n  context.fn = this;\n\n  let result = eval('context.fn(...args)');\n\n  delete context.fn;\n  return result;\n};\n复制代码;\n\n\n类似的，有 apply 的对应实现:\n\nFunction.prototype.apply = function(context, args) {\n  let context = context || window;\n  context.fn = this;\n  let result = eval('context.fn(...args)');\n\n  delete context.fn;\n  return result;\n};\n复制代码;\n\n\n\n# 第二十一篇: 谈谈你对 JS 中 this 的理解。\n\n其实 JS 中的 this 是一个非常简单的东西，只需要理解它的执行规则就 OK。\n\n在这里不想像其他博客一样展示太多的代码例子弄得天花乱坠， 反而不易理解。\n\ncall/apply/bind 可以显式绑定, 这里就不说了。\n\n主要这些场隐式绑定的场景讨论:\n\n 1. 全局上下文\n 2. 直接调用函数\n 3. 对象.方法的形式调用\n 4. DOM 事件绑定(特殊)\n 5. new 构造函数绑定\n 6. 箭头函数\n\n\n# 1. 全局上下文\n\n全局上下文默认 this 指向 window, 严格模式下指向 undefined。\n\n\n# 2. 直接调用函数\n\n比如:\n\nlet obj = {\n  a: function() {\n    console.log(this);\n  },\n};\nlet func = obj.a;\nfunc();\n复制代码;\n\n\n这种情况是直接调用。this 相当于全局上下文的情况。\n\n\n# 3. 对象.方法的形式调用\n\n还是刚刚的例子，我如果这样写:\n\nobj.a();\n复制代码;\n\n\n这就是对象.方法的情况，this 指向这个对象\n\n\n# 4. DOM 事件绑定\n\nonclick 和 addEventerListener 中 this 默认指向绑定事件的元素。\n\nIE 比较奇异，使用 attachEvent，里面的 this 默认指向 window。\n\n\n# 5. new+构造函数\n\n此时构造函数中的 this 指向实例对象。\n\n\n# 6. 箭头函数？\n\n箭头函数没有 this, 因此也不能绑定。里面的 this 会指向当前最近的非箭头函数的 this，找不到就是 window(严格模式是 undefined)。比如:\n\nlet obj = {\n  a: function() {\n    let do = () => {\n      console.log(this);\n    }\n    do();\n  }\n}\nobj.a(); // 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj\n复制代码\n\n\n> 优先级: new > call、apply、bind > 对象.方法 > 直接调用。\n\n\n# 第二十二篇: JS 中浅拷贝的手段有哪些？\n\n\n# 重要: 什么是拷贝？\n\n首先来直观的感受一下什么是拷贝。\n\nlet arr = [1, 2, 3];\nlet newArr = arr;\nnewArr[0] = 100;\n\nconsole.log(arr); //[100, 2, 3]\n复制代码;\n\n\n这是直接赋值的情况，不涉及任何拷贝。当改变 newArr 的时候，由于是同一个引用，arr 指向的值也跟着改变。\n\n现在进行浅拷贝:\n\nlet arr = [1, 2, 3];\nlet newArr = arr.slice();\nnewArr[0] = 100;\n\nconsole.log(arr); //[1, 2, 3]\n复制代码;\n\n\n当修改 newArr 的时候，arr 的值并不改变。什么原因?因为这里 newArr 是 arr 浅拷贝后的结果，newArr 和 arr 现在引用的已经不是同一块空间啦！\n\n这就是浅拷贝！\n\n但是这又会带来一个潜在的问题:\n\nlet arr = [1, 2, { val: 4 }];\nlet newArr = arr.slice();\nnewArr[2].val = 1000;\n\nconsole.log(arr); //[ 1, 2, { val: 1000 } ]\n复制代码;\n\n\n咦!不是已经不是同一块空间的引用了吗？为什么改变了 newArr 改变了第二个元素的 val 值，arr 也跟着变了。\n\n这就是浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，它能 解决无限极的对象嵌套问题，实现彻底的拷贝。当然，这是我们下一篇的重点。 现在先让大家有一个基本的概念。\n\n接下来，我们来研究一下 JS 中实现浅拷贝到底有多少种方式？\n\n\n# 1. 手动实现\n\nconst shallowClone = (target) => {\n  if (typeof target === 'object' && target !== null) {\n    const cloneTarget = Array.isArray(target) ? [] : {};\n    for (let prop in target) {\n      if (target.hasOwnProperty(prop)) {\n        cloneTarget[prop] = target[prop];\n      }\n    }\n    return cloneTarget;\n  } else {\n    return target;\n  }\n};\n复制代码;\n\n\n\n# 2. Object.assign\n\n但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。\n\nlet obj = { name: 'sy', age: 18 };\nconst obj2 = Object.assign({}, obj, { name: 'sss' });\nconsole.log(obj2); //{ name: 'sss', age: 18 }\n复制代码;\n\n\n\n# 3. concat 浅拷贝数组\n\nlet arr = [1, 2, 3];\nlet newArr = arr.concat();\nnewArr[1] = 100;\nconsole.log(arr); //[ 1, 2, 3 ]\n复制代码;\n\n\n\n# 4. slice 浅拷贝\n\n开头的例子不就说的这个嘛！\n\n\n# 5. ...展开运算符\n\nlet arr = [1, 2, 3];\nlet newArr = [...arr]; //跟arr.slice()是一样的效果\n复制代码;\n\n\n\n# 第二十三篇: 能不能写一个完整的深拷贝？\n\n上一篇已经解释了什么是深拷贝，现在我们来一起实现一个完整且专业的深拷贝。\n\n\n# 1. 简易版及问题\n\nJSON.parse(JSON.stringify());\n复制代码;\n\n\n估计这个 api 能覆盖大多数的应用场景，没错，谈到深拷贝，我第一个想到的也是它。但是实际上，对于某些严格的场景来说，这个方法是有巨大的坑的。问题如下：\n\n>  1. 无法解决循环引用的问题。举个例子：\n\nconst a = { val: 2 };\na.target = a;\n复制代码;\n\n\n拷贝 a 会出现系统栈溢出，因为出现了无限递归的情况。\n\n>  1. 无法拷贝一写特殊的对象，诸如 RegExp, Date, Set, Map 等。\n\n>  1. 无法拷贝函数(划重点)。\n\n因此这个 api 先 pass 掉，我们重新写一个深拷贝，简易版如下:\n\nconst deepClone = (target) => {\n  if (typeof target === 'object' && target !== null) {\n    const cloneTarget = Array.isArray(target) ? [] : {};\n    for (let prop in target) {\n      if (target.hasOwnProperty(prop)) {\n        cloneTarget[prop] = deepClone(target[prop]);\n      }\n    }\n    return cloneTarget;\n  } else {\n    return target;\n  }\n};\n复制代码;\n\n\n现在，我们以刚刚发现的三个问题为导向，一步步来完善、优化我们的深拷贝代码。\n\n\n# 2. 解决循环引用\n\n现在问题如下:\n\nlet obj = { val: 100 };\nobj.target = obj;\n\ndeepClone(obj); //报错: RangeError: Maximum call stack size exceeded\n复制代码;\n\n\n这就是循环引用。我们怎么来解决这个问题呢？\n\n创建一个 Map。记录下已经拷贝过的对象，如果说已经拷贝过，那直接返回它行了。\n\nconst isObject = (target) =>\n  (typeof target === 'object' ||\n    typeof target === 'function') &&\n  target !== null;\n\nconst deepClone = (target, map = new Map()) => {\n  if (map.get(target)) return target;\n\n  if (isObject(target)) {\n    map.set(target, true);\n    const cloneTarget = Array.isArray(target) ? [] : {};\n    for (let prop in target) {\n      if (target.hasOwnProperty(prop)) {\n        cloneTarget[prop] = deepClone(target[prop], map);\n      }\n    }\n    return cloneTarget;\n  } else {\n    return target;\n  }\n};\n复制代码;\n\n\n现在来试一试：\n\nconst a = { val: 2 };\na.target = a;\nlet newA = deepClone(a);\nconsole.log(newA); //{ val: 2, target: { val: 2, target: [Circular] } }\n复制代码;\n\n\n好像是没有问题了, 拷贝也完成了。但还是有一个潜在的坑, 就是 map 上的 key 和 map 构成了强引用关系，这是相当危险的。我给你解释一下与之相对的弱引用的概念你就明白了：\n\n> 在计算机程序设计中，弱引用与强引用相对，\n\n是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 --百度百科\n\n说的有一点绕，我用大白话解释一下，被弱引用的对象可以在任何时候被回收，而对于强引用来说，只要这个强引用还在，那么对象无法被回收。拿上面的例子说，map 和 a 一直是强引用的关系， 在程序结束之前，a 所占的内存空间一直不会被释放。\n\n怎么解决这个问题？\n\n很简单，让 map 的 key 和 map 构成弱引用即可。ES6 给我们提供了这样的数据结构，它的名字叫WeakMap，它是一种特殊的 Map, 其中的键是弱引用的。其键必须是对象，而值可以是任意的。\n\n稍微改造一下即可:\n\nconst deepClone = (target, map = new WeakMap()) => {\n  //...\n};\n复制代码;\n\n\n\n# 3. 拷贝特殊对象\n\n# 可继续遍历\n\n对于特殊的对象，我们使用以下方式来鉴别:\n\nObject.prototype.toString.call(obj);\n复制代码;\n\n\n梳理一下对于可遍历对象会有什么结果：\n\n['object Map']['object Set']['object Array'][\n  'object Object'\n]['object Arguments'];\n复制代码;\n\n\n好，以这些不同的字符串为依据，我们就可以成功地鉴别这些对象。\n\nconst getType = Object.prototype.toString.call(obj);\n\nconst canTraverse = {\n  '[object Map]': true,\n  '[object Set]': true,\n  '[object Array]': true,\n  '[object Object]': true,\n  '[object Arguments]': true,\n};\n\nconst deepClone = (target, map = new Map()) => {\n  if (!isObject(target)) return target;\n  let type = getType(target);\n  let cloneTarget;\n  if (!canTraverse[type]) {\n    // 处理不能遍历的对象\n    return;\n  } else {\n    // 这波操作相当关键，可以保证对象的原型不丢失！\n    let ctor = target.prototype;\n    cloneTarget = new ctor();\n  }\n\n  if (map.get(target)) return target;\n  map.put(target, true);\n\n  if (type === mapTag) {\n    //处理Map\n    target.forEach((item, key) => {\n      cloneTarget.set(deepClone(key), deepClone(item));\n    });\n  }\n\n  if (type === setTag) {\n    //处理Set\n    target.forEach((item) => {\n      target.add(deepClone(item));\n    });\n  }\n\n  // 处理数组和对象\n  for (let prop in target) {\n    if (target.hasOwnProperty(prop)) {\n      cloneTarget[prop] = deepClone(target[prop]);\n    }\n  }\n  return cloneTarget;\n};\n复制代码;\n\n\n# 不可遍历的对象\n\nconst boolTag = '[object Boolean]';\nconst numberTag = '[object Number]';\nconst stringTag = '[object String]';\nconst dateTag = '[object Date]';\nconst errorTag = '[object Error]';\nconst regexpTag = '[object RegExp]';\nconst funcTag = '[object Function]';\n复制代码;\n\n\n对于不可遍历的对象，不同的对象有不同的处理。\n\nconst handleRegExp = (target) => {\n  const { source, flags } = target;\n  return new target.constructor(source, flags);\n};\n\nconst handleFunc = (target) => {\n  // 待会的重点部分\n};\n\nconst handleNotTraverse = (target, tag) => {\n  const Ctor = targe.constructor;\n  switch (tag) {\n    case boolTag:\n    case numberTag:\n    case stringTag:\n    case errorTag:\n    case dateTag:\n      return new Ctor(target);\n    case regexpTag:\n      return handleRegExp(target);\n    case funcTag:\n      return handleFunc(target);\n    default:\n      return new Ctor(target);\n  }\n};\n复制代码;\n\n\n\n# 4. 拷贝函数\n\n虽然函数也是对象，但是它过于特殊，我们单独把它拿出来拆解。\n\n提到函数，在 JS 种有两种函数，一种是普通函数，另一种是箭头函数。每个普通函数都是 Function 的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用。那我们只需要 处理普通函数的情况，箭头函数直接返回它本身就好了。\n\n那么如何来区分两者呢？\n\n答案是: 利用原型。箭头函数是不存在原型的。\n\n代码如下:\n\nconst handleFunc = (func) => {\n  // 箭头函数直接返回自身\n  if (!func.prototype) return func;\n  const bodyReg = /(?<={)(.|\\n)+(?=})/m;\n  const paramReg = /(?<=\\().+(?=\\)\\s+{)/;\n  const funcString = func.toString();\n  // 分别匹配 函数参数 和 函数体\n  const param = paramReg.exec(funcString);\n  const body = bodyReg.exec(funcString);\n  if (!body) return null;\n  if (param) {\n    const paramArr = param[0].split(',');\n    return new Function(...paramArr, body[0]);\n  } else {\n    return new Function(body[0]);\n  }\n};\n复制代码;\n\n\n到现在，我们的深拷贝就实现地比较完善了。不过在测试的过程中，我也发现了一个小小的 bug。\n\n\n# 5. 小小的 bug\n\n如下所示:\n\nconst target = new Boolean(false);\nconst Ctor = target.constructor;\nnew Ctor(target); // 结果为 Boolean {true} 而不是 false。\n复制代码;\n\n\n对于这样一个 bug，我们可以对 Boolean 拷贝做最简单的修改， 调用 valueOf: new target.constructor(target.valueOf())。\n\n但实际上，这种写法是不推荐的。因为在 ES6 后不推荐使用【new 基本类型()】这 样的语法，所以 es6 中的新类型 Symbol 是不能直接 new 的，只能通过 new Object(SymbelType)。\n\n因此我们接下来统一一下:\n\nconst handleNotTraverse = (target, tag) => {\n  const Ctor = targe.constructor;\n  switch (tag) {\n    case boolTag:\n      return new Object(\n        Boolean.prototype.valueOf.call(target),\n      );\n    case numberTag:\n      return new Object(\n        Number.prototype.valueOf.call(target),\n      );\n    case stringTag:\n      return new Object(\n        String.prototype.valueOf.call(target),\n      );\n    case errorTag:\n    case dateTag:\n      return new Ctor(target);\n    case regexpTag:\n      return handleRegExp(target);\n    case funcTag:\n      return handleFunc(target);\n    default:\n      return new Ctor(target);\n  }\n};\n复制代码;\n\n\n\n# 6. 完整代码展示\n\nOK!是时候给大家放出完整版的深拷贝啦:\n\nconst getType = (obj) =>\n  Object.prototype.toString.call(obj);\n\nconst isObject = (target) =>\n  (typeof target === 'object' ||\n    typeof target === 'function') &&\n  target !== null;\n\nconst canTraverse = {\n  '[object Map]': true,\n  '[object Set]': true,\n  '[object Array]': true,\n  '[object Object]': true,\n  '[object Arguments]': true,\n};\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst boolTag = '[object Boolean]';\nconst numberTag = '[object Number]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\nconst dateTag = '[object Date]';\nconst errorTag = '[object Error]';\nconst regexpTag = '[object RegExp]';\nconst funcTag = '[object Function]';\n\nconst handleRegExp = (target) => {\n  const { source, flags } = target;\n  return new target.constructor(source, flags);\n};\n\nconst handleFunc = (func) => {\n  // 箭头函数直接返回自身\n  if (!func.prototype) return func;\n  const bodyReg = /(?<={)(.|\\n)+(?=})/m;\n  const paramReg = /(?<=\\().+(?=\\)\\s+{)/;\n  const funcString = func.toString();\n  // 分别匹配 函数参数 和 函数体\n  const param = paramReg.exec(funcString);\n  const body = bodyReg.exec(funcString);\n  if (!body) return null;\n  if (param) {\n    const paramArr = param[0].split(',');\n    return new Function(...paramArr, body[0]);\n  } else {\n    return new Function(body[0]);\n  }\n};\n\nconst handleNotTraverse = (target, tag) => {\n  const Ctor = target.constructor;\n  switch (tag) {\n    case boolTag:\n      return new Object(\n        Boolean.prototype.valueOf.call(target),\n      );\n    case numberTag:\n      return new Object(\n        Number.prototype.valueOf.call(target),\n      );\n    case stringTag:\n      return new Object(\n        String.prototype.valueOf.call(target),\n      );\n    case symbolTag:\n      return new Object(\n        Symbol.prototype.valueOf.call(target),\n      );\n    case errorTag:\n    case dateTag:\n      return new Ctor(target);\n    case regexpTag:\n      return handleRegExp(target);\n    case funcTag:\n      return handleFunc(target);\n    default:\n      return new Ctor(target);\n  }\n};\n\nconst deepClone = (target, map = new WeakMap()) => {\n  if (!isObject(target)) return target;\n  let type = getType(target);\n  let cloneTarget;\n  if (!canTraverse[type]) {\n    // 处理不能遍历的对象\n    return handleNotTraverse(target, type);\n  } else {\n    // 这波操作相当关键，可以保证对象的原型不丢失！\n    let ctor = target.constructor;\n    cloneTarget = new ctor();\n  }\n\n  if (map.get(target)) return target;\n  map.set(target, true);\n\n  if (type === mapTag) {\n    //处理Map\n    target.forEach((item, key) => {\n      cloneTarget.set(\n        deepClone(key, map),\n        deepClone(item, map),\n      );\n    });\n  }\n\n  if (type === setTag) {\n    //处理Set\n    target.forEach((item) => {\n      cloneTarget.add(deepClone(item, map));\n    });\n  }\n\n  // 处理数组和对象\n  for (let prop in target) {\n    if (target.hasOwnProperty(prop)) {\n      cloneTarget[prop] = deepClone(target[prop], map);\n    }\n  }\n  return cloneTarget;\n};\n\n\n\n# 第 24 篇: JavaScript 内存机制之问——数据是如何存储的？\n\n网上的资料基本是这样说的: 基本数据类型用栈存储，引用数据类型用堆存储。\n\n看起来没有错误，但实际上是有问题的。可以考虑一下闭包的情况，如果变量存在栈中，那函数调用完栈顶空间销毁，闭包变量不就没了吗？\n\n其实还是需要补充一句:\n\n> 闭包变量是存在堆内存中的。\n\n具体而言，以下数据类型存储在栈中:\n\n * boolean\n * null\n * undefined\n * number\n * string\n * symbol\n * bigint\n\n而所有的对象数据类型存放在堆中。\n\n值得注意的是，对于赋值操作，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。\n\n因此会有下面的情况:\n\nlet obj = { a: 1 };\nlet newObj = obj;\nnewObj.a = 2;\nconsole.log(obj.a); //变成了2\n复制代码;\n\n\n之所以会这样，是因为 obj 和 newObj 是同一份堆空间的地址，改变 newObj，等于改变了共同的堆内存，这时候通过 obj 来获取这块内存的值当然会改变。\n\n当然，你可能会问: 为什么不全部用栈来保存呢？\n\n首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:\n\nfunction f(a) {\n  console.log(a);\n}\n\nfunction func(a) {\n  f(a);\n}\n\nfunc(1);\n复制代码;\n\n\n假设用 ESP 指针来保存当前的执行状态，在系统栈中会产生如下的过程：\n\n 1. 调用 func, 将 func 函数的上下文压栈，ESP 指向栈顶。\n 2. 执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移。\n 3. 执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收。\n 4. 执行完 func，ESP 下移，func 对应的空间被回收。\n\n图示如下:\n\n\n\n因此你也看到了，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大！\n\n不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销，下一篇就来分析一下堆内存到底是如何进行垃圾回收并进行优化的。\n\n\n# 第 25 篇：V8 引擎如何进行垃圾内存的回收？\n\nJS 语言不像 C/C++, 让程序员自己去开辟或者释放内存，而是类似 Java，采用自己的一套垃圾回收算法进行自动的内存管理。作为一名资深的前端工程师，对于 JS 内存回收的机制是需要非常清楚, 以便于在极端的环境下能够分析出系统性能的瓶颈，另一方面，学习这其中的机制，也对我们深入理解 JS 的闭包特性、以及对内存的高效使用，都有很大的帮助。\n\n\n# V8 内存限制\n\n在其他的后端语言中，如 Java/Go, 对于内存的使用没有什么限制，但是 JS 不一样，V8 只能使用系统的一部分内存，具体来说，在64位系统下，V8 最多只能分配1.4G, 在 32 位系统中，最多只能分配0.7G。你想想在前端这样的大内存需求其实并不大，但对于后端而言，nodejs 如果遇到一个 2G 多的文件，那么将无法全部将其读入内存进行各种操作了。\n\n我们知道对于栈内存而言，当 ESP 指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析堆内存的垃圾回收。\n\n上一篇我们提到过了，所有的对象类型的数据在 JS 中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。\n\n那么问题来了，V8 为什么要给它设置内存上限？明明我的机器大几十 G 的内存，只能让我用这么一点？\n\n究其根本，是由两个因素所共同决定的，一个是 JS 单线程的执行机制，另一个是 JS 垃圾回收机制的限制。\n\n首先 JS 是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的:\n\n> 以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上。\n\n可见其耗时之久，而且在这么长的时间内，我们的 JS 代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个 G 内存这样的场景的。\n\n不过，如果你想调整这个内存的限制也不是不行。配置命令如下:\n\n// 这是调整老生代这部分的内存，单位是MB。后面会详细介绍新生代和老生代内存\nnode --max-old-space-size=2048 xxx.js\n复制代码\n\n\n或者\n\n// 这是调整新生代这部分的内存，单位是 KB。\nnode --max-new-space-size=2048 xxx.js\n复制代码\n\n\n\n# 新生代内存的回收\n\nV8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存之和。\n\n\n\n根据这两种不同种类的堆内存，V8 采用了不同的回收策略，来根据不同的场景做针对性的优化。\n\n首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32MB 和 16MB。够小吧，不过也很好理解，新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。\n\n那好了，新生代的垃圾回收是怎么做的呢？\n\n首先将新生代内存空间一分为二:\n\n\n\n其中 From 部分表示正在使用的内存，To 是目前闲置的内存。\n\n当进行垃圾回收时，V8 将 From 部分的对象检查一遍，如果是存活对象那么复制到 To 内存中(在 To 内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。\n\n当所有的 From 中的存活对象按照顺序进入到 To 内存之后，From 和 To 两者的角色对调，From 现在被闲置，To 为正在使用，如此循环。\n\n那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？\n\n注意，我刚刚特别说明了，在 To 内存中按照顺序从头放置的，这是为了应对这样的场景:\n\n\n\n深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做内存碎片。刚刚介绍的新生代垃圾回收算法也叫Scavenge 算法。\n\nScavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To 空间变成了这个样子:\n\n\n\n是不是整齐了许多？这样就大大方便了后续连续空间的分配。\n\n不过 Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。\n\n\n# 老生代内存的回收\n\n刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。\n\n发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:\n\n * 已经经历过一次 Scavenge 回收。\n * To（闲置）空间的内存占用超过 25%。\n\n现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用Scavenge算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是劳民伤财？\n\n那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？\n\n第一步，进行标记-清除。这个过程在《JavaScript 高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。\n\n当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？\n\n第二步，整理内存碎片。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。\n\n\n\n由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。\n\n\n# 增量标记\n\n由于 JS 的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就\"歇\"一下，就 js 应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟 React Fiber 的思路有点像，这里就不展开了。\n\n经过增量标记之后，垃圾回收过程对 JS 应用的阻塞时间减少到原来了 1 / 6, 可以看到，这是一个非常成功的改进。\n\nJS 垃圾回收的原理就介绍到这里了，其实理解起来是非常简单的，重要的是理解它为什么要这么做，而不仅仅是如何做的，希望这篇总结能够对你有所启发。\n\n\n# 第 26 篇: 描述一下 V8 执行一段 JS 代码的过程？\n\n前端相对来说是一个比较新兴的领域，因此各种前端框架和工具层出不穷，让人眼花缭乱，尤其是各大厂商推出小程序之后各自制定标准，让前端开发的工作更加繁琐，在此背景下为了抹平平台之间的差异，诞生的各种编译工具/框架也数不胜数。但无论如何，想要赶上这些框架和工具的更新速度是非常难的，即使赶上了也很难产生自己的技术积淀，一个更好的方式便是学习那些本质的知识，抓住上层应用中不变的底层机制，这样我们便能轻松理解上层的框架而不仅仅是被动地使用，甚至能够在适当的场景下自己造出轮子，以满足开发效率的需求。\n\n站在 V8 的角度，理解其中的执行机制，也能够帮助我们理解很多的上层应用，包括 Babel、Eslint、前端框架的底层机制。那么，一段 JavaScript 代码放在 V8 当中究竟是如何执行的呢？\n\n首先需要明白的是，机器是读不懂 JS 代码，机器只能理解特定的机器码，那如果要让 JS 的逻辑在机器上运行起来，就必须将 JS 的代码翻译成机器码，然后让机器识别。JS 属于解释型语言，对于解释型的语言说，解释器会对源代码做如下分析:\n\n * 通过词法分析和语法分析生成 AST(抽象语法树)\n * 生成字节码\n\n然后解释器根据字节码来执行程序。但 JS 整个执行的过程其实会比这个更加复杂，接下来就来一一地拆解。\n\n\n# 1.生成 AST\n\n生成 AST 分为两步——词法分析和语法分析。\n\n词法分析即分词，它的工作就是将一行行的代码分解成一个个 token。 比如下面一行代码:\n\nlet name = 'sanyuan';\n复制代码;\n\n\n其中会把句子分解成四个部分:\n\n\n\n即解析成了四个 token，这就是词法分析的作用。\n\n接下来语法分析阶段，将生成的这些 token 数据，根据一定的语法规则转化为 AST。举个例子:\n\nlet name = 'sanyuan';\nconsole.log(name);\n复制代码;\n\n\n最后生成的 AST 是这样的:\n\n\n\n当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码。顺便补充一句，babel 的工作原理就是将 ES6 的代码解析生成ES6的AST，然后将 ES6 的 AST 转换为 ES5 的AST,最后才将 ES5 的 AST 转化为具体的 ES5 代码。由于本文着重阐述原理，关于 babel 编译的细节就不展开了，推荐大家去读一读荒山的babel 文章, 帮你打开新世界的大门: )\n\n回到 V8 本身，生成 AST 后，接下来会生成执行上下文，关于执行上下文，可以参考上上篇《JavaScript 内存机制之问——数据是如何存储的？》中对于上下文压栈出栈过程的讲解。\n\n\n# 2. 生成字节码\n\n开头就已经提到过了，生成 AST 之后，直接通过 V8 的解释器(也叫 Ignition)来生成字节码。但是字节码并不能让机器直接运行，那你可能就会说了，不能执行还转成字节码干嘛，直接把 AST 转换成机器码不就得了，让机器直接执行。确实，在 V8 的早期是这么做的，但后来因为机器码的体积太大，引发了严重的内存占用问题。\n\n给一张对比图让大家直观地感受以下三者代码量的差异:\n\n\n\n很容易得出，字节码是比机器码轻量得多的代码。那 V8 为什么要使用字节码，字节码到底是个什么东西？\n\n> 字节码是介于 AST 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。\n\n字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。\n\n\n# 3. 执行代码\n\n接下来，就进入到字节码解释执行的阶段啦！\n\n在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做热点代码(HotSpot)，然后将这么代码编译成机器码保存起来，这个用来编译的工具就是 V8 的编译器(也叫做TurboFan) , 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为热点代码，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。\n\n其实当你听到有人说 JS 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 JS 并不是完全的解释型语言。而编译器和解释器的 根本区别在于前者会编译生成二进制文件但后者不会。\n\n并且，这种字节码跟编译器和解释器结合的技术，我们称之为即时编译, 也就是我们经常听到的JIT。\n\n这就是 V8 中执行一段 JS 代码的整个过程，梳理一下:\n\n 1. 首先通过词法分析和语法分析生成 AST\n 2. 将 AST 转换为字节码\n 3. 由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率\n\n关于这个问题的拆解就到这里，希望对你有所启发。\n\n\n# 第 28 篇：如何理解 EventLoop——宏任务和微任务篇\n\n\n# 宏任务(MacroTask)引入\n\n在 JS 中，大部分的任务都是在主线程上执行，常见的任务有:\n\n 1. 渲染事件\n 2. 用户交互事件\n 3. js 脚本执行\n 4. 网络请求、文件读写完成事件等等。\n\n为了让这些事件有条不紊地进行，JS 引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种队列的方式来存储这些任务， 即先进来的先执行。模拟如下:\n\nbool keep_running = true;\nvoid MainTherad(){\n  for(;;){\n    //执行队列中的任务\n    Task task = task_queue.takeTask();\n    ProcessTask(task);\n\n    //执行延迟队列中的任务\n    ProcessDelayTask()\n\n    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环\n        break;\n  }\n}\n复制代码\n\n\n这里用到了一个 for 循环，将队列中的任务一一取出，然后执行，这个很好理解。但是其中包含了两种任务队列，除了上述提到的任务队列， 还有一个延迟队列，它专门处理诸如 setTimeout/setInterval 这样的定时器回调任务。\n\n上述提到的，普通任务队列和延迟队列中的任务，都属于宏任务。\n\n\n# 微任务(MicroTask)引入\n\n对于每个宏任务而言，其内部都有一个微任务队列。那为什么要引入微任务？微任务在什么时候执行呢？\n\n其实引入微任务的初衷是为了解决异步回调的问题。想一想，对于异步回调的处理，有多少种方式？总结起来有两点:\n\n 1. 将异步回调进行宏任务队列的入队操作。\n 2. 将异步回调放到当前宏任务的末尾。\n\n如果采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。\n\n为了规避这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。\n\n常见的微任务有 MutationObserver、Promise.then(或.reject) 以及以 Promise 为基础开发的其他技术(比如 fetch API), 还包括 V8 的垃圾回收过程。\n\nOk, 这便是宏任务和微任务的概念，接下来正式介绍 JS 非常重要的运行机制——EventLoop。\n\n\n# 第 29 篇: 如何理解 EventLoop——浏览器篇\n\n干讲理论不容易理解，让我们直接以一个例子开始吧:\n\nconsole.log('start');\nsetTimeout(() => {\n  console.log('timeout');\n});\nPromise.resolve().then(() => {\n  console.log('resolve');\n});\nconsole.log('end');\n复制代码;\n\n\n我们来分析一下:\n\n 1. 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈(关于执行栈，若不了解请移步之前的文章《JavaScript 内存机制之问——数据是如何存储的？》)进行执行，因此先打印 start 和 end\n 2. setTimeout 作为一个宏任务放入宏任务队列\n 3. Promise.then 作为一个为微任务放入到微任务队列\n 4. 当本次宏任务执行完，检查微任务队列，发现一个 Promise.then, 执行\n 5. 接下来进入到下一个宏任务——setTimeout, 执行\n\n因此最后的顺序是:\n\nstart\nend\nresolve\ntimeout\n复制代码\n\n\n这样就带大家直观地感受到了浏览器环境下 EventLoop 的执行流程。不过，这只是其中的一部分情况，接下来我们来做一个更完整的总结。\n\n 1. 一开始整段脚本作为第一个宏任务执行\n 2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列\n 3. 当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空\n 4. 执行浏览器 UI 线程的渲染工作\n 5. 检查是否有 Web worker 任务，有则执行\n 6. 执行队首新的宏任务，回到 2，依此循环，直到宏任务和微任务队列都为空\n\n最后给大家留一道题目练习:\n\nPromise.resolve().then(() => {\n  console.log('Promise1');\n  setTimeout(() => {\n    console.log('setTimeout2');\n  }, 0);\n});\nsetTimeout(() => {\n  console.log('setTimeout1');\n  Promise.resolve().then(() => {\n    console.log('Promise2');\n  });\n}, 0);\nconsole.log('start');\n\n// start\n// Promise1\n// setTimeout1\n// Promise2\n// setTimeout2\n复制代码;\n\n\n\n# 第 30 篇: 如何理解 EventLoop——nodejs 篇\n\nnodejs 和 浏览器的 eventLoop 还是有很大差别的，值得单独拿出来说一说。\n\n不知你是否看过关于 nodejs 中 eventLoop 的一些文章, 是否被这些流程图搞得眼花缭乱、一头雾水:\n\n\n\n看到这你不用紧张，这里会抛开这些晦涩的流程图，以最清晰浅显的方式来一步步拆解 nodejs 的事件循环机制。\n\n\n# 1. 三大关键阶段\n\n首先，梳理一下 nodejs 三个非常重要的执行阶段:\n\n 1. 执行 定时器回调 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是 setTimeout、setInterval。这个阶段暂且叫它timer。\n 2. 轮询(英文叫poll)阶段。因为在 node 代码中难免会有异步操作，比如文件 I/O，网络 I/O 等等，那么当这些异步操作做完了，就会来通知 JS 主线程，怎么通知呢？就是通过'data'、\n\n'connect'等事件使得事件循环到达 poll 阶段。到达了这个阶段后:\n\n如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timer 阶段。\n\n如果没有定时器, 会去看回调函数队列。\n\n * 如果队列不为空，拿出队列中的方法依次执行\n\n * 如果队列\n   \n   为空\n   \n   \n   ，检查是否有\n   \n   setImmdiate\n   \n   \n   的回调\n   \n   * 有则前往check阶段(下面会说)\n   * 没有则继续等待，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段。\n\n 1. check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。\n\n这三个阶段为一个循环过程。不过现在的 eventLoop 并不完整，我们现在就来一一地完善。\n\n\n# 2. 完善\n\n首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 I/O异常的回调阶段。比如说 TCP 连接遇到 ECONNREFUSED，就会在这个时候执行回调。\n\n并且在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()， 'close' 事件的回调就会在这个阶段执行。\n\n梳理一下，nodejs 的 eventLoop 分为下面的几个阶段:\n\n 1. timer 阶段\n 2. I/O 异常回调阶段\n 3. 空闲、预备状态(第 2 阶段结束，poll 未触发之前)\n 4. poll 阶段\n 5. check 阶段\n 6. 关闭事件的回调阶段\n\n是不是清晰了许多？\n\n\n# 3. 实例演示\n\n好，我们以上次的练习题来实践一把:\n\nsetTimeout(() => {\n  console.log('timer1');\n  Promise.resolve().then(function() {\n    console.log('promise1');\n  });\n}, 0);\nsetTimeout(() => {\n  console.log('timer2');\n  Promise.resolve().then(function() {\n    console.log('promise2');\n  });\n}, 0);\n复制代码;\n\n\n这里我要说，node 版本 >= 11 和在 11 以下的会有不同的表现。\n\n首先说 node 版本 >= 11 的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。\n\ntimer1\npromise1\ntime2\npromise2\n复制代码\n\n\n而 node 版本小于 11 的情况下，对于定时器的处理是:\n\n> 若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务。\n\n因此会打印出这样的结果:\n\ntimer1\ntimer2\npromise1\npromise2\n复制代码\n\n\n\n# 4.nodejs 和 浏览器关于 eventLoop 的主要区别\n\n两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段之间执行的。\n\n\n# 5.关于 process.nextTick 的一点说明\n\nprocess.nextTick 是一个独立于 eventLoop 的任务队列。\n\n在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。\n\n\n# 第 31 篇: nodejs 中的异步、非阻塞 I/O 是如何实现的？\n\n在听到 nodejs 相关的特性时，经常会对 异步I/O、非阻塞I/O有所耳闻，听起来好像是差不多的意思，但其实是两码事，下面我们就以原理的角度来剖析一下对 nodejs 来说，这两种技术底层是如何实现的？\n\n\n# 什么是 I/O？\n\n首先，我想有必要把 I/O 的概念解释一下。I/O 即 Input/Output, 输入和输出的意思。在浏览器端，只有一种 I/O，那就是利用 Ajax 发送网络请求，然后读取返回的内容，这属于网络I/O。回到 nodejs 中，其实这种的 I/O 的场景就更加广泛了，主要分为两种:\n\n * 文件 I/O。比如用 fs 模块对文件进行读写操作。\n * 网络 I/O。比如 http 模块发起网络请求。\n\n\n# 阻塞和非阻塞 I/O\n\n阻塞和非阻塞 I/O 其实是针对操作系统内核而言的，而不是 nodejs 本身。阻塞 I/O 的特点就是一定要等到操作系统完成所有操作后才表示调用结束，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。\n\n对前者而言，在操作系统进行 I/O 的操作的过程中，我们的应用程序其实是一直处于等待状态的，什么都做不了。那如果换成非阻塞I/O，调用返回后我们的 nodejs 应用程序可以完成其他的事情，而操作系统同时也在进行 I/O。这样就把等待的时间充分利用了起来，提高了执行效率，但是同时又会产生一个问题，nodejs 应用程序怎么知道操作系统已经完成了 I/O 操作呢？\n\n为了让 nodejs 知道操作系统已经做完 I/O 操作，需要重复地去操作系统那里判断一下是否完成，这种重复判断的方式就是轮询。对于轮询而言，有以下这么几种方案:\n\n 1. 一直轮询检查 I/O 状态，直到 I/O 完成。这是最原始的方式，也是性能最低的，会让 CPU 一直耗用在等待上面。其实跟阻塞 I/O 的效果是一样的。\n 2. 遍历文件描述符(即 文件 I/O 时操作系统和 nodejs 之间的文件凭证)的方式来确定 I/O 是否完成，I/O 完成则文件描述符的状态改变。但 CPU 轮询消耗还是很大。\n 3. epoll 模式。即在进入轮询的时候如果 I/O 未完成 CPU 就休眠，完成之后唤醒 CPU。\n\n总之，CPU 要么重复检查 I/O，要么重复检查文件描述符，要么休眠，都得不到很好的利用，我们希望的是:\n\n> nodejs 应用程序发起 I/O 调用后可以直接去执行别的逻辑，操作系统默默地做完 I/O 之后给 nodejs 发一个完成信号，nodejs 执行回调操作。\n\n这是理想的情况，也是异步 I/O 的效果，那如何实现这样的效果呢？\n\n\n# 异步 I/O 的本质\n\nLinux 原生存在这样的一种方式，即(AIO), 但两个致命的缺陷:\n\n 1. 只有 Linux 下存在，在其他系统中没有异步 I/O 支持。\n 2. 无法利用系统缓存。\n\n# nodejs 中的异步 I/O 方案\n\n是不是没有办法了呢？在单线程的情况下确实是这样，但是如果把思路放开一点，利用多线程来考虑这个问题，就变得轻松多了。我们可以让一个进程进行计算操作，另外一些进行 I/O 调用，I/O 完成后把信号传给计算的线程，进而执行回调，这不就好了吗？没错，异步 I/O 就是使用这样的线程池来实现的。\n\n只不过在不同的系统下面表现会有所差异，在 Linux 下可以直接使用线程池来完成，在 Window 系统下则采用 IOCP 这个系统 API(其内部还是用线程池完成的)。\n\n有了操作系统的支持，那 nodejs 如何来对接这些操作系统从而实现异步 I/O 呢？\n\n以文件为 I/O 我们以一段代码为例:\n\nlet fs = require('fs');\n\nfs.readFile('/test.txt', function(err, data) {\n  console.log(data);\n});\n复制代码;\n\n\n# 执行流程\n\n执行代码的过程中大概发生了这些事情:\n\n 1. 首先，fs.readFile 调用 Node 的核心模块 fs.js ；\n 2. 接下来，Node 的核心模块调用内建模块 node_file.cc，创建对应的文件 I/O 观察者对象(这个对象后面有大用！) ；\n 3. 最后，根据不同平台（Linux 或者 window），内建模块通过 libuv 中间层进行系统调用\n\n\n\n# libuv 调用过程拆解\n\n重点来了！libuv 中是如何来进行进行系统调用的呢？也就是 uv_fs_open() 中做了些什么？\n\n# 1. 创建请求对象\n\n以 Windows 系统为例来说，在这个函数的调用过程中，我们创建了一个文件 I/O 的请求对象，并往里面注入了回调函数。\n\nreq_wrap->object_->Set(oncomplete_sym, callback);\n复制代码\n\n\nreqwrap 便是这个请求对象，req_wrap 中 object 的 oncomplete_sym 属性对应的值便是我们 nodejs 应用程序代码中传入的回调函数。\n\n# 2. 推入线程池，调用返回\n\n在这个对象包装完成后，QueueUserWorkItem() 方法将这个对象推进线程池中等待执行。\n\n好，至此现在 js 的调用就直接返回了，我们的 js 应用程序代码可以继续往下执行，当然，当前的 I/O 操作同时也在线程池中将被执行，这不就完成了异步么：）\n\n等等，别高兴太早，回调都还没执行呢！接下来便是执行回调通知的环节。\n\n# 3. 回调通知\n\n事实上现在线程池中的 I/O 无论是阻塞还是非阻塞都已经无所谓了，因为异步的目的已经达成。重要的是 I/O 完成后会发生什么。\n\n在介绍后续的故事之前，给大家介绍两个重要的方法: GetQueuedCompletionStatus 和 PostQueuedCompletionStatus。\n\n 1. 还记得之前讲过的 eventLoop 吗？在每一个 Tick 当中会调用GetQueuedCompletionStatus检查线程池中是否有执行完的请求，如果有则表示时机已经成熟，可以执行回调了。\n 2. PostQueuedCompletionStatus方法则是向 IOCP 提交状态，告诉它当前 I/O 完成了。\n\n名字比较长，先介绍是为了让大家混个脸熟，至少后面出来不会感到太突兀：）\n\n我们言归正传，把后面的过程串联起来。\n\n当对应线程中的 I/O 完成后，会将获得的结果存储起来，保存到相应的请求对象中，然后调用PostQueuedCompletionStatus()向 IOCP 提交执行完成的状态，并且将线程还给操作系统。一旦 EventLoop 的轮询操作中，调用GetQueuedCompletionStatus检测到了完成的状态，就会把请求对象塞给 I/O 观察者(之前埋下伏笔，如今终于闪亮登场)。\n\nI/O 观察者现在的行为就是取出请求对象的存储结果，同时也取出它的oncomplete_sym属性，即回调函数(不懂这个属性的回看第 1 步的操作)。将前者作为函数参数传入后者，并执行后者。 这里，回调函数就成功执行啦！\n\n总结 :\n\n 1. 阻塞和非阻塞 I/O 其实是针对操作系统内核而言的。阻塞 I/O 的特点就是一定要等到操作系统完成所有操作后才表示调用结束，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。\n 2. nodejs 中的异步 I/O 采用多线程的方式，由 EventLoop、I/O 观察者，请求对象、线程池四大要素相互配合，共同实现。\n\n\n# 第 32 篇：JS 异步编程有哪些方案？为什么会出现这些方案？\n\n关于 JS 单线程、EventLoop 以及异步 I/O 这些底层的特性，我们之前做过了详细的拆解，不在赘述。在探究了底层机制之后，我们还需要对代码的组织方式有所理解，这是离我们最日常开发最接近的部分，异步代码的组织方式直接决定了开发和维护的效率，其重要性也不可小觑。尽管底层机制没变，但异步代码的组织方式却随着 ES 标准的发展，一步步发生了巨大的变革。接着让我们来一探究竟吧！\n\n\n# 回调函数时代\n\n相信很多 nodejs 的初学者都或多或少踩过这样的坑，node 中很多原生的 api 就是诸如这样的:\n\nfs.readFile('xxx', (err, data) => {});\n复制代码;\n\n\n典型的高阶函数，将回调函数作为函数参数传给了 readFile。但久而久之，就会发现，这种传入回调的方式也存在大坑, 比如下面这样:\n\nfs.readFile('1.json', (err, data) => {\n  fs.readFile('2.json', (err, data) => {\n    fs.readFile('3.json', (err, data) => {\n      fs.readFile('4.json', (err, data) => {});\n    });\n  });\n});\n复制代码;\n\n\n回调当中嵌套回调，也称回调地狱。这种代码的可读性和可维护性都是非常差的，因为嵌套的层级太多。而且还有一个严重的问题，就是每次任务可能会失败，需要在回调里面对每个任务的失败情况进行处理，增加了代码的混乱程度。\n\n\n# Promise 时代\n\nES6 中新增的 Promise 就很好了解决了回调地狱的问题，同时了合并了错误处理。写出来的代码类似于下面这样:\n\nreadFilePromise('1.json')\n  .then((data) => {\n    return readFilePromise('2.json');\n  })\n  .then((data) => {\n    return readFilePromise('3.json');\n  })\n  .then((data) => {\n    return readFilePromise('4.json');\n  });\n复制代码;\n\n\n以链式调用的方式避免了大量的嵌套，也符合人的线性思维方式，大大方便了异步编程。\n\n\n# co + Generator 方式\n\n利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。\n\nco(function*() {\n  const r1 = yield readFilePromise('1.json');\n  const r2 = yield readFilePromise('2.json');\n  const r3 = yield readFilePromise('3.json');\n  const r4 = yield readFilePromise('4.json');\n});\n复制代码;\n\n\n\n# async + await 方式\n\n这是 ES7 中新增的关键字，凡是加上 async 的函数都默认返回一个 Promise 对象，而更重要的是 async + await 也能让异步代码以同步的方式来书写，而不需要借助第三方库的支持。\n\nconst readFileAsync = async function() {\n  const f1 = await readFilePromise('1.json');\n  const f2 = await readFilePromise('2.json');\n  const f3 = await readFilePromise('3.json');\n  const f4 = await readFilePromise('4.json');\n};\n复制代码;\n\n\n这四种经典的异步编程方式就简单回顾完了，由于是鸟瞰大局，我觉得知道是什么比了解细节要重要, 因此也没有展开。不过没关系，接下来，让我们针对这些具体的解决方案，一步步深入异步编程，理解其中的本质。\n\n\n# 第 33 篇: 能不能简单实现一下 node 中回调函数的机制？\n\n回调函数的方式其实内部利用了发布-订阅模式，在这里我们以模拟实现 node 中的 Event 模块为例来写实现回调函数的机制。\n\nfunction EventEmitter() {\n  this.events = new Map();\n}\n复制代码;\n\n\n这个 EventEmitter 一共需要实现这些方法: addListener, removeListener, once, removeAllListener, emit。\n\n首先是 addListener：\n\n// once 参数表示是否只是触发一次\nconst wrapCallback = (fn, once = false) => ({\n  callback: fn,\n  once,\n});\n\nEventEmitter.prototype.addListener = function(\n  type,\n  fn,\n  once = false,\n) {\n  let handler = this.events.get(type);\n  if (!handler) {\n    // 为 type 事件绑定回调\n    this.events.set(type, wrapCallback(fn, once));\n  } else if (\n    handler &&\n    typeof handler.callback === 'function'\n  ) {\n    // 目前 type 事件只有一个回调\n    this.events.set(type, [\n      handler,\n      wrapCallback(fn, once),\n    ]);\n  } else {\n    // 目前 type 事件回调数 >= 2\n    handler.push(wrapCallback(fn, once));\n  }\n};\n复制代码;\n\n\nremoveLisener 的实现如下:\n\nEventEmitter.prototype.removeListener = function(\n  type,\n  listener,\n) {\n  let handler = this.events.get(type);\n  if (!handler) return;\n  if (!Array.isArray(handler)) {\n    if (handler.callback === listener.callback)\n      this.events.delete(type);\n    else return;\n  }\n  for (let i = 0; i < handler.length; i++) {\n    let item = handler[i];\n    if (item.callback === listener.callback) {\n      // 删除该回调，注意数组塌陷的问题，即后面的元素会往前挪一位。i 要 --\n      handler.splice(i, 1);\n      i--;\n      if (handler.length === 1) {\n        // 长度为 1 就不用数组存了\n        this.events.set(type, handler[0]);\n      }\n    }\n  }\n};\n复制代码;\n\n\nonce 实现思路很简单，先调用 addListener 添加上了 once 标记的回调对象, 然后在 emit 的时候遍历回调列表，将标记了 once: true 的项 remove 掉即可。\n\nEventEmitter.prototype.once = function(type, fn) {\n  this.addListener(type, fn, true);\n};\n\nEventEmitter.prototype.emit = function(type, ...args) {\n  let handler = this.events.get(type);\n  if (!handler) return;\n  if (Array.isArray(handler)) {\n    // 遍历列表，执行回调\n    handler.map((item) => {\n      item.callback.apply(this, args);\n      // 标记的 once: true 的项直接移除\n      if (item.once) this.removeListener(type, item);\n    });\n  } else {\n    // 只有一个回调则直接执行\n    handler.callback.apply(this, args);\n  }\n  return true;\n};\n\n复制代码;\n\n\n最后是 removeAllListener：\n\nEventEmitter.prototype.removeAllListener = function(type) {\n  let handler = this.events.get(type);\n  if (!handler) return;\n  else this.events.delete(type);\n};\n复制代码;\n\n\n现在我们测试一下:\n\nlet e = new EventEmitter();\ne.addListener('type', () => {\n  console.log('type事件触发！');\n});\ne.addListener('type', () => {\n  console.log('WOW!type事件又触发了！');\n});\n\nfunction f() {\n  console.log('type事件我只触发一次');\n}\ne.once('type', f);\ne.emit('type');\ne.emit('type');\ne.removeAllListener('type');\ne.emit('type');\n\n// type事件触发！\n// WOW!type事件又触发了！\n// type事件我只触发一次\n// type事件触发！\n// WOW!type事件又触发了！\n复制代码;\n\n\nOK，一个简易的 Event 就这样实现完成了，为什么说它简易呢？因为还有很多细节的部分没有考虑:\n\n 1. 在参数少的情况下，call 的性能优于 apply，反之 apply 的性能更好。因此在执行回调时候可以根据情况调用 call 或者 apply。\n 2. 考虑到内存容量，应该设置回调列表的最大值，当超过最大值的时候，应该选择部分回调进行删除操作。\n 3. 鲁棒性有待提高。对于参数的校验很多地方直接忽略掉了。\n\n不过，这个案例的目的只是带大家掌握核心的原理，如果在这里洋洋洒洒写三四百行意义也不大，有兴趣的可以去看看 Node 中 Event 模块 的源码，里面对各种细节和边界情况做了详细的处理。\n\n\n# 第 34 篇: Promise 之问(一)——Promise 凭借什么消灭了回调地狱？\n\n\n# 问题\n\n首先，什么是回调地狱:\n\n 1. 多层嵌套的问题。\n 2. 每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。\n\n这两种问题在回调函数时代尤为突出。Promise 的诞生就是为了解决这两个问题。\n\n\n# 解决方法\n\nPromise 利用了三大技术手段来解决回调地狱:\n\n * 回调函数延迟绑定。\n * 返回值穿透。\n * 错误冒泡。\n\n首先来举个例子:\n\nlet readFilePromise = (filename) => {\n  fs.readFile(filename, (err, data) => {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(data);\n    }\n  });\n};\nreadFilePromise('1.json').then((data) => {\n  return readFilePromise('2.json');\n});\n复制代码;\n\n\n看到没有，回调函数不是直接声明的，而是在通过后面的 then 方法传入的，即延迟传入。这就是回调函数延迟绑定。\n\n然后我们做以下微调:\n\nlet x = readFilePromise('1.json').then((data) => {\n  return readFilePromise('2.json'); //这是返回的Promise\n});\nx.then(/* 内部逻辑省略 */);\n复制代码;\n\n\n我们会根据 then 中回调函数的传入值创建不同类型的 Promise, 然后把返回的 Promise 穿透到外层, 以供后续的调用。这里的 x 指的就是内部返回的 Promise，然后在 x 后面可以依次完成链式调用。\n\n这便是返回值穿透的效果。\n\n这两种技术一起作用便可以将深层的嵌套回调写成下面的形式:\n\nreadFilePromise('1.json')\n  .then((data) => {\n    return readFilePromise('2.json');\n  })\n  .then((data) => {\n    return readFilePromise('3.json');\n  })\n  .then((data) => {\n    return readFilePromise('4.json');\n  });\n复制代码;\n\n\n这样就显得清爽了许多，更重要的是，它更符合人的线性思维模式，开发体验也更好。\n\n两种技术结合产生了链式调用的效果。\n\n这解决的是多层嵌套的问题，那另一个问题，即每次任务执行结束后分别处理成功和失败的情况怎么解决的呢？\n\nPromise 采用了错误冒泡的方式。其实很简单理解，我们来看看效果:\n\nreadFilePromise('1.json')\n  .then((data) => {\n    return readFilePromise('2.json');\n  })\n  .then((data) => {\n    return readFilePromise('3.json');\n  })\n  .then((data) => {\n    return readFilePromise('4.json');\n  })\n  .catch((err) => {\n    // xxx\n  });\n复制代码;\n\n\n这样前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了。\n\n\n# 解决效果\n\n * 1. 实现链式调用，解决多层嵌套问题\n * 1. 实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题\n\n\n# 第 35 篇: Promise 之问(二)——为什么 Promise 要引入微任务？\n\n在这里，如果你还没有接触过 Promise, 务必去看看 MDN 文档，了解使用方式，不然后面很会懵。\n\nPromise 中的执行函数是同步进行的，但是里面存在着异步操作，在异步操作结束后会调用 resolve 方法，或者中途遇到错误调用 reject 方法，这两者都是作为微任务进入到 EventLoop 中。但是你有没有想过，Promise 为什么要引入微任务的方式来进行回调操作？\n\n\n# 解决方式\n\n回到问题本身，其实就是如何处理回调的问题。总结起来有三种方式:\n\n 1. 使用同步回调，直到异步任务进行完，再进行后面的任务。\n 2. 使用异步回调，将回调函数放在进行宏任务队列的队尾。\n 3. 使用异步回调，将回调函数放到当前宏任务中的最后面。\n\n\n# 优劣对比\n\n第一种方式显然不可取，因为同步的问题非常明显，会让整个脚本阻塞住，当前任务等待，后面的任务都无法得到执行，而这部分等待的时间是可以拿来完成其他事情的，导致 CPU 的利用率非常低，而且还有另外一个致命的问题，就是无法实现延迟绑定的效果。\n\n如果采用第二种方式，那么执行回调(resolve/reject)的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。\n\n为了解决上述方案的问题，另外也考虑到延迟绑定的需求，Promise 采取第三种方式, 即引入微任务, 即把 resolve(reject) 回调的执行放在当前宏任务的末尾。\n\n这样，利用微任务解决了两大痛点:\n\n * 1. 采用异步回调替代同步回调解决了浪费 CPU 性能的问题。\n * 1. 放到当前宏任务最后执行，解决了回调执行的实时性问题。\n\n好，Promise 的基本实现思想已经讲清楚了，相信大家已经知道了它为什么这么设计，接下来就让我们一步步弄清楚它内部到底是怎么设计的。\n\n\n# 第 36 篇: Promise 之问(三)——Promise 如何实现链式调用？\n\n从现在开始，我们就来动手实现一个功能完整的 Promise，一步步深挖其中的细节。我们先从链式调用开始。\n\n\n# 简易版实现\n\n首先写出第一版的代码:\n\n//定义三种状态\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\n\nfunction MyPromise(executor) {\n  let self = this; // 缓存当前promise实例\n  self.value = null;\n  self.error = null;\n  self.status = PENDING;\n  self.onFulfilled = null; //成功的回调函数\n  self.onRejected = null; //失败的回调函数\n\n  const resolve = (value) => {\n    if (self.status !== PENDING) return;\n    setTimeout(() => {\n      self.status = FULFILLED;\n      self.value = value;\n      self.onFulfilled(self.value); //resolve时执行成功回调\n    });\n  };\n\n  const reject = (error) => {\n    if (self.status !== PENDING) return;\n    setTimeout(() => {\n      self.status = REJECTED;\n      self.error = error;\n      self.onRejected(self.error); //resolve时执行成功回调\n    });\n  };\n  executor(resolve, reject);\n}\nMyPromise.prototype.then = function(\n  onFulfilled,\n  onRejected,\n) {\n  if (this.status === PENDING) {\n    this.onFulfilled = onFulfilled;\n    this.onRejected = onRejected;\n  } else if (this.status === FULFILLED) {\n    //如果状态是fulfilled，直接执行成功回调，并将成功值传入\n    onFulfilled(this.value);\n  } else {\n    //如果状态是rejected，直接执行失败回调，并将失败原因传入\n    onRejected(this.error);\n  }\n  return this;\n};\n复制代码;\n\n\n可以看到，Promise 的本质是一个有限状态机，存在三种状态:\n\n * PENDING(等待)\n * FULFILLED(成功)\n * REJECTED(失败)\n\n状态改变规则如下图:\n\n\n\n对于 Promise 而言，状态的改变不可逆，即由等待态变为其他的状态后，就无法再改变了。\n\n不过，回到目前这一版的 Promise, 还是存在一些问题的。\n\n\n# 设置回调数组\n\n首先只能执行一个回调函数，对于多个回调的绑定就无能为力，比如下面这样:\n\nlet promise1 = new MyPromise((resolve, reject) => {\n  fs.readFile('./001.txt', (err, data) => {\n    if (!err) {\n      resolve(data);\n    } else {\n      reject(err);\n    }\n  });\n});\n\nlet x1 = promise1.then((data) => {\n  console.log('第一次展示', data.toString());\n});\n\nlet x2 = promise1.then((data) => {\n  console.log('第二次展示', data.toString());\n});\n\nlet x3 = promise1.then((data) => {\n  console.log('第三次展示', data.toString());\n});\n复制代码;\n\n\n这里我绑定了三个回调，想要在 resolve() 之后一起执行，那怎么办呢？\n\n需要将 onFulfilled 和 onRejected 改为数组，调用 resolve 时将其中的方法拿出来一一执行即可。\n\nself.onFulfilledCallbacks = [];\nself.onRejectedCallbacks = [];\n复制代码;\nMyPromise.prototype.then = function(\n  onFulfilled,\n  onRejected,\n) {\n  if (this.status === PENDING) {\n    this.onFulfilledCallbacks.push(onFulfilled);\n    this.onRejectedCallbacks.push(onRejected);\n  } else if (this.status === FULFILLED) {\n    onFulfilled(this.value);\n  } else {\n    onRejected(this.error);\n  }\n  return this;\n};\n复制代码;\n\n\n接下来将 resolve 和 reject 方法中执行回调的部分进行修改：\n\n// resolve 中\nself.onFulfilledCallbacks.forEach((callback) =>\n  callback(self.value),\n);\n//reject 中\nself.onRejectedCallbacks.forEach((callback) =>\n  callback(self.error),\n);\n复制代码;\n\n\n\n# 链式调用完成\n\n我们采用目前的代码来进行测试:\n\nlet fs = require('fs');\nlet readFilePromise = (filename) => {\n  return new MyPromise((resolve, reject) => {\n    fs.readFile(filename, (err, data) => {\n      if (!err) {\n        resolve(data);\n      } else {\n        reject(err);\n      }\n    });\n  });\n};\nreadFilePromise('./001.txt')\n  .then((data) => {\n    console.log(data.toString());\n    return readFilePromise('./002.txt');\n  })\n  .then((data) => {\n    console.log(data.toString());\n  });\n// 001.txt的内容\n// 001.txt的内容\n复制代码;\n\n\n咦？怎么打印了两个 001，第二次不是读的 002 文件吗？\n\n问题出在这里:\n\nMyPromise.prototype.then = function(\n  onFulfilled,\n  onRejected,\n) {\n  //...\n  return this;\n};\n复制代码;\n\n\n这么写每次返回的都是第一个 Promise。then 函数当中返回的第二个 Promise 直接被无视了！\n\n说明 then 当中的实现还需要改进, 我们现在需要对 then 中返回值重视起来。\n\nMyPromise.prototype.then = function(\n  onFulfilled,\n  onRejected,\n) {\n  let bridgePromise;\n  let self = this;\n  if (self.status === PENDING) {\n    return (bridgePromise = new MyPromise(\n      (resolve, reject) => {\n        self.onFulfilledCallbacks.push((value) => {\n          try {\n            // 看到了吗？要拿到 then 中回调返回的结果。\n            let x = onFulfilled(value);\n            resolve(x);\n          } catch (e) {\n            reject(e);\n          }\n        });\n        self.onRejectedCallbacks.push((error) => {\n          try {\n            let x = onRejected(error);\n            resolve(x);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      },\n    ));\n  }\n  //...\n};\n复制代码;\n\n\n假若当前状态为 PENDING，将回调数组中添加如上的函数，当 Promise 状态变化后，会遍历相应回调数组并执行回调。\n\n但是这段程度还是存在一些问题:\n\n 1. 首先 then 中的两个参数不传的情况并没有处理，\n 2. 假如 then 中的回调执行后返回的结果(也就是上面的x)是一个 Promise, 直接给 resolve 了，这是我们不希望看到的。\n\n怎么来解决这两个问题呢？\n\n先对参数不传的情况做判断:\n\n// 成功回调不传给它一个默认函数\nonFulfilled =\n  typeof onFulfilled === 'function'\n    ? onFulfilled\n    : (value) => value;\n// 对于失败回调直接抛错\nonRejected =\n  typeof onRejected === 'function'\n    ? onRejected\n    : (error) => {\n        throw error;\n      };\n复制代码;\n\n\n然后对返回Promise的情况进行处理:\n\nfunction resolvePromise(bridgePromise, x, resolve, reject) {\n  //如果x是一个promise\n  if (x instanceof MyPromise) {\n    // 拆解这个 promise ，直到返回值不为 promise 为止\n    if (x.status === PENDING) {\n      x.then(\n        (y) => {\n          resolvePromise(bridgePromise, y, resolve, reject);\n        },\n        (error) => {\n          reject(error);\n        },\n      );\n    } else {\n      x.then(resolve, reject);\n    }\n  } else {\n    // 非 Promise 的话直接 resolve 即可\n    resolve(x);\n  }\n}\n复制代码;\n\n\n然后在 then 的方法实现中作如下修改:\n\nresolve(x)  ->  resolvePromise(bridgePromise, x, resolve, reject);\n复制代码\n\n\n在这里大家好好体会一下拆解 Promise 的过程，其实不难理解，我要强调的是其中的递归调用始终传入的resolve和reject这两个参数是什么含义，其实他们控制的是最开始传入的bridgePromise的状态，这一点非常重要。\n\n紧接着，我们实现一下当 Promise 状态不为 PENDING 时的逻辑。\n\n成功状态下调用 then：\n\nif (self.status === FULFILLED) {\n  return (bridgePromise = new MyPromise(\n    (resolve, reject) => {\n      try {\n        // 状态变为成功，会有相应的 self.value\n        let x = onFulfilled(self.value);\n        // 暂时可以理解为 resolve(x)，后面具体实现中有拆解的过程\n        resolvePromise(bridgePromise, x, resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n    },\n  ));\n}\n复制代码;\n\n\n失败状态下调用 then：\n\nif (self.status === REJECTED) {\n  return (bridgePromise = new MyPromise(\n    (resolve, reject) => {\n      try {\n        // 状态变为失败，会有相应的 self.error\n        let x = onRejected(self.error);\n        resolvePromise(bridgePromise, x, resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n    },\n  ));\n}\n复制代码;\n\n\nPromise A+中规定成功和失败的回调都是微任务，由于浏览器中 JS 触碰不到底层微任务的分配，可以直接拿 setTimeout(属于宏任务的范畴) 来模拟，用 setTimeout将需要执行的任务包裹 ，当然，上面的 resolve 实现也是同理, 大家注意一下即可，其实并不是真正的微任务。\n\nif (self.status === FULFILLED) {\n  return bridgePromise = new MyPromise((resolve, reject) => {\n    setTimeout(() => {\n      //...\n    })\n}\n复制代码\nif (self.status === REJECTED) {\n  return bridgePromise = new MyPromise((resolve, reject) => {\n    setTimeout(() => {\n      //...\n    })\n}\n复制代码\n\n\n好了，到这里, 我们基本实现了 then 方法，现在我们拿刚刚的测试代码做一下测试, 依次打印如下:\n\n(001).txt的内容;\n(002).txt的内容;\n复制代码;\n\n\n可以看到，已经可以顺利地完成链式调用。\n\n\n# 错误捕获及冒泡机制分析\n\n现在来实现 catch 方法:\n\nPromise.prototype.catch = function(onRejected) {\n  return this.then(null, onRejected);\n};\n复制代码;\n\n\n对，就是这么几行，catch 原本就是 then 方法的语法糖。\n\n相比于实现来讲，更重要的是理解其中错误冒泡的机制，即中途一旦发生错误，可以在最后用 catch 捕获错误。\n\n我们回顾一下 Promise 的运作流程也不难理解，贴上一行关键的代码:\n\n// then 的实现中\nonRejected =\n  typeof onRejected === 'function'\n    ? onRejected\n    : (error) => {\n        throw error;\n      };\n复制代码;\n\n\n一旦其中有一个PENDING状态的 Promise 出现错误后状态必然会变为失败, 然后执行 onRejected函数，而这个 onRejected 执行又会抛错，把新的 Promise 状态变为失败，新的 Promise 状态变为失败后又会执行onRejected......就这样一直抛下去，直到用catch 捕获到这个错误，才停止往下抛。\n\n这就是 Promise 的错误冒泡机制。\n\n至此，Promise 三大法宝: 回调函数延迟绑定、回调返回值穿透和错误冒泡。\n\n\n# 第 37 篇: Promise 之问(四)——实现 Promise 的 resolve、reject 和 finally\n\n\n# 实现 Promise.resolve\n\n实现 resolve 静态方法有三个要点:\n\n * 1. 传参为一个 Promise, 则直接返回它。\n * 1. 传参为一个 thenable 对象，返回的 Promise 会跟随这个对象，采用它的最终状态作为自己的状态。\n * 1. 其他情况，直接返回以该值为成功状态的 promise 对象。\n\n具体实现如下:\n\nPromise.resolve = (param) => {\n  if (param instanceof Promise) return param;\n  return new Promise((resolve, reject) => {\n    if (\n      param &&\n      param.then &&\n      typeof param.then === 'function'\n    ) {\n      // param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然\n      param.then(resolve, reject);\n    } else {\n      resolve(param);\n    }\n  });\n};\n复制代码;\n\n\n\n# 实现 Promise.reject\n\nPromise.reject 中传入的参数会作为一个 reason 原封不动地往下传, 实现如下:\n\nPromise.reject = function(reason) {\n  return new Promise((resolve, reject) => {\n    reject(reason);\n  });\n};\n复制代码;\n\n\n\n# 实现 Promise.prototype.finally\n\n无论当前 Promise 是成功还是失败，调用finally之后都会执行 finally 中传入的函数，并且将值原封不动的往下传。\n\nPromise.prototype.finally = function(callback) {\n  this.then(\n    (value) => {\n      return Promise.resolve(callback()).then(() => {\n        return value;\n      });\n    },\n    (error) => {\n      return Promise.resolve(callback()).then(() => {\n        throw error;\n      });\n    },\n  );\n};\n复制代码;\n\n\n\n# 第 38 篇: Promise 之问(五)——实现 Promise 的 all 和 race\n\n\n# 实现 Promise.all\n\n对于 all 方法而言，需要完成下面的核心功能:\n\n 1. 传入参数为一个空的可迭代对象，则直接进行resolve。\n 2. 如果参数中有一个promise 失败，那么 Promise.all 返回的 promise 对象失败。\n 3. 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组\n\n具体实现如下:\n\nPromise.all = function(promises) {\n  return new Promise((resolve, reject) => {\n    let result = [];\n    let index = 0;\n    let len = promises.length;\n    if (len === 0) {\n      resolve(result);\n      return;\n    }\n\n    for (let i = 0; i < len; i++) {\n      // 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise\n      Promise.resolve(promise[i])\n        .then((data) => {\n          result[i] = data;\n          index++;\n          if (index === len) resolve(result);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    }\n  });\n};\n复制代码;\n\n\n\n# 实现 Promise.race\n\nrace 的实现相比之下就简单一些，只要有一个 promise 执行完，直接 resolve 并停止执行。\n\nPromise.race = function(promises) {\n  return new Promise((resolve, reject) => {\n    let len = promises.length;\n    if (len === 0) return;\n    for (let i = 0; i < len; i++) {\n      Promise.resolve(promise[i])\n        .then((data) => {\n          resolve(data);\n          return;\n        })\n        .catch((err) => {\n          reject(err);\n          return;\n        });\n    }\n  });\n};\n复制代码;\n\n\n到此为止，一个完整的 Promise 就被我们实现完啦。从原理到细节，我们一步步拆解和实现，希望大家在知道 Promise 设计上的几大亮点之后，也能自己手动实现一个 Promise，让自己的思维层次和动手能力更上一层楼！\n\n\n# 第 39 篇: 谈谈你对生成器以及协程的理解。\n\n生成器(Generator)是 ES6 中的新语法，相对于之前的异步语法，上手的难度还是比较大的。因此这里我们先来好好熟悉一下 Generator 语法。\n\n\n# 生成器执行流程\n\n上面是生成器函数？\n\n生成器是一个带星号的\"函数\"(注意：它并不是真正的函数)，可以通过yield关键字暂停执行和恢复执行的\n\n举个例子:\n\nfunction* gen() {\n  console.log('enter');\n  let a = yield 1;\n  let b = yield (function() {\n    return 2;\n  })();\n  return 3;\n}\nvar g = gen(); // 阻塞住，不会执行任何语句\nconsole.log(typeof g); // object  看到了吗？不是\"function\"\n\nconsole.log(g.next());\nconsole.log(g.next());\nconsole.log(g.next());\nconsole.log(g.next());\n\n// enter\n// { value: 1, done: false }\n\n// { value: 2, done: false }\n// { value: 3, done: true }\n// { value: undefined, done: true }\n复制代码;\n\n\n由此可以看到，生成器的执行有这样几个关键点:\n\n 1. 调用 gen() 后，程序会阻塞住，不会执行任何语句。\n 2. 调用 g.next() 后，程序继续执行，直到遇到 yield 程序暂停。\n 3. next 方法返回一个对象， 有两个属性: value 和 done。value 为当前 yield 后面的结果，done 表示是否执行完，遇到了return 后，done 会由false变为true。\n\n\n# yield*\n\n当一个生成器要调用另一个生成器时，使用 yield* 就变得十分方便。比如下面的例子:\n\nfunction* gen1() {\n  yield 1;\n  yield 4;\n}\nfunction* gen2() {\n  yield 2;\n  yield 3;\n}\n复制代码;\n\n\n我们想要按照1234的顺序执行，如何来做呢？\n\n在 gen1 中，修改如下:\n\nfunction* gen1() {\n  yield 1;\n  yield* gen2();\n  yield 4;\n}\n复制代码;\n\n\n这样修改之后，之后依次调用next即可。\n\n\n# 生成器实现机制——协程\n\n可能你会比较好奇，生成器究竟是如何让函数暂停, 又会如何恢复的呢？接下来我们就来对其中的执行机制——协程一探究竟。\n\n# 什么是协程？\n\n协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。\n\n# 协程的运作过程\n\n那你可能要问了，JS 不是单线程执行的吗，开这么多协程难道可以一起执行吗？\n\n答案是：并不能。一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将JS 线程的控制权转交给 B协程，那么现在 B 执行，A 就相当于处于暂停的状态。\n\n举个具体的例子:\n\nfunction* A() {\n  console.log('我是A');\n  yield B(); // A停住，在这里转交线程执行权给B\n  console.log('结束了');\n}\nfunction B() {\n  console.log('我是B');\n  return 100; // 返回，并且将线程执行权还给A\n}\nlet gen = A();\ngen.next();\ngen.next();\n\n// 我是A\n// 我是B\n// 结束了\n复制代码;\n\n\n在这个过程中，A 将执行权交给 B，也就是 A 启动 B，我们也称 A 是 B 的父协程。因此 B 当中最后return 100其实是将 100 传给了父协程。\n\n需要强调的是，对于协程来说，它并不受操作系统的控制，完全由用户自定义切换，因此并没有进程/线程上下文切换的开销，这是高性能的重要原因。\n\nOK, 原理就说到这里。可能你还会有疑问: 这个生成器不就暂停-恢复、暂停-恢复这样执行的吗？它和异步有什么关系？而且，每次执行都要调用 next，能不能让它一次性执行完毕呢？下一节我们就来仔细拆解这些问题。\n\n\n# 第 40 篇: 如何让 Generator 的异步代码按顺序执行完毕？\n\n这里面其实有两个问题:\n\n 1. Generator 如何跟异步产生关系？\n 2. 怎么把 Generator 按顺序执行完毕？\n\n\n# thunk 函数\n\n要想知道 Generator 跟异步的关系，首先带大家搞清楚一个概念——thunk 函数(即偏函数)，虽然这只是实现两者关系的方式之一。(另一种方式是Promise, 后面会讲到)\n\n举个例子，比如我们现在要判断数据类型。可以写如下的判断逻辑:\n\nlet isString = (obj) => {\n  return (\n    Object.prototype.toString.call(obj) ===\n    '[object String]'\n  );\n};\nlet isFunction = (obj) => {\n  return (\n    Object.prototype.toString.call(obj) ===\n    '[object Function]'\n  );\n};\nlet isArray = (obj) => {\n  return (\n    Object.prototype.toString.call(obj) === '[object Array]'\n  );\n};\nlet isSet = (obj) => {\n  return (\n    Object.prototype.toString.call(obj) === '[object Set]'\n  );\n};\n// ...\n复制代码;\n\n\n可以看到，出现了非常多重复的逻辑。我们将它们做一下封装:\n\nlet isType = (type) => {\n  return (obj) => {\n    return (\n      Object.prototype.toString.call(obj) ===\n      `[object ${type}]`\n    );\n  };\n};\n复制代码;\n\n\n现在我们这样做即可:\n\nlet isString = isType('String');\nlet isFunction = isType('Function');\n//...\n复制代码;\n\n\n相应的 isString和isFunction是由isType生产出来的函数，但它们依然可以判断出参数是否为 String（Function），而且代码简洁了不少。\n\nisString('123');\nisFunction((val) => val);\n复制代码;\n\n\nisType这样的函数我们称为thunk 函数。它的核心逻辑是接收一定的参数，生产出定制化的函数，然后使用定制化的函数去完成功能。thunk 函数的实现会比单个的判断函数复杂一点点，但就是这一点点的复杂，大大方便了后续的操作。\n\n\n# Generator 和 异步\n\n# thunk 版本\n\n以文件操作为例，我们来看看 异步操作 如何应用于Generator。\n\nconst readFileThunk = (filename) => {\n  return (callback) => {\n    fs.readFile(filename, callback);\n  };\n};\n复制代码;\n\n\nreadFileThunk就是一个thunk函数。异步操作核心的一环就是绑定回调函数，而thunk函数可以帮我们做到。首先传入文件名，然后生成一个针对某个文件的定制化函数。这个函数中传入回调，这个回调就会成为异步操作的回调。这样就让 Generator 和异步关联起来了。\n\n紧接者我们做如下的操作:\n\nconst gen = function*() {\n  const data1 = yield readFileThunk('001.txt');\n  console.log(data1.toString());\n  const data2 = yield readFileThunk('002.txt');\n  console.log(data2.toString);\n};\n复制代码;\n\n\n接着我们让它执行完:\n\nlet g = gen();\n// 第一步: 由于进场是暂停的，我们调用next，让它开始执行。\n// next返回值中有一个value值，这个value是yield后面的结果，放在这里也就是是thunk函数生成的定制化函数，里面需要传一个回调函数作为参数\ng.next().value((err, data1) => {\n  // 第二步: 拿到上一次得到的结果，调用next, 将结果作为参数传入，程序继续执行。\n  // 同理，value传入回调\n  g.next(data1).value((err, data2) => {\n    g.next(data2);\n  });\n});\n\n复制代码;\n\n\n打印结果如下:\n\n001.txt的内容\n002.txt的内容\n复制代码\n\n\n上面嵌套的情况还算简单，如果任务多起来，就会产生很多层的嵌套，可操作性不强，有必要把执行的代码封装一下:\n\nfunction run(gen) {\n  const next = (err, data) => {\n    let res = gen.next(data);\n    if (res.done) return;\n    res.value(next);\n  };\n  next();\n}\nrun(g);\n复制代码;\n\n\nOk,再次执行，依然打印正确的结果。代码虽然就这么几行，但包含了递归的过程，好好体会一下。\n\n这是通过thunk完成异步操作的情况。\n\n# Promise 版本\n\n还是拿上面的例子，用Promise来实现就轻松一些:\n\nconst readFilePromise = (filename) => {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filename, (err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  }).then((res) => res);\n};\nconst gen = function*() {\n  const data1 = yield readFilePromise('001.txt');\n  console.log(data1.toString());\n  const data2 = yield readFilePromise('002.txt');\n  console.log(data2.toString);\n};\n复制代码;\n\n\n执行的代码如下:\n\nlet g = gen();\nfunction getGenPromise(gen, data) {\n  return gen.next(data).value;\n}\ngetGenPromise(g)\n  .then((data1) => {\n    return getGenPromise(g, data1);\n  })\n  .then((data2) => {\n    return getGenPromise(g, data2);\n  });\n复制代码;\n\n\n打印结果如下:\n\n001.txt的内容\n002.txt的内容\n复制代码\n\n\n同样，我们可以对执行Generator的代码加以封装:\n\nfunction run(g) {\n  const next = (data) => {\n    let res = g.next();\n    if (res.done) return;\n    res.value.then((data) => {\n      next(data);\n    });\n  };\n  next();\n}\n复制代码;\n\n\n同样能输出正确的结果。代码非常精炼，希望能参照刚刚链式调用的例子，仔细体会一下递归调用的过程。\n\n\n# 采用 co 库\n\n以上我们针对 thunk 函数和Promise两种Generator异步操作的一次性执行完毕做了封装，但实际场景中已经存在成熟的工具包了，如果大名鼎鼎的co库, 其实核心原理就是我们已经手写过了（就是刚刚封装的 Promise 情况下的执行代码），只不过源码会各种边界情况做了处理。使用起来非常简单:\n\nconst co = require('co');\nlet g = gen();\nco(g).then((res) => {\n  console.log(res);\n});\n复制代码;\n\n\n打印结果如下:\n\n(001).txt的内容;\n(002).txt的内容;\n100;\n复制代码;\n\n\n简单几行代码就完成了Generator所有的操作，真不愧co和Generator天生一对啊！\n\n\n# 第 41 篇: 解释一下 async/await 的运行机制。\n\nasync/await被称为 JS 中异步终极解决方案。它既能够像 co + Generator 一样用同步的方式来书写异步代码，又得到底层的语法支持，无需借助任何第三方库。接下来，我们从原理的角度来重新审视这个语法糖背后究竟做了些什么。\n\n\n# async\n\n什么是 async ?\n\n> MDN 的定义: async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。\n\n注意重点: 返回结果为 Promise。\n\n举个例子:\n\nasync function func() {\n  return 100;\n}\nconsole.log(func());\n// Promise {<resolved>: 100}\n复制代码;\n\n\n这就是隐式返回 Promise 的效果。\n\n\n# await\n\n我们来看看 await做了些什么事情。\n\n以一段代码为例:\n\nasync function test() {\n  console.log(100);\n  let x = await 200;\n  console.log(x);\n  console.log(200);\n}\nconsole.log(0);\ntest();\nconsole.log(300);\n复制代码;\n\n\n我们来分析一下这段程序。首先代码同步执行，打印出0，然后将test压入执行栈，打印出100, 下面注意了，遇到了关键角色await。\n\n放个慢镜头:\n\nawait 100;\n复制代码;\n\n\n被 JS 引擎转换成一个 Promise :\n\nlet promise = new Promise((resolve, reject) => {\n  resolve(100);\n});\n复制代码;\n\n\n这里调用了 resolve，resolve 的任务进入微任务队列。\n\n然后，JS 引擎将暂停当前协程的运行，把线程的执行权交给父协程(父协程不懂是什么的，上上篇才讲，回去补课)。\n\n回到父协程中，父协程的第一件事情就是对await返回的Promise调用then, 来监听这个 Promise 的状态改变 。\n\npromise.then((value) => {\n  // 相关逻辑，在resolve 执行之后来调用\n});\n复制代码;\n\n\n然后往下执行，打印出300。\n\n根据EventLoop机制，当前主线程的宏任务完成，现在检查微任务队列, 发现还有一个 Promise 的 resolve，执行，现在父协程在then中传入的回调执行。我们来看看这个回调具体做的是什么。\n\npromise.then((value) => {\n  // 1. 将线程的执行权交给test协程\n  // 2. 把 value 值传递给 test 协程\n});\n复制代码;\n\n\nOk, 现在执行权到了test协程手上，test 接收到父协程传来的200, 赋值给 a ,然后依次执行后面的语句，打印200、200。\n\n最后的输出为:\n\n0;\n100;\n300;\n200;\n200;\n复制代码;\n\n\n总结一下，async/await利用协程和Promise实现了同步方式编写异步代码的效果，其中Generator是对协程的一种实现，虽然语法简单，但引擎在背后做了大量的工作，我们也对这些工作做了一一的拆解。用async/await写出的代码也更加优雅、美观，相比于之前的Promise不断调用 then 的方式，语义化更加明显，相比于co + Generator性能更高，上手成本也更低，不愧是 JS 异步终极解决方案！\n\n\n# 第 42 篇: forEach 中用 await 会产生什么问题?怎么解决这个问题？\n\n\n# 问题\n\n问题:对于异步代码，forEach 并不能保证按顺序执行。\n\n举个例子:\n\nasync function test() {\n  let arr = [4, 2, 1];\n  arr.forEach(async (item) => {\n    const res = await handle(item);\n    console.log(res);\n  });\n  console.log('结束');\n}\n\nfunction handle(x) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(x);\n    }, 1000 * x);\n  });\n}\n\ntest();\n复制代码;\n\n\n我们期望的结果是:\n\n4;\n2;\n1;\n结束;\n复制代码;\n\n\n但是实际上会输出:\n\n结束;\n1;\n2;\n4;\n复制代码;\n\n\n\n# 问题原因\n\n这是为什么呢？我想我们有必要看看forEach底层怎么实现的。\n\n// 核心逻辑\nfor (var i = 0; i < length; i++) {\n  if (i in array) {\n    var element = array[i];\n    callback(element, i, array);\n  }\n}\n复制代码;\n\n\n可以看到，forEach 拿过来直接执行了，这就导致它无法保证异步任务的执行顺序。比如后面的任务用时短，那么就又可能抢在前面的任务之前执行。\n\n\n# 解决方案\n\n如何来解决这个问题呢？\n\n其实也很简单, 我们利用for...of就能轻松解决。\n\nasync function test() {\n  let arr = [4, 2, 1];\n  for (const item of arr) {\n    const res = await handle(item);\n    console.log(res);\n  }\n  console.log('结束');\n}\n复制代码;\n\n\n\n# 解决原理——Iterator\n\n好了，这个问题看起来好像很简单就能搞定，你有想过这么做为什么可以成功吗？\n\n其实，for...of 并不像 forEach 那么简单粗暴的方式去遍历执行，而是采用一种特别的手段——迭代器去遍历。\n\n首先，对于数组来讲，它是一种可迭代数据类型。那什么是可迭代数据类型呢？\n\n> 原生具有[Symbol.iterator]属性数据类型为可迭代数据类型。如数组、类数组（如 arguments、NodeList）、Set 和 Map。\n\n可迭代对象可以通过迭代器进行遍历。\n\nlet arr = [4, 2, 1];\n// 这就是迭代器\nlet iterator = arr[Symbol.iterator]();\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\n\n// {value: 4, done: false}\n// {value: 2, done: false}\n// {value: 1, done: false}\n// {value: undefined, done: true}\n复制代码;\n\n\n因此，我们的代码可以这样来组织:\n\nasync function test() {\n  let arr = [4, 2, 1];\n  let iterator = arr[Symbol.iterator]();\n  let res = iterator.next();\n  while (!res.done) {\n    let value = res.value;\n    console.log(value);\n    await handle(value);\n    res = iterater.next();\n  }\n  console.log('结束');\n}\n// 4\n// 2\n// 1\n// 结束\n复制代码;\n\n\n多个任务成功地按顺序执行！其实刚刚的 for...of 循环代码就是这段代码的语法糖。\n\n\n# 重新认识生成器\n\n回头再看看用 iterator 遍历[4,2,1]这个数组的代码。\n\nlet arr = [4, 2, 1];\n// 迭代器\nlet iterator = arr[Symbol.iterator]();\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\n\n// {value: 4, done: false}\n// {value: 2, done: false}\n// {value: 1, done: false}\n// {value: undefined, done: true}\n复制代码;\n\n\n咦？返回值有value和done属性，生成器也可以调用 next,返回的也是这样的数据结构，这么巧?!\n\n没错，生成器本身就是一个迭代器。\n\n既然属于迭代器，那它就可以用 for...of 遍历了吧？\n\n当然没错，不信来写一个简单的斐波那契数列(50 以内)：\n\nfunction* fibonacci() {\n  let [prev, cur] = [0, 1];\n  console.log(cur);\n  while (true) {\n    [prev, cur] = [cur, prev + cur];\n    yield cur;\n  }\n}\n\nfor (let item of fibonacci()) {\n  if (item > 50) break;\n  console.log(item);\n}\n// 1\n// 1\n// 2\n// 3\n// 5\n// 8\n// 13\n// 21\n// 34\n复制代码;\n\n\n是不是非常酷炫？这就是迭代器的魅力：）同时又对生成器有了更深入的理解，没想到我们的老熟人Generator还有这样的身份。",
      "normalizedContent": "javascript interview\n\n> https://juejin.cn/user/430664257382462 @神三元\n\n\n# 第一篇: js 数据类型之问——概念篇\n\n\n# 1.js 原始数据类型有哪些？引用数据类型有哪些？\n\n在 js 中，存在着 7 种原始值，分别是：\n\n * boolean\n * null\n * undefined\n * number\n * string\n * symbol\n * bigint\n\n引用数据类型: 对象 object（包含普通对象-object，数组对象-array，正则对象-regexp，日期对象-date，数学函数-math，函数对象-function）\n\n\n# 2.说出下面运行的结果，解释原因。\n\nfunction test(person) {\n  person.age = 26;\n  person = {\n    name: 'hzj',\n    age: 18,\n  };\n  return person;\n}\nconst p1 = {\n  name: 'fyq',\n  age: 19,\n};\nconst p2 = test(p1);\nconsole.log(p1); // -> ?\nconsole.log(p2); // -> ?\n复制代码;\n\n\n结果:\n\np1：{name: “fyq”, age: 26}\np2：{name: “hzj”, age: 18}\n复制代码\n\n\n> 原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test 函数中的实参 person 是 p1 对象的内存地址，通过调用 person.age = 26 确实改变了 p1 的值，但随后 person 变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了 p2。\n\n\n# 3.null 是对象吗？为什么？\n\n结论: null 不是对象。\n\n解释: 虽然 typeof null 会输出 object，但是这只是 js 存在的一个悠久 bug。在 js 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。\n\n\n# 4.'1'.tostring()为什么可以调用？\n\n其实在这个语句运行的过程中做了这样几件事情：\n\nvar s = new object('1');\ns.tostring();\ns = null;\n复制代码;\n\n\n第一步: 创建 object 类实例。注意为什么不是 string ？ 由于 symbol 和 bigint 的出现，对它们调用 new 都会报错，目前 es6 规范也不建议用 new 来创建基本类型的包装类。\n\n第二步: 调用实例方法。\n\n第三步: 执行完方法立即销毁这个实例。\n\n整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括 boolean, number 和 string。\n\n> 参考:《javascript 高级程序设计(第三版)》p118\n\n\n# 5.0.1+0.2 为什么不等于 0.3？\n\n0.1 和 0.2 在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成 0.30000000000000004。\n\n\n# 6.如何理解 bigint?\n\n# 什么是 bigint?\n\n> bigint 是一种新的数据类型，用于当整数值大于 number 数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数 id，等等，而不需要使用库。\n\n# 为什么需要 bigint?\n\n在 js 中，所有的数字都以双精度 64 位浮点格式表示，那这会带来什么问题呢？\n\n这导致 js 中的 number 无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，js 中的 number 类型只能安全地表示-9007199254740991(-(2^53-1))和 9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。\n\nconsole.log(999999999999999); //=>10000000000000000\n复制代码;\n\n\n同时也会有一定的安全性问题:\n\n9007199254740992 === 9007199254740993; // → true 居然是true!\n复制代码;\n\n\n# 如何创建并使用 bigint？\n\n要创建 bigint，只需要在数字末尾追加 n 即可。\n\nconsole.log(9007199254740995n); // → 9007199254740995n\nconsole.log(9007199254740995); // → 9007199254740996\n复制代码;\n\n\n另一种创建 bigint 的方法是用 bigint()构造函数、\n\nbigint('9007199254740995'); // → 9007199254740995n\n复制代码;\n\n\n简单使用如下:\n\n10n + 20n; // → 30n\n10n - 20n; // → -10n\n+10n; // → typeerror: cannot convert a bigint value to a number\n-10n; // → -10n\n10n * 20n; // → 200n\n20n / 10n; // → 2n\n23n % 10n; // → 3n\n10n ** 3n; // → 1000n\n\nconst x = 10n;\n++x; // → 11n\n--x; // → 9n\nconsole.log(typeof x); //\"bigint\"\n复制代码;\n\n\n# 值得警惕的点\n\n 1. bigint 不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js 代码。\n 2. 因为隐式类型转换可能丢失信息，所以不允许在 bigint 和 number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由 bigint 或 number 精确表示。\n\n10 + 10n; // → typeerror\n复制代码;\n\n\n 1. 不能将 bigint 传递给 web api 和内置的 js 函数，这些函数需要一个 number 类型的数字。尝试这样做会报 typeerror 错误。\n\nmath.max(2n, 4n, 6n); // → typeerror\n复制代码;\n\n\n 1. 当 boolean 类型与 bigint 类型相遇时，bigint 的处理方式与 number 类似，换句话说，只要不是 0n，bigint 就被视为 truthy 的值。\n\nif (0n) {\n  //条件判断为false\n}\nif (3n) {\n  //条件为true\n}\n复制代码;\n\n\n 1. 元素都为 bigint 的数组可以进行 sort。\n 2. bigint 可以正常地进行位运算，如|、&、<<、>>和^\n\n# 浏览器兼容性\n\ncaniuse 的结果:\n\n\n\n其实现在的兼容性并不怎么好，只有 chrome67、firefox、opera 这些主流实现，要正式成为规范，其实还有很长的路要走。\n\n我们期待 bigint 的光明前途！\n\n\n# 第二篇: js 数据类型之问——检测篇\n\n\n# 1. typeof 是否能正确判断类型？\n\n对于原始类型来说，除了 null 都可以调用 typeof 显示正确的类型。\n\ntypeof 1; // 'number'\ntypeof '1'; // 'string'\ntypeof undefined; // 'undefined'\ntypeof true; // 'boolean'\ntypeof symbol(); // 'symbol'\n复制代码;\n\n\n但对于引用数据类型，除了函数之外，都会显示\"object\"。\n\ntypeof []; // 'object'\ntypeof {}; // 'object'\ntypeof console.log; // 'function'\n复制代码;\n\n\n因此采用 typeof 判断对象数据类型是不合适的，采用 instanceof 会更好，instanceof 的原理是基于原型链的查询，只要处于原型链中，判断永远为 true\n\nconst person = function() {};\nconst p1 = new person();\np1 instanceof person; // true\n\nvar str1 = 'hello world';\nstr1 instanceof string; // false\n\nvar str2 = new string('hello world');\nstr2 instanceof string; // true\n复制代码;\n\n\n\n# 2. instanceof 能否判断基本数据类型？\n\n能。比如下面这种方式:\n\nclass primitivenumber {\n  static [symbol.hasinstance](x) {\n    return typeof x === 'number';\n  }\n}\nconsole.log(111 instanceof primitivenumber); // true\n复制代码;\n\n\n如果你不知道 symbol，可以看看mdn 上关于 hasinstance 的解释。\n\n其实就是自定义 instanceof 行为的一种方式，这里将原有的 instanceof 方法重定义，换成了 typeof，因此能够判断基本数据类型。\n\n\n# 3. 能不能手动实现一下 instanceof 的功能？\n\n核心: 原型链的向上查找。\n\nfunction myinstanceof(left, right) {\n  //基本数据类型直接返回false\n  if (typeof left !== 'object' || left === null)\n    return false;\n  //getprotypeof是object对象自带的一个方法，能够拿到参数的原型对象\n  let proto = object.getprototypeof(left);\n  while (true) {\n    //查找到尽头，还没找到\n    if (proto == null) return false;\n    //找到相同的原型对象\n    if (proto == right.prototype) return true;\n    proto = object.getprototypeof(proto);\n  }\n}\n\n复制代码;\n\n\n测试:\n\nconsole.log(myinstanceof('111', string)); //false\nconsole.log(myinstanceof(new string('111'), string)); //true\n复制代码;\n\n\n\n# 4. object.is 和===的区别？\n\nobject 在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0 和-0，nan 和 nan。 源码如下：\n\nfunction is(x, y) {\n  if (x === y) {\n    //运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +infinity， 1/-0 = -infinity, 是不一样的\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    //nan===nan是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 nan, y 同理\n    //两个都是nan的时候返回true\n    return x !== x && y !== y;\n  }\n\n\n复制代码\n\n\n\n# 第三篇: js 数据类型之问——转换篇\n\n\n# 1. [] == ![]结果是什么？为什么？\n\n解析:\n\n== 中，左右两边都需要转换为数字然后进行比较。\n\n[]转换为数字为 0。\n\n![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为 true,\n\n因此![]为 false，进而在转换成数字，变为 0。\n\n0 == 0 ， 结果为 true\n\n\n# 2. js 中类型转换有哪几种？\n\njs 中，类型转换只有三种：\n\n * 转换成数字\n * 转换成布尔值\n * 转换成字符串\n\n转换具体规则如下:\n\n> 注意\"boolean 转字符串\"这行结果指的是 true 转字符串的例子\n\n\n\n\n# 3. == 和 ===有什么区别？\n\n===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如'1'===1的结果是false，因为一边是string，另一边是number。\n复制代码\n\n\n==不像===那样严格，对于一般情况，只要值相等，就返回 true，但==还涉及一些类型转换，它的转换规则如下：\n\n * 两边的类型是否相同，相同的话就比较值的大小，例如 1==2，返回 false\n * 判断的是否是 null 和 undefined，是的话就返回 true\n * 判断的类型是否是 string 和 number，是的话，把 string 类型转换成 number，再进行比较\n * 判断其中一方是否是 boolean，是的话就把 boolean 转换成 number，再进行比较\n * 如果其中一方为 object，且另一方为 string、number 或者 symbol，会将 object 转换成字符串，再进行比较\n\nconsole.log({ a: 1 } == true); //false\nconsole.log({ a: 1 } == '[object object]'); //true\n复制代码;\n\n\n\n# 4. 对象转原始类型是根据什么流程运行的？\n\n对象转原始类型，会调用内置的[toprimitive]函数，对于该函数而言，其逻辑如下：\n\n 1. 如果 symbol.toprimitive()方法，优先调用再返回\n 2. 调用 valueof()，如果转换为原始类型，则返回\n 3. 调用 tostring()，如果转换为原始类型，则返回\n 4. 如果都没有返回原始类型，会报错\n\nvar obj = {\n  value: 3,\n  valueof() {\n    return 4;\n  },\n  tostring() {\n    return '5';\n  },\n  [symbol.toprimitive]() {\n    return 6;\n  },\n};\nconsole.log(obj + 1); // 输出7\n复制代码;\n\n\n\n# 5. 如何让 if(a == 1 && a == 2)条件成立？\n\n其实就是上一个问题的应用。\n\nvar a = {\n  value: 0,\n  valueof: function() {\n    this.value++;\n    return this.value;\n  },\n};\nconsole.log(a == 1 && a == 2); //true\n复制代码;\n\n\n\n# 第四篇: 谈谈你对闭包的理解\n\n\n# 什么是闭包？\n\n红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，\n复制代码\nmdn 对闭包的定义为：闭包是指那些能够访问自由变量的函数。\n\n（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）\n复制代码\n\n\n\n# 闭包产生的原因?\n\n首先要明白作用域链的概念，其实很简单，在 es5 中只存在两种作用域————全局作用域和函数作用域，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。 比如:\n\nvar a = 1;\nfunction f1() {\n  var a = 2;\n  function f2() {\n    var a = 3;\n    console.log(a); //3\n  }\n}\n复制代码;\n\n\n在这段代码中，f1 的作用域指向有全局作用域(window)和它本身，而 f2 的作用域指向全局作用域(window)、f1 和它本身。而且作用域是从最底层向上找，直到找到全局作用域 window 为止，如果全局还没有的话就会报错。就这么简单一件事情！\n\n闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:\n\nfunction f1() {\n  var a = 2;\n  function f2() {\n    console.log(a); //2\n  }\n  return f2;\n}\nvar x = f1();\nx();\n复制代码;\n\n\n这里 x 会拿到父级作用域中的变量，输出 2。因为在当前环境中，含有对 f2 的引用，f2 恰恰引用了 window、f1 和 f2 的作用域。因此 f2 可以访问到 f1 的作用域的变量。\n\n那是不是只有返回函数才算是产生了闭包呢？、\n\n回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：\n\nvar f3;\nfunction f1() {\n  var a = 2;\n  f3 = function() {\n    console.log(a);\n  };\n}\nf1();\nf3();\n复制代码;\n\n\n让 f1 执行，给 f3 赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了 a,因此输出 2。\n\n在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。\n\n\n# 闭包有哪些表现形式?\n\n明白了本质之后，我们就来看看，在真实的场景中，究竟在哪些地方能体现闭包的存在？\n\n 1. 返回一个函数。刚刚已经举例。\n 2. 作为函数参数传递\n\nvar a = 1;\nfunction foo() {\n  var a = 2;\n  function baz() {\n    console.log(a);\n  }\n  bar(baz);\n}\nfunction bar(fn) {\n  // 这就是闭包\n  fn();\n}\n// 输出2，而不是1\nfoo();\n复制代码;\n\n\n 1. 在定时器、事件监听、ajax 请求、跨窗口通信、web workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。\n\n以下的闭包保存的仅仅是 window 和当前作用域。\n\n// 定时器\nsettimeout(function timehandler(){\n  console.log('111');\n}，100)\n\n// 事件监听\n$('#app').click(function(){\n  console.log('dom listener');\n})\n复制代码\n\n\n 1. iife(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。\n\nvar a = 2;\n(function iife() {\n  // 输出2\n  console.log(a);\n})();\n复制代码;\n\n\n\n# 如何解决下面的循环输出问题？\n\nfor (var i = 1; i <= 5; i++) {\n  settimeout(function timer() {\n    console.log(i);\n  }, 0);\n}\n复制代码;\n\n\n为什么会全部输出 6？如何改进，让它输出 1，2，3，4，5？(方法越多越好)\n\n因为 settimeout 为宏任务，由于 js 中单线程 eventloop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 settimeout 中的回调才依次执行，但输出 i 的时候当前作用域没有，往上一级再找，发现了 i,此时循环已经结束，i 变成了 6。因此会全部输出 6。\n\n解决方法：\n\n1、利用 iife(立即执行函数表达式)当每次 for 循环时，把此时的 i 变量传递到定时器中\n\nfor (var i = 1; i <= 5; i++) {\n  (function(j) {\n    settimeout(function timer() {\n      console.log(j);\n    }, 0);\n  })(i);\n}\n复制代码;\n\n\n2、给定时器传入第三个参数, 作为 timer 函数的第一个函数参数\n\nfor (var i = 1; i <= 5; i++) {\n  settimeout(\n    function timer(j) {\n      console.log(j);\n    },\n    0,\n    i,\n  );\n}\n复制代码;\n\n\n3、使用 es6 中的 let\n\nfor (let i = 1; i <= 5; i++) {\n  settimeout(function timer() {\n    console.log(i);\n  }, 0);\n}\n复制代码;\n\n\nlet 使 js 发生革命性的变化，让 js 有函数作用域变为了块级作用域，用 let 后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:\n\n// i = 1\n{\n  settimeout(function timer(){\n    console.log(1)\n  },0)\n}\n// i = 2\n{\n  settimeout(function timer(){\n    console.log(2)\n  },0)\n}\n// i = 3\n...\n复制代码\n\n\n因此能输出正确的结果。\n\n\n# 第五篇: 谈谈你对原型链的理解\n\n\n# 1.原型对象和构造函数有何关系？\n\n在 javascript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象。\n\n当函数经过 new 调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个proto属性，指向构造函数的原型对象。\n\n\n\n\n# 2.能不能描述一下原型链？\n\njavascript 对象通过proto 指向父类对象，直到指向 object 对象为止，这样就形成了一个原型指向的链条, 即原型链。\n\n\n\n * 对象的 hasownproperty() 来检查对象自身中是否含有该属性\n * 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true\n\n\n# 第六篇: js 如何实现继承？\n\n\n# 第一种: 借助 call\n\nfunction parent1() {\n  this.name = 'parent1';\n}\nfunction child1() {\n  parent1.call(this);\n  this.type = 'child1';\n}\nconsole.log(new child1());\n复制代码;\n\n\n这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。\n\n\n# 第二种: 借助原型链\n\nfunction parent2() {\n  this.name = 'parent2';\n  this.play = [1, 2, 3];\n}\nfunction child2() {\n  this.type = 'child2';\n}\nchild2.prototype = new parent2();\n\nconsole.log(new child2());\n复制代码;\n\n\n看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：\n\nvar s1 = new child2();\nvar s2 = new child2();\ns1.play.push(4);\nconsole.log(s1.play, s2.play);\n复制代码;\n\n\n可以看到控制台：\n\n\n\n明明我只改变了 s1 的 play 属性，为什么 s2 也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。\n\n那么还有更好的方式么？\n\n\n# 第三种：将前两种组合\n\nfunction parent3() {\n  this.name = 'parent3';\n  this.play = [1, 2, 3];\n}\nfunction child3() {\n  parent3.call(this);\n  this.type = 'child3';\n}\nchild3.prototype = new parent3();\nvar s3 = new child3();\nvar s4 = new child3();\ns3.play.push(4);\nconsole.log(s3.play, s4.play);\n复制代码;\n\n\n可以看到控制台：\n\n\n\n之前的问题都得以解决。但是这里又徒增了一个新问题，那就是 parent3 的构造函数会多执行了一次（child3.prototype = new parent3();）。这是我们不愿看到的。那么如何解决这个问题？\n\n\n# 第四种: 组合继承的优化 1\n\nfunction parent4() {\n  this.name = 'parent4';\n  this.play = [1, 2, 3];\n}\nfunction child4() {\n  parent4.call(this);\n  this.type = 'child4';\n}\nchild4.prototype = parent4.prototype;\n复制代码;\n\n\n这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：\n\nvar s3 = new child4();\nvar s4 = new child4();\nconsole.log(s3);\n复制代码;\n\n\n\n\n子类实例的构造函数是 parent4，显然这是不对的，应该是 child4。\n\n\n# 第五种(最推荐使用): 组合继承的优化 1\n\nfunction parent5() {\n  this.name = 'parent5';\n  this.play = [1, 2, 3];\n}\nfunction child5() {\n  parent5.call(this);\n  this.type = 'child5';\n}\nchild5.prototype = object.create(parent5.prototype);\nchild5.prototype.constructor = child5;\n复制代码;\n\n\n这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。\n\n\n# es6 的 extends 被编译后的 javascript 代码\n\nes6 的代码最后都是要在浏览器上能够跑起来的，这中间就利用了 babel 这个编译工具，将 es6 的代码编译成 es5 让一些不支持新语法的浏览器也能运行。\n\n那最后编译成了什么样子呢？\n\nfunction _possibleconstructorreturn(self, call) {\n  // ...\n  return call &&\n    (typeof call === 'object' || typeof call === 'function')\n    ? call\n    : self;\n}\n\nfunction _inherits(subclass, superclass) {\n  // ...\n  //看到没有\n  subclass.prototype = object.create(\n    superclass && superclass.prototype,\n    {\n      constructor: {\n        value: subclass,\n        enumerable: false,\n        writable: true,\n        configurable: true,\n      },\n    },\n  );\n  if (superclass)\n    object.setprototypeof\n      ? object.setprototypeof(subclass, superclass)\n      : (subclass.__proto__ = superclass);\n}\n\nvar parent = function parent() {\n  // 验证是否是 parent 构造出来的 this\n  _classcallcheck(this, parent);\n};\n\nvar child = (function(_parent) {\n  _inherits(child, _parent);\n\n  function child() {\n    _classcallcheck(this, child);\n\n    return _possibleconstructorreturn(\n      this,\n      (\n        child.__proto__ || object.getprototypeof(child)\n      ).apply(this, arguments),\n    );\n  }\n\n  return child;\n})(parent);\n复制代码;\n\n\n核心是_inherits 函数，可以看到它采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个 object.setprototypeof(subclass, superclass)，这是用来干啥的呢？\n\n答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。\n\n追问: 面向对象的设计一定是好的设计吗？\n复制代码\n\n\n不一定。从继承的角度说，这一设计是存在巨大隐患的。\n\n\n# 从设计思想上谈谈继承本身的问题\n\n假如现在有不同品牌的车，每辆车都有 drive、music、addoil 这三个方法。\n\nclass car {\n  constructor(id) {\n    this.id = id;\n  }\n  drive() {\n    console.log('wuwuwu!');\n  }\n  music() {\n    console.log('lalala!');\n  }\n  addoil() {\n    console.log('哦哟！');\n  }\n}\nclass othercar extends car {}\n复制代码;\n\n\n现在可以实现车的功能，并且以此去扩展不同的车。\n\n但是问题来了，新能源汽车也是车，但是它并不需要 addoil(加油)。\n\n如果让新能源汽车的类继承 car 的话，也是有问题的，俗称\"大猩猩和香蕉\"的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。\n\n> 继承的最大问题在于：无法决定继承哪些属性，所有属性都得继承。\n\n当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，代码势必会大量重复，另一方面一旦子类有所变动，父类也要进行相应的更新，代码的耦合性太高，维护性不好。\n\n那如何来解决继承的诸多问题呢？\n\n用组合，这也是当今编程语法发展的趋势，比如 golang 完全采用的是面向组合的设计方式。\n\n顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。\n\nfunction drive() {\n  console.log('wuwuwu!');\n}\nfunction music() {\n  console.log('lalala!');\n}\nfunction addoil() {\n  console.log('哦哟！');\n}\n\nlet car = compose(drive, music, addoil);\nlet newenergycar = compose(drive, music);\n复制代码;\n\n\n代码干净，复用性也很好。这就是面向组合的设计方式。\n\n\n# 第七篇: 函数的 arguments 为什么不是数组？如何转化成数组？\n\n因为 arguments 本身并不能调用数组方法，它是一个另外一种对象类型，只不过属性从 0 开始排，依次为 0，1，2...最后还有 callee 和 length 属性。我们也把这样的对象称为类数组。\n\n常见的类数组还有：\n\n * 1. 用 getelementsbytagname/classname()获得的 htmlcollection\n * 1. 用 queryselector 获得的 nodelist\n\n那这导致很多数组的方法就不能用了，必要时需要我们将它们转换成数组，有哪些方法呢？\n\n\n# 1. array.prototype.slice.call()\n\nfunction sum(a, b) {\n  let args = array.prototype.slice.call(arguments);\n  console.log(args.reduce((sum, cur) => sum + cur)); //args可以调用数组原生的方法啦\n}\nsum(1, 2); //3\n复制代码;\n\n\n\n# 2. array.from()\n\nfunction sum(a, b) {\n  let args = array.from(arguments);\n  console.log(args.reduce((sum, cur) => sum + cur)); //args可以调用数组原生的方法啦\n}\nsum(1, 2); //3\n复制代码;\n\n\n这种方法也可以用来转换 set 和 map 哦！\n\n\n# 3. es6 展开运算符\n\nfunction sum(a, b) {\n  let args = [...arguments];\n  console.log(args.reduce((sum, cur) => sum + cur)); //args可以调用数组原生的方法啦\n}\nsum(1, 2); //3\n复制代码;\n\n\n\n# 4. 利用 concat+apply\n\nfunction sum(a, b) {\n  let args = array.prototype.concat.apply([], arguments); //apply方法会把第二个参数展开\n  console.log(args.reduce((sum, cur) => sum + cur)); //args可以调用数组原生的方法啦\n}\nsum(1, 2); //3\n复制代码;\n\n\n当然，最原始的方法就是再创建一个数组，用 for 循环把类数组的每个属性值放在里面，过于简单，就不浪费篇幅了。\n\n\n# 第八篇: foreach 中 return 有效果吗？如何中断 foreach 循环？\n\n在 foreach 中用 return 不会返回，函数会继续执行。\n\nlet nums = [1, 2, 3];\nnums.foreach((item, index) => {\n  return; //无效\n});\n复制代码;\n\n\n中断方法：\n\n 1. 使用 try 监视代码块，在需要中断的地方抛出异常。\n 2. 官方推荐方法（替换方法）：用 every 和 some 替代 foreach 函数。every 在碰到 return false 的时候，中止循环。some 在碰到 return true 的时候，中止循环\n\n\n# 第九篇: js 判断数组中是否包含某个值\n\n\n# 方法一：array.indexof\n\n> 此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。\n\nvar arr = [1, 2, 3, 4];\nvar index = arr.indexof(3);\nconsole.log(index);\n复制代码;\n\n\n\n# 方法二：array.includes(searcelement[,fromindex])\n\n> 此方法判断数组中是否存在某个值，如果存在返回 true，否则返回 false\n\nvar arr = [1, 2, 3, 4];\nif (arr.includes(3)) console.log('存在');\nelse console.log('不存在');\n复制代码;\n\n\n\n# 方法三：array.find(callback[,thisarg])\n\n> 返回数组中满足条件的第一个元素的值，如果没有，返回 undefined\n\nvar arr = [1, 2, 3, 4];\nvar result = arr.find((item) => {\n  return item > 3;\n});\nconsole.log(result);\n复制代码;\n\n\n\n# 方法四：array.findeindex(callback[,thisarg])\n\n> 返回数组中满足条件的第一个元素的下标，如果没有找到，返回-1]\n\nvar arr = [1, 2, 3, 4];\nvar result = arr.findindex((item) => {\n  return item > 3;\n});\nconsole.log(result);\n复制代码;\n\n\n当然，for 循环当然是没有问题的，这里讨论的是数组方法，就不再展开了。\n\n\n# 第十篇: js 中 flat---数组扁平化\n\n对于前端项目开发过程中，偶尔会出现层叠数据结构的数组，我们需要将多层级数组转化为一级数组（即提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。那么该如何去实现呢？\n\n需求:多维数组=>一维数组\n\nlet ary = [1, [2, [3, [4, 5]]], 6]; // -> [1, 2, 3, 4, 5, 6]\nlet str = json.stringify(ary);\n复制代码;\n\n\n\n# 1. 调用 es6 中的 flat 方法\n\nary = ary.flat(infinity);\n复制代码;\n\n\n\n# 2. replace + split\n\nary = str.replace(/(\\[|\\])/g, '').split(',');\n复制代码;\n\n\n\n# 3. replace + json.parse\n\nstr = str.replace(/(\\[|\\])/g, '');\nstr = '[' + str + ']';\nary = json.parse(str);\n复制代码;\n\n\n\n# 4. 普通递归\n\nlet result = [];\nlet fn = function(ary) {\n  for (let i = 0; i < ary.length; i++) {\n    let item = ary[i];\n    if (array.isarray(ary[i])) {\n      fn(item);\n    } else {\n      result.push(item);\n    }\n  }\n};\n复制代码;\n\n\n\n# 5. 利用 reduce 函数迭代\n\nfunction flatten(ary) {\n  return ary.reduce((pre, cur) => {\n    return pre.concat(\n      array.isarray(cur) ? flatten(cur) : cur,\n    );\n  }, []);\n}\nlet ary = [1, 2, [3, 4], [5, [6, 7]]];\nconsole.log(flatten(ary));\n复制代码;\n\n\n\n# 6：扩展运算符\n\n//只要有一个元素有数组，那么循环继续\nwhile (ary.some(array.isarray)) {\n  ary = [].concat(...ary);\n}\n复制代码;\n\n\n这是一个比较实用而且很容易被问到的问题，欢迎大家交流补充。\n\n\n# 第十一篇: js 数组的高阶函数——基础篇\n\n\n# 1.什么是高阶函数\n\n概念非常简单，如下:\n\n> 一个函数就可以接收另一个函数作为参数或者返回值为一个函数，这种函数就称之为高阶函数。\n\n那对应到数组中有哪些方法呢？\n\n\n# 2.数组中的高阶函数\n\n# 1.map\n\n * 参数:接受两个参数，一个是回调函数，一个是回调函数的 this 值(可选)。\n\n其中，回调函数被默认传入三个值，依次为当前元素、当前索引、整个数组。\n\n * 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果\n * 对原来的数组没有影响\n\nlet nums = [1, 2, 3];\nlet obj = { val: 5 };\nlet newnums = nums.map(function(item, index, array) {\n  return item + index + array[index] + this.val;\n  //对第一个元素，1 + 0 + 1 + 5 = 7\n  //对第二个元素，2 + 1 + 2 + 5 = 10\n  //对第三个元素，3 + 2 + 3 + 5 = 13\n}, obj);\nconsole.log(newnums); //[7, 10, 13]\n复制代码;\n\n\n当然，后面的参数都是可选的 ，不用的话可以省略。\n\n# 2. reduce\n\n * 参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中四个默认参数，依次为积累值、当前值、当前索引和整个数组。\n\nlet nums = [1, 2, 3];\n// 多个数的加和\nlet newnums = nums.reduce(function(\n  presum,\n  curval,\n  currentindex,\n  array,\n) {\n  return presum + curval;\n},\n0);\nconsole.log(newnums); //6\n复制代码;\n\n\n不传默认值会怎样？\n\n不传默认值会自动以第一个元素为初始值，然后从第二个元素开始依次累计。\n\n# 3. filter\n\n参数: 一个函数参数。这个函数接受一个默认参数，就是当前元素。这个作为参数的函数返回值为一个布尔类型，决定元素是否保留。\n\nfilter 方法返回值为一个新的数组，这个数组里面包含参数里面所有被保留的项。\n\nlet nums = [1, 2, 3];\n// 保留奇数项\nlet oddnums = nums.filter((item) => item % 2);\nconsole.log(oddnums);\n复制代码;\n\n\n# 4. sort\n\n参数: 一个用于比较的函数，它有两个默认参数，分别是代表比较的两个元素。\n\n举个例子:\n\nlet nums = [2, 3, 1];\n//两个比较的元素分别为a, b\nnums.sort(function(a, b) {\n  if (a > b) return 1;\n  else if (a < b) return -1;\n  else if (a == b) return 0;\n});\n复制代码;\n\n\n当比较函数返回值大于 0，则 a 在 b 的后面，即 a 的下标应该比 b 大。\n\n反之，则 a 在 b 的后面，即 a 的下标比 b 小。\n\n整个过程就完成了一次升序的排列。\n\n当然还有一个需要注意的情况，就是比较函数不传的时候，是如何进行排序的？\n\n> 答案是将数字转换为字符串，然后根据字母 unicode 值进行升序排序，也就是根据字符串的比较规则进行升序排序。\n\n\n# 第十二篇: 能不能实现数组 map 方法 ?\n\n依照 ecma262 草案，实现的 map 的规范如下:\n\n\n\n下面根据草案的规定一步步来模拟实现 map 函数:\n\narray.prototype.map = function(callbackfn, thisarg) {\n  // 处理数组类型异常\n  if (this === null || this === undefined) {\n    throw new typeerror(\n      \"cannot read property 'map' of null or undefined\",\n    );\n  }\n  // 处理回调类型异常\n  if (\n    object.prototype.tostring.call(callbackfn) !=\n    '[object function]'\n  ) {\n    throw new typeerror(callbackfn + ' is not a function');\n  }\n  // 草案中提到要先转换为对象\n  let o = object(this);\n  let t = thisarg;\n\n  let len = o.length >>> 0;\n  let a = new array(len);\n  for (let k = 0; k < len; k++) {\n    // 还记得原型链那一节提到的 in 吗？in 表示在原型链查找\n    // 如果用 hasownproperty 是有问题的，它只能找私有属性\n    if (k in o) {\n      let kvalue = o[k];\n      // 依次传入this, 当前项，当前索引，整个数组\n      let mappedvalue = callbackfn.call(t, kvalue, k, o);\n      a[k] = mappedvalue;\n    }\n  }\n  return a;\n};\n复制代码;\n\n\n这里解释一下, length >>> 0, 字面意思是指\"右移 0 位\"，但实际上是把前面的空位用 0 填充，这里的作用是保证 len 为数字且为整数。\n\n举几个特例：\n\nnull >>> 0  //0\n\nundefined >>> 0  //0\n\nvoid(0) >>> 0  //0\n\nfunction a (){};  a >>> 0  //0\n\n[] >>> 0  //0\n\nvar a = {}; a >>> 0  //0\n\n123123 >>> 0  //123123\n\n45.2 >>> 0  //45\n\n0 >>> 0  //0\n\n-0 >>> 0  //0\n\n-1 >>> 0  //4294967295\n\n-1212 >>> 0  //4294966084\n复制代码\n\n\n总体实现起来并没那么难，需要注意的就是使用 in 来进行原型链查找。同时，如果没有找到就不处理，能有效处理稀疏数组的情况。\n\n最后给大家奉上 v8 源码，参照源码检查一下，其实还是实现得很完整了。\n\nfunction arraymap(f, receiver) {\n  check_object_coercible(this, 'array.prototype.map');\n\n  // pull out the length so that modifications to the length in the\n  // loop will not affect the looping and side effects are visible.\n  var array = to_object(this);\n  var length = to_length(array.length);\n  if (!is_callable(f))\n    throw %make_type_error(kcallednoncallable, f);\n  var result = arrayspeciescreate(array, length);\n  for (var i = 0; i < length; i++) {\n    if (i in array) {\n      var element = array[i];\n      %createdataproperty(\n        result,\n        i,\n        %_call(f, receiver, element, i, array),\n      );\n    }\n  }\n  return result;\n}\n复制代码;\n\n\n参考:\n\nv8 源码\n\narray 原型方法源码实现大揭秘\n\necma262 草案\n\n\n# 第十三篇: 能不能实现数组 reduce 方法 ?\n\n依照 ecma262 草案，实现的 reduce 的规范如下:\n\n\n\n其中有几个核心要点:\n\n1、初始值不传怎么处理\n\n2、回调函数的参数有哪些，返回值如何处理。\n\narray.prototype.reduce = function(\n  callbackfn,\n  initialvalue,\n) {\n  // 异常处理，和 map 一样\n  // 处理数组类型异常\n  if (this === null || this === undefined) {\n    throw new typeerror(\n      \"cannot read property 'reduce' of null or undefined\",\n    );\n  }\n  // 处理回调类型异常\n  if (\n    object.prototype.tostring.call(callbackfn) !=\n    '[object function]'\n  ) {\n    throw new typeerror(callbackfn + ' is not a function');\n  }\n  let o = object(this);\n  let len = o.length >>> 0;\n  let k = 0;\n  let accumulator = initialvalue;\n  if (accumulator === undefined) {\n    for (; k < len; k++) {\n      // 查找原型链\n      if (k in o) {\n        accumulator = o[k];\n        k++;\n        break;\n      }\n    }\n  }\n  // 表示数组全为空\n  if (k === len && accumulator === undefined)\n    throw new error('each element of the array is empty');\n  for (; k < len; k++) {\n    if (k in o) {\n      // 注意，核心！\n      accumulator = callbackfn.call(\n        undefined,\n        accumulator,\n        o[k],\n        k,\n        o,\n      );\n    }\n  }\n  return accumulator;\n};\n复制代码;\n\n\n其实是从最后一项开始遍历，通过原型链查找跳过空项。\n\n最后给大家奉上 v8 源码，以供大家检查:\n\nfunction arrayreduce(callback, current) {\n  check_object_coercible(this, 'array.prototype.reduce');\n\n  // pull out the length so that modifications to the length in the\n  // loop will not affect the looping and side effects are visible.\n  var array = to_object(this);\n  var length = to_length(array.length);\n  return innerarrayreduce(\n    callback,\n    current,\n    array,\n    length,\n    arguments.length,\n  );\n}\n\nfunction innerarrayreduce(\n  callback,\n  current,\n  array,\n  length,\n  argumentslength,\n) {\n  if (!is_callable(callback)) {\n    throw %make_type_error(kcallednoncallable, callback);\n  }\n\n  var i = 0;\n  find_initial: if (argumentslength < 2) {\n    for (; i < length; i++) {\n      if (i in array) {\n        current = array[i++];\n        break find_initial;\n      }\n    }\n    throw %make_type_error(kreducenoinitial);\n  }\n\n  for (; i < length; i++) {\n    if (i in array) {\n      var element = array[i];\n      current = callback(current, element, i, array);\n    }\n  }\n  return current;\n}\n复制代码;\n\n\n参考:\n\nv8 源码\n\necma262 草案\n\n\n# 第十四篇: 能不能实现数组 push、pop 方法 ?\n\n参照 ecma262 草案的规定，关于 push 和 pop 的规范如下图所示:\n\n\n\n\n\n首先来实现一下 push 方法:\n\narray.prototype.push = function(...items) {\n  let o = object(this);\n  let len = this.length >>> 0;\n  let argcount = items.length >>> 0;\n  // 2 ** 53 - 1 为js能表示的最大正整数\n  if (len + argcount > 2 ** 53 - 1) {\n    throw new typeerror(\n      'the number of array is over the max value restricted!',\n    );\n  }\n  for (let i = 0; i < argcount; i++) {\n    o[len + i] = items[i];\n  }\n  let newlength = len + argcount;\n  o.length = newlength;\n  return newlength;\n};\n复制代码;\n\n\n亲测已通过 mdn 上所有测试用例。mdn 链接\n\n然后来实现 pop 方法:\n\narray.prototype.pop = function() {\n  let o = object(this);\n  let len = this.length >>> 0;\n  if (len === 0) {\n    o.length = 0;\n    return undefined;\n  }\n  len--;\n  let value = o[len];\n  delete o[len];\n  o.length = len;\n  return value;\n};\n复制代码;\n\n\n亲测已通过 mdn 上所有测试用例。mdn 链接\n\n参考链接:\n\nv8 数组源码\n\necma262 规范草案\n\nmdn 文档\n\n\n# 第十五篇: 能不能实现数组 filter 方法 ?\n\n\n\n代码如下:\n\narray.prototype.filter = function(callbackfn, thisarg) {\n  // 处理数组类型异常\n  if (this === null || this === undefined) {\n    throw new typeerror(\n      \"cannot read property 'filter' of null or undefined\",\n    );\n  }\n  // 处理回调类型异常\n  if (\n    object.prototype.tostring.call(callbackfn) !=\n    '[object function]'\n  ) {\n    throw new typeerror(callbackfn + ' is not a function');\n  }\n  let o = object(this);\n  let len = o.length >>> 0;\n  let reslen = 0;\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    if (i in o) {\n      let element = o[i];\n      if (callbackfn.call(thisarg, o[i], i, o)) {\n        res[reslen++] = element;\n      }\n    }\n  }\n  return res;\n};\n复制代码;\n\n\nmdn 上所有测试用例亲测通过。\n\n参考:\n\nv8 数组部分源码第 1025 行\n\nmdn 中 filter 文档\n\n\n# 第十六篇: 能不能实现数组 splice 方法 ?\n\nsplice 可以说是最受欢迎的数组方法之一，api 灵活，使用方便。现在来梳理一下用法:\n\n * 1. splice(position, count) 表示从 position 索引的位置开始，删除 count 个元素\n * 1. splice(position, 0, ele1, ele2, ...) 表示从 position 索引的元素后面插入一系列的元素\n * 1. splice(postion, count, ele1, ele2, ...) 表示从 position 索引的位置开始，删除 count 个元素，然后再插入一系列的元素\n * 1. 返回值为被删除元素组成的数组。\n\n接下来我们实现这个方法。\n\n参照 ecma262 草案的规定，详情请点击。\n\n首先我们梳理一下实现的思路。\n\n\n\n\n# 初步实现\n\narray.prototype.splice = function(\n  startindex,\n  deletecount,\n  ...addelements\n) {\n  let argumentslen = arguments.length;\n  let array = object(this);\n  let len = array.length;\n  let deletearr = new array(deletecount);\n\n  // 拷贝删除的元素\n  slicedeleteelements(\n    array,\n    startindex,\n    deletecount,\n    deletearr,\n  );\n  // 移动删除元素后面的元素\n  movepostelements(\n    array,\n    startindex,\n    len,\n    deletecount,\n    addelements,\n  );\n  // 插入新元素\n  for (let i = 0; i < addelements.length; i++) {\n    array[startindex + i] = addelements[i];\n  }\n  array.length = len - deletecount + addelements.length;\n  return deletearr;\n};\n复制代码;\n\n\n先拷贝删除的元素，如下所示:\n\nconst slicedeleteelements = (\n  array,\n  startindex,\n  deletecount,\n  deletearr,\n) => {\n  for (let i = 0; i < deletecount; i++) {\n    let index = startindex + i;\n    if (index in array) {\n      let current = array[index];\n      deletearr[i] = current;\n    }\n  }\n};\n复制代码;\n\n\n然后对删除元素后面的元素进行挪动, 挪动分为三种情况:\n\n 1. 添加的元素和删除的元素个数相等\n 2. 添加的元素个数小于删除的元素\n 3. 添加的元素个数大于删除的元素\n\n当两者相等时，\n\nconst movepostelements = (\n  array,\n  startindex,\n  len,\n  deletecount,\n  addelements,\n) => {\n  if (deletecount === addelements.length) return;\n};\n复制代码;\n\n\n当添加的元素个数小于删除的元素时, 如图所示:\n\n\n\nconst movepostelements = (\n  array,\n  startindex,\n  len,\n  deletecount,\n  addelements,\n) => {\n  //...\n  // 如果添加的元素和删除的元素个数不相等，则移动后面的元素\n  if (deletecount > addelements.length) {\n    // 删除的元素比新增的元素多，那么后面的元素整体向前挪动\n    // 一共需要挪动 len - startindex - deletecount 个元素\n    for (let i = startindex + deletecount; i < len; i++) {\n      let fromindex = i;\n      // 将要挪动到的目标位置\n      let toindex = i - (deletecount - addelements.length);\n      if (fromindex in array) {\n        array[toindex] = array[fromindex];\n      } else {\n        delete array[toindex];\n      }\n    }\n    // 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素\n    // 目前长度为 len + addelements - deletecount\n    for (\n      let i = len - 1;\n      i >= len + addelements.length - deletecount;\n      i--\n    ) {\n      delete array[i];\n    }\n  }\n};\n复制代码;\n\n\n当添加的元素个数大于删除的元素时, 如图所示:\n\n\n\nconst movepostelements = (\n  array,\n  startindex,\n  len,\n  deletecount,\n  addelements,\n) => {\n  //...\n  if (deletecount < addelements.length) {\n    // 删除的元素比新增的元素少，那么后面的元素整体向后挪动\n    // 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？\n    for (\n      let i = len - 1;\n      i >= startindex + deletecount;\n      i--\n    ) {\n      let fromindex = i;\n      // 将要挪动到的目标位置\n      let toindex = i + (addelements.length - deletecount);\n      if (fromindex in array) {\n        array[toindex] = array[fromindex];\n      } else {\n        delete array[toindex];\n      }\n    }\n  }\n};\n复制代码;\n\n\n\n# 优化一: 参数的边界情况\n\n当用户传来非法的 startindex 和 deletecount 或者负索引的时候，需要我们做出特殊的处理。\n\nconst computestartindex = (startindex, len) => {\n  // 处理索引负数的情况\n  if (startindex < 0) {\n    return startindex + len > 0 ? startindex + len : 0;\n  }\n  return startindex >= len ? len : startindex;\n};\n\nconst computedeletecount = (\n  startindex,\n  len,\n  deletecount,\n  argumentslen,\n) => {\n  // 删除数目没有传，默认删除startindex及后面所有的\n  if (argumentslen === 1) return len - startindex;\n  // 删除数目过小\n  if (deletecount < 0) return 0;\n  // 删除数目过大\n  if (deletecount > len - startindex)\n    return len - startindex;\n  return deletecount;\n};\n\narray.prototype.splice = function(\n  startindex,\n  deletecount,\n  ...addelements\n) {\n  //,...\n  let deletearr = new array(deletecount);\n\n  // 下面参数的清洗工作\n  startindex = computestartindex(startindex, len);\n  deletecount = computedeletecount(\n    startindex,\n    len,\n    deletecount,\n    argumentslen,\n  );\n\n  // 拷贝删除的元素\n  slicedeleteelements(\n    array,\n    startindex,\n    deletecount,\n    deletearr,\n  );\n  //...\n};\n复制代码;\n\n\n\n# 优化二: 数组为密封对象或冻结对象\n\n什么是密封对象?\n\n> 密封对象是不可扩展的对象，而且已有成员的[[configurable]]属性被设置为 false，这意味着不能添加、删除方法和属性。但是属性值是可以修改的。\n\n什么是冻结对象？\n\n> 冻结对象是最严格的防篡改级别，除了包含密封对象的限制外，还不能修改属性值。\n\n接下来，我们来把这两种情况一一排除。\n\n// 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象\nif (\n  object.issealed(array) &&\n  deletecount !== addelements.length\n) {\n  throw new typeerror('the object is a sealed object!');\n} else if (\n  object.isfrozen(array) &&\n  (deletecount > 0 || addelements.length > 0)\n) {\n  throw new typeerror('the object is a frozen object!');\n}\n复制代码;\n\n\n好了，现在就写了一个比较完整的 splice，如下:\n\nconst slicedeleteelements = (\n  array,\n  startindex,\n  deletecount,\n  deletearr,\n) => {\n  for (let i = 0; i < deletecount; i++) {\n    let index = startindex + i;\n    if (index in array) {\n      let current = array[index];\n      deletearr[i] = current;\n    }\n  }\n};\n\nconst movepostelements = (\n  array,\n  startindex,\n  len,\n  deletecount,\n  addelements,\n) => {\n  // 如果添加的元素和删除的元素个数相等，相当于元素的替换，数组长度不变，被删除元素后面的元素不需要挪动\n  if (deletecount === addelements.length) return;\n  // 如果添加的元素和删除的元素个数不相等，则移动后面的元素\n  else if (deletecount > addelements.length) {\n    // 删除的元素比新增的元素多，那么后面的元素整体向前挪动\n    // 一共需要挪动 len - startindex - deletecount 个元素\n    for (let i = startindex + deletecount; i < len; i++) {\n      let fromindex = i;\n      // 将要挪动到的目标位置\n      let toindex = i - (deletecount - addelements.length);\n      if (fromindex in array) {\n        array[toindex] = array[fromindex];\n      } else {\n        delete array[toindex];\n      }\n    }\n    // 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素\n    // 目前长度为 len + addelements - deletecount\n    for (\n      let i = len - 1;\n      i >= len + addelements.length - deletecount;\n      i--\n    ) {\n      delete array[i];\n    }\n  } else if (deletecount < addelements.length) {\n    // 删除的元素比新增的元素少，那么后面的元素整体向后挪动\n    // 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？\n    for (\n      let i = len - 1;\n      i >= startindex + deletecount;\n      i--\n    ) {\n      let fromindex = i;\n      // 将要挪动到的目标位置\n      let toindex = i + (addelements.length - deletecount);\n      if (fromindex in array) {\n        array[toindex] = array[fromindex];\n      } else {\n        delete array[toindex];\n      }\n    }\n  }\n};\n\nconst computestartindex = (startindex, len) => {\n  // 处理索引负数的情况\n  if (startindex < 0) {\n    return startindex + len > 0 ? startindex + len : 0;\n  }\n  return startindex >= len ? len : startindex;\n};\n\nconst computedeletecount = (\n  startindex,\n  len,\n  deletecount,\n  argumentslen,\n) => {\n  // 删除数目没有传，默认删除startindex及后面所有的\n  if (argumentslen === 1) return len - startindex;\n  // 删除数目过小\n  if (deletecount < 0) return 0;\n  // 删除数目过大\n  if (deletecount > len - startindex)\n    return len - startindex;\n  return deletecount;\n};\n\narray.prototype.splice = function(\n  startindex,\n  deletecount,\n  ...addelements\n) {\n  let argumentslen = arguments.length;\n  let array = object(this);\n  let len = array.length >>> 0;\n  let deletearr = new array(deletecount);\n\n  startindex = computestartindex(startindex, len);\n  deletecount = computedeletecount(\n    startindex,\n    len,\n    deletecount,\n    argumentslen,\n  );\n\n  // 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象\n  if (\n    object.issealed(array) &&\n    deletecount !== addelements.length\n  ) {\n    throw new typeerror('the object is a sealed object!');\n  } else if (\n    object.isfrozen(array) &&\n    (deletecount > 0 || addelements.length > 0)\n  ) {\n    throw new typeerror('the object is a frozen object!');\n  }\n\n  // 拷贝删除的元素\n  slicedeleteelements(\n    array,\n    startindex,\n    deletecount,\n    deletearr,\n  );\n  // 移动删除元素后面的元素\n  movepostelements(\n    array,\n    startindex,\n    len,\n    deletecount,\n    addelements,\n  );\n\n  // 插入新元素\n  for (let i = 0; i < addelements.length; i++) {\n    array[startindex + i] = addelements[i];\n  }\n\n  array.length = len - deletecount + addelements.length;\n\n  return deletearr;\n};\n复制代码;\n\n\n以上代码对照mdn 文档中的所有测试用例亲测通过。\n\n相关测试代码请前往: 传送门\n\n最后给大家奉上 v8 源码，供大家检查： v8 数组 splice 源码第 660 行\n\n\n# 第十七篇: 能不能实现数组 sort 方法？\n\n估计大家对 js 数组的 sort 方法已经不陌生了，之前也对它的用法做了详细的总结。那，它的内部是如何来实现的呢？如果说我们能够进入它的内部去看一看， 理解背后的设计，会使我们的思维和素养得到不错的提升。\n\nsort 方法在 v8 内部相对与其他方法而言是一个比较高深的算法，对于很多边界情况做了反复的优化，但是这里我们不会直接拿源码来干讲。我们会来根据源码的思路，实现一个 跟引擎性能一样的排序算法，并且一步步拆解其中的奥秘。\n\n\n# v8 引擎的思路分析\n\n首先大概梳理一下源码中排序的思路:\n\n设要排序的元素个数是 n：\n\n * 当 n <= 10 时，采用插入排序\n\n * 当 n > 10 时，采用\n   \n   三路快速排序\n   \n   \n   * 10 < n <= 1000, 采用中位数作为哨兵元素\n   * n > 1000, 每隔 200~215 个元素挑出一个元素，放到一个新数组，然后对它排序，找到中间位置的数，以此作为中位数\n\n在动手之前，我觉得我们有必要为什么这么做搞清楚。\n\n第一、为什么元素个数少的时候要采用插入排序？\n\n虽然插入排序理论上说是 o(n^2)的算法，快速排序是一个 o(nlogn)级别的算法。但是别忘了，这只是理论上的估算，在实际情况中两者的算法复杂度前面都会有一个系数的， 当 n 足够小的时候，快速排序nlogn的优势会越来越小，倘若插入排序 o(n^2)前面的系数足够小，那么就会超过快排。而事实上正是如此，插入排序经过优化以后对于小数据集的排序会有非常优越的性能，很多时候甚至会超过快排。\n\n因此，对于很小的数据量，应用插入排序是一个非常不错的选择。\n\n第二、为什么要花这么大的力气选择哨兵元素？\n\n因为快速排序的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行 partition(一边是小于哨兵的元素，另一边是大于哨兵的元素)时，就会有一边是空的，那么这么排下去，递归的层数就达到了 n, 而每一层的复杂度是 o(n)，因此快排这时候会退化成 o(n^2)级别。\n\n这种情况是要尽力避免的！如果来避免？\n\n就是让哨兵元素进可能地处于数组的中间位置，让最大或者最小的情况尽可能少。这时候，你就能理解 v8 里面所做的种种优化了。\n\n接下来，我们来一步步实现的这样的官方排序算法。\n\n\n# 插入排序及优化\n\n最初的插入排序可能是这样写的:\n\nconst insertsort = (arr, start = 0, end) => {\n  end = end || arr.length;\n  for (let i = start; i < end; i++) {\n    let j;\n    for (j = i; j > start && arr[j - 1] > arr[j]; j--) {\n      let temp = arr[j];\n      arr[j] = arr[j - 1];\n      arr[j - 1] = temp;\n    }\n  }\n  return;\n};\n复制代码;\n\n\n看似可以正确的完成排序，但实际上交换元素会有相当大的性能消耗，我们完全可以用变量覆盖的方式来完成，如图所示:\n\n\n\n优化后代码如下:\n\nconst insertsort = (arr, start = 0, end) => {\n  end = end || arr.length;\n  for (let i = start; i < end; i++) {\n    let e = arr[i];\n    let j;\n    for (j = i; j > start && arr[j - 1] > e; j--)\n      arr[j] = arr[j - 1];\n    arr[j] = e;\n  }\n  return;\n};\n复制代码;\n\n\n接下来正式进入到 sort 方法。\n\n\n# 寻找哨兵元素\n\nsort 的骨架大致如下:\n\narray.prototype.sort = (comparefn) => {\n  let array = object(this);\n  let length = array.length >>> 0;\n  return innerarraysort(array, length, comparefn);\n};\n\nconst innerarraysort = (array, length, comparefn) => {\n  // 比较函数未传入\n  if (\n    object.prototype.tostring.call(callbackfn) !==\n    '[object function]'\n  ) {\n    comparefn = function(x, y) {\n      if (x === y) return 0;\n      x = x.tostring();\n      y = y.tostring();\n      if (x == y) return 0;\n      else return x < y ? -1 : 1;\n    };\n  }\n  const insertsort = () => {\n    //...\n  };\n  const getthirdindex = (a, from, to) => {\n    // 元素个数大于1000时寻找哨兵元素\n  };\n  const quicksort = (a, from, to) => {\n    //哨兵位置\n    let thirdindex = 0;\n    while (true) {\n      if (to - from <= 10) {\n        insertsort(a, from, to);\n        return;\n      }\n      if (to - from > 1000) {\n        thirdindex = getthirdindex(a, from, to);\n      } else {\n        // 小于1000 直接取中点\n        thirdindex = from + ((to - from) >> 2);\n      }\n    }\n    //下面开始快排\n  };\n};\n复制代码;\n\n\n我们先来把求取哨兵位置的代码实现一下:\n\nconst getthirdindex = (a, from, to) => {\n  let tmparr = [];\n  // 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的\n  let increment = 200 + ((to - from) & 15);\n  let j = 0;\n  from += 1;\n  to -= 1;\n  for (let i = from; i < to; i += increment) {\n    tmparr[j] = [i, a[i]];\n    j++;\n  }\n  // 把临时数组排序，取中间的值，确保哨兵的值接近平均位置\n  tmparr.sort(function(a, b) {\n    return comparefn(a[1], b[1]);\n  });\n  let thirdindex = tmparr[tmparr.length >> 1][0];\n  return thirdindex;\n};\n复制代码;\n\n\n\n# 完成快排\n\n接下来我们来完成快排的具体代码：\n\nconst _sort = (a, b, c) => {\n  let arr = [a, b, c];\n  insertsort(arr, 0, 3);\n  return arr;\n};\n\nconst quicksort = (a, from, to) => {\n  //...\n  // 上面我们拿到了thirdindex\n  // 现在我们拥有三个元素，from, thirdindex, to\n  // 为了再次确保 thirdindex 不是最值，把这三个值排序\n  [a[from], a[thirdindex], a[to - 1]] = _sort(\n    a[from],\n    a[thirdindex],\n    a[to - 1],\n  );\n  // 现在正式把 thirdindex 作为哨兵\n  let pivot = a[thirdindex];\n  // 正式进入快排\n  let lowend = from + 1;\n  let highstart = to - 1;\n  // 现在正式把 thirdindex 作为哨兵, 并且lowend和thirdindex交换\n  let pivot = a[thirdindex];\n  a[thirdindex] = a[lowend];\n  a[lowend] = pivot;\n\n  // [lowend, i)的元素是和pivot相等的\n  // [i, highstart) 的元素是需要处理的\n  for (let i = lowend + 1; i < highstart; i++) {\n    let element = a[i];\n    let order = comparefn(element, pivot);\n    if (order < 0) {\n      a[i] = a[lowend];\n      a[lowend] = element;\n      lowend++;\n    } else if (order > 0) {\n      do {\n        highstart--;\n        if (highstart === i) break;\n        order = comparefn(a[highstart], pivot);\n      } while (order > 0);\n      // 现在 a[highstart] <= pivot\n      // a[i] > pivot\n      // 两者交换\n      a[i] = a[highstart];\n      a[highstart] = element;\n      if (order < 0) {\n        // a[i] 和 a[lowend] 交换\n        element = a[i];\n        a[i] = a[lowend];\n        a[lowend] = element;\n        lowend++;\n      }\n    }\n  }\n  // 永远切分大区间\n  if (lowend - from > to - highstart) {\n    // 继续切分lowend ~ from 这个区间\n    to = lowend;\n    // 单独处理小区间\n    quicksort(a, highstart, to);\n  } else if (lowend - from <= to - highstart) {\n    from = highstart;\n    quicksort(a, from, lowend);\n  }\n};\n复制代码;\n\n\n\n# 测试结果\n\n测试结果如下:\n\n一万条数据:\n\n\n\n十万条数据:\n\n\n\n一百万条数据:\n\n\n\n一千万条数据:\n\n\n\n结果仅供大家参考，因为不同的 node 版本对于部分细节的实现可能不一样，我现在的版本是 v10.15。\n\n从结果可以看到，目前版本的 node 对于有序程度较高的数据是处理的不够好的，而我们刚刚实现的排序通过反复确定哨兵的位置就能 有效的规避快排在这一场景下的劣势。\n\n最后给大家完整版的 sort 代码:\n\nconst sort = (arr, comparefn) => {\n  let array = object(arr);\n  let length = array.length >>> 0;\n  return innerarraysort(array, length, comparefn);\n};\n\nconst innerarraysort = (array, length, comparefn) => {\n  // 比较函数未传入\n  if (\n    object.prototype.tostring.call(comparefn) !==\n    '[object function]'\n  ) {\n    comparefn = function(x, y) {\n      if (x === y) return 0;\n      x = x.tostring();\n      y = y.tostring();\n      if (x == y) return 0;\n      else return x < y ? -1 : 1;\n    };\n  }\n  const insertsort = (arr, start = 0, end) => {\n    end = end || arr.length;\n    for (let i = start; i < end; i++) {\n      let e = arr[i];\n      let j;\n      for (\n        j = i;\n        j > start && comparefn(arr[j - 1], e) > 0;\n        j--\n      )\n        arr[j] = arr[j - 1];\n      arr[j] = e;\n    }\n    return;\n  };\n  const getthirdindex = (a, from, to) => {\n    let tmparr = [];\n    // 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的\n    let increment = 200 + ((to - from) & 15);\n    let j = 0;\n    from += 1;\n    to -= 1;\n    for (let i = from; i < to; i += increment) {\n      tmparr[j] = [i, a[i]];\n      j++;\n    }\n    // 把临时数组排序，取中间的值，确保哨兵的值接近平均位置\n    tmparr.sort(function(a, b) {\n      return comparefn(a[1], b[1]);\n    });\n    let thirdindex = tmparr[tmparr.length >> 1][0];\n    return thirdindex;\n  };\n\n  const _sort = (a, b, c) => {\n    let arr = [];\n    arr.push(a, b, c);\n    insertsort(arr, 0, 3);\n    return arr;\n  };\n\n  const quicksort = (a, from, to) => {\n    //哨兵位置\n    let thirdindex = 0;\n    while (true) {\n      if (to - from <= 10) {\n        insertsort(a, from, to);\n        return;\n      }\n      if (to - from > 1000) {\n        thirdindex = getthirdindex(a, from, to);\n      } else {\n        // 小于1000 直接取中点\n        thirdindex = from + ((to - from) >> 2);\n      }\n      let tmparr = _sort(a[from], a[thirdindex], a[to - 1]);\n      a[from] = tmparr[0];\n      a[thirdindex] = tmparr[1];\n      a[to - 1] = tmparr[2];\n      // 现在正式把 thirdindex 作为哨兵\n      let pivot = a[thirdindex];\n      [a[from], a[thirdindex]] = [a[thirdindex], a[from]];\n      // 正式进入快排\n      let lowend = from + 1;\n      let highstart = to - 1;\n      a[thirdindex] = a[lowend];\n      a[lowend] = pivot;\n      // [lowend, i)的元素是和pivot相等的\n      // [i, highstart) 的元素是需要处理的\n      for (let i = lowend + 1; i < highstart; i++) {\n        let element = a[i];\n        let order = comparefn(element, pivot);\n        if (order < 0) {\n          a[i] = a[lowend];\n          a[lowend] = element;\n          lowend++;\n        } else if (order > 0) {\n          do {\n            highstart--;\n            if (highstart === i) break;\n            order = comparefn(a[highstart], pivot);\n          } while (order > 0);\n          // 现在 a[highstart] <= pivot\n          // a[i] > pivot\n          // 两者交换\n          a[i] = a[highstart];\n          a[highstart] = element;\n          if (order < 0) {\n            // a[i] 和 a[lowend] 交换\n            element = a[i];\n            a[i] = a[lowend];\n            a[lowend] = element;\n            lowend++;\n          }\n        }\n      }\n      // 永远切分大区间\n      if (lowend - from > to - highstart) {\n        // 单独处理小区间\n        quicksort(a, highstart, to);\n        // 继续切分lowend ~ from 这个区间\n        to = lowend;\n      } else if (lowend - from <= to - highstart) {\n        quicksort(a, from, lowend);\n        from = highstart;\n      }\n    }\n  };\n  quicksort(array, 0, length);\n};\n复制代码;\n\n\n参考链接:\n\nv8 sort 源码(点开第 997 行)\n\n冴羽排序源码专题\n\n\n# 第十八篇: 能不能模拟实现一个 new 的效果？\n\nnew被调用后做了三件事情:\n\n 1. 让实例可以访问到私有属性\n 2. 让实例可以访问构造函数原型(constructor.prototype)所在原型链上的属性\n 3. 如果构造函数返回的结果不是引用数据类型\n\nfunction newoperator(ctor, ...args) {\n    if(typeof ctor !== 'function'){\n      throw 'newoperator function the first param must be a function';\n    }\n    let obj = object.create(ctor.prototype);\n    let res = ctor.apply(obj, args);\n\n    let isobject = typeof res === 'object' && res !== null;\n    let isfunction = typoof res === 'function';\n    return isobect || isfunction ? res : obj;\n};\n复制代码\n\n\n\n# 第十九篇: 能不能模拟实现一个 bind 的效果？\n\n实现 bind 之前，我们首先要知道它做了哪些事情。\n\n 1. 对于普通函数，绑定 this 指向\n 2. 对于构造函数，要保证原函数的原型对象上的属性不能丢失\n\nfunction.prototype.bind = function(context, ...args) {\n  // 异常处理\n  if (typeof this !== 'function') {\n    throw new error(\n      'function.prototype.bind - what is trying to be bound is not callable',\n    );\n  }\n  // 保存this的值，它代表调用 bind 的函数\n  var self = this;\n  var fnop = function() {};\n\n  var fbound = function() {\n    self.apply(\n      this instanceof self ? this : context,\n      args.concat(array.prototype.slice.call(arguments)),\n    );\n  };\n\n  fnop.prototype = this.prototype;\n  fbound.prototype = new fnop();\n\n  return fbound;\n};\n复制代码;\n\n\n也可以这么用 object.create 来处理原型:\n\nfunction.prototype.bind = function(context, ...args) {\n  if (typeof this !== 'function') {\n    throw new error(\n      'function.prototype.bind - what is trying to be bound is not callable',\n    );\n  }\n\n  var self = this;\n\n  var fbound = function() {\n    self.apply(\n      this instanceof self ? this : context,\n      args.concat(array.prototype.slice.call(arguments)),\n    );\n  };\n\n  fbound.prototype = object.create(self.prototype);\n\n  return fbound;\n};\n复制代码;\n\n\n\n# 第二十篇: 能不能实现一个 call/apply 函数？\n\n引自冴羽大佬的代码，可以说比较完整了。\n\nfunction.prototype.call = function(context) {\n  let context = context || window;\n  let fn = symbol('fn');\n  context.fn = this;\n\n  let args = [];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    args.push('arguments[' + i + ']');\n  }\n\n  let result = eval('context.fn(' + args + ')');\n\n  delete context.fn;\n  return result;\n};\n复制代码;\n\n\n不过我认为换成 es6 的语法会更精炼一些:\n\nfunction.prototype.call = function(context, ...args) {\n  let context = context || window;\n  let fn = symbol('fn');\n  context.fn = this;\n\n  let result = eval('context.fn(...args)');\n\n  delete context.fn;\n  return result;\n};\n复制代码;\n\n\n类似的，有 apply 的对应实现:\n\nfunction.prototype.apply = function(context, args) {\n  let context = context || window;\n  context.fn = this;\n  let result = eval('context.fn(...args)');\n\n  delete context.fn;\n  return result;\n};\n复制代码;\n\n\n\n# 第二十一篇: 谈谈你对 js 中 this 的理解。\n\n其实 js 中的 this 是一个非常简单的东西，只需要理解它的执行规则就 ok。\n\n在这里不想像其他博客一样展示太多的代码例子弄得天花乱坠， 反而不易理解。\n\ncall/apply/bind 可以显式绑定, 这里就不说了。\n\n主要这些场隐式绑定的场景讨论:\n\n 1. 全局上下文\n 2. 直接调用函数\n 3. 对象.方法的形式调用\n 4. dom 事件绑定(特殊)\n 5. new 构造函数绑定\n 6. 箭头函数\n\n\n# 1. 全局上下文\n\n全局上下文默认 this 指向 window, 严格模式下指向 undefined。\n\n\n# 2. 直接调用函数\n\n比如:\n\nlet obj = {\n  a: function() {\n    console.log(this);\n  },\n};\nlet func = obj.a;\nfunc();\n复制代码;\n\n\n这种情况是直接调用。this 相当于全局上下文的情况。\n\n\n# 3. 对象.方法的形式调用\n\n还是刚刚的例子，我如果这样写:\n\nobj.a();\n复制代码;\n\n\n这就是对象.方法的情况，this 指向这个对象\n\n\n# 4. dom 事件绑定\n\nonclick 和 addeventerlistener 中 this 默认指向绑定事件的元素。\n\nie 比较奇异，使用 attachevent，里面的 this 默认指向 window。\n\n\n# 5. new+构造函数\n\n此时构造函数中的 this 指向实例对象。\n\n\n# 6. 箭头函数？\n\n箭头函数没有 this, 因此也不能绑定。里面的 this 会指向当前最近的非箭头函数的 this，找不到就是 window(严格模式是 undefined)。比如:\n\nlet obj = {\n  a: function() {\n    let do = () => {\n      console.log(this);\n    }\n    do();\n  }\n}\nobj.a(); // 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj\n复制代码\n\n\n> 优先级: new > call、apply、bind > 对象.方法 > 直接调用。\n\n\n# 第二十二篇: js 中浅拷贝的手段有哪些？\n\n\n# 重要: 什么是拷贝？\n\n首先来直观的感受一下什么是拷贝。\n\nlet arr = [1, 2, 3];\nlet newarr = arr;\nnewarr[0] = 100;\n\nconsole.log(arr); //[100, 2, 3]\n复制代码;\n\n\n这是直接赋值的情况，不涉及任何拷贝。当改变 newarr 的时候，由于是同一个引用，arr 指向的值也跟着改变。\n\n现在进行浅拷贝:\n\nlet arr = [1, 2, 3];\nlet newarr = arr.slice();\nnewarr[0] = 100;\n\nconsole.log(arr); //[1, 2, 3]\n复制代码;\n\n\n当修改 newarr 的时候，arr 的值并不改变。什么原因?因为这里 newarr 是 arr 浅拷贝后的结果，newarr 和 arr 现在引用的已经不是同一块空间啦！\n\n这就是浅拷贝！\n\n但是这又会带来一个潜在的问题:\n\nlet arr = [1, 2, { val: 4 }];\nlet newarr = arr.slice();\nnewarr[2].val = 1000;\n\nconsole.log(arr); //[ 1, 2, { val: 1000 } ]\n复制代码;\n\n\n咦!不是已经不是同一块空间的引用了吗？为什么改变了 newarr 改变了第二个元素的 val 值，arr 也跟着变了。\n\n这就是浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，它能 解决无限极的对象嵌套问题，实现彻底的拷贝。当然，这是我们下一篇的重点。 现在先让大家有一个基本的概念。\n\n接下来，我们来研究一下 js 中实现浅拷贝到底有多少种方式？\n\n\n# 1. 手动实现\n\nconst shallowclone = (target) => {\n  if (typeof target === 'object' && target !== null) {\n    const clonetarget = array.isarray(target) ? [] : {};\n    for (let prop in target) {\n      if (target.hasownproperty(prop)) {\n        clonetarget[prop] = target[prop];\n      }\n    }\n    return clonetarget;\n  } else {\n    return target;\n  }\n};\n复制代码;\n\n\n\n# 2. object.assign\n\n但是需要注意的是，object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。\n\nlet obj = { name: 'sy', age: 18 };\nconst obj2 = object.assign({}, obj, { name: 'sss' });\nconsole.log(obj2); //{ name: 'sss', age: 18 }\n复制代码;\n\n\n\n# 3. concat 浅拷贝数组\n\nlet arr = [1, 2, 3];\nlet newarr = arr.concat();\nnewarr[1] = 100;\nconsole.log(arr); //[ 1, 2, 3 ]\n复制代码;\n\n\n\n# 4. slice 浅拷贝\n\n开头的例子不就说的这个嘛！\n\n\n# 5. ...展开运算符\n\nlet arr = [1, 2, 3];\nlet newarr = [...arr]; //跟arr.slice()是一样的效果\n复制代码;\n\n\n\n# 第二十三篇: 能不能写一个完整的深拷贝？\n\n上一篇已经解释了什么是深拷贝，现在我们来一起实现一个完整且专业的深拷贝。\n\n\n# 1. 简易版及问题\n\njson.parse(json.stringify());\n复制代码;\n\n\n估计这个 api 能覆盖大多数的应用场景，没错，谈到深拷贝，我第一个想到的也是它。但是实际上，对于某些严格的场景来说，这个方法是有巨大的坑的。问题如下：\n\n>  1. 无法解决循环引用的问题。举个例子：\n\nconst a = { val: 2 };\na.target = a;\n复制代码;\n\n\n拷贝 a 会出现系统栈溢出，因为出现了无限递归的情况。\n\n>  1. 无法拷贝一写特殊的对象，诸如 regexp, date, set, map 等。\n\n>  1. 无法拷贝函数(划重点)。\n\n因此这个 api 先 pass 掉，我们重新写一个深拷贝，简易版如下:\n\nconst deepclone = (target) => {\n  if (typeof target === 'object' && target !== null) {\n    const clonetarget = array.isarray(target) ? [] : {};\n    for (let prop in target) {\n      if (target.hasownproperty(prop)) {\n        clonetarget[prop] = deepclone(target[prop]);\n      }\n    }\n    return clonetarget;\n  } else {\n    return target;\n  }\n};\n复制代码;\n\n\n现在，我们以刚刚发现的三个问题为导向，一步步来完善、优化我们的深拷贝代码。\n\n\n# 2. 解决循环引用\n\n现在问题如下:\n\nlet obj = { val: 100 };\nobj.target = obj;\n\ndeepclone(obj); //报错: rangeerror: maximum call stack size exceeded\n复制代码;\n\n\n这就是循环引用。我们怎么来解决这个问题呢？\n\n创建一个 map。记录下已经拷贝过的对象，如果说已经拷贝过，那直接返回它行了。\n\nconst isobject = (target) =>\n  (typeof target === 'object' ||\n    typeof target === 'function') &&\n  target !== null;\n\nconst deepclone = (target, map = new map()) => {\n  if (map.get(target)) return target;\n\n  if (isobject(target)) {\n    map.set(target, true);\n    const clonetarget = array.isarray(target) ? [] : {};\n    for (let prop in target) {\n      if (target.hasownproperty(prop)) {\n        clonetarget[prop] = deepclone(target[prop], map);\n      }\n    }\n    return clonetarget;\n  } else {\n    return target;\n  }\n};\n复制代码;\n\n\n现在来试一试：\n\nconst a = { val: 2 };\na.target = a;\nlet newa = deepclone(a);\nconsole.log(newa); //{ val: 2, target: { val: 2, target: [circular] } }\n复制代码;\n\n\n好像是没有问题了, 拷贝也完成了。但还是有一个潜在的坑, 就是 map 上的 key 和 map 构成了强引用关系，这是相当危险的。我给你解释一下与之相对的弱引用的概念你就明白了：\n\n> 在计算机程序设计中，弱引用与强引用相对，\n\n是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 --百度百科\n\n说的有一点绕，我用大白话解释一下，被弱引用的对象可以在任何时候被回收，而对于强引用来说，只要这个强引用还在，那么对象无法被回收。拿上面的例子说，map 和 a 一直是强引用的关系， 在程序结束之前，a 所占的内存空间一直不会被释放。\n\n怎么解决这个问题？\n\n很简单，让 map 的 key 和 map 构成弱引用即可。es6 给我们提供了这样的数据结构，它的名字叫weakmap，它是一种特殊的 map, 其中的键是弱引用的。其键必须是对象，而值可以是任意的。\n\n稍微改造一下即可:\n\nconst deepclone = (target, map = new weakmap()) => {\n  //...\n};\n复制代码;\n\n\n\n# 3. 拷贝特殊对象\n\n# 可继续遍历\n\n对于特殊的对象，我们使用以下方式来鉴别:\n\nobject.prototype.tostring.call(obj);\n复制代码;\n\n\n梳理一下对于可遍历对象会有什么结果：\n\n['object map']['object set']['object array'][\n  'object object'\n]['object arguments'];\n复制代码;\n\n\n好，以这些不同的字符串为依据，我们就可以成功地鉴别这些对象。\n\nconst gettype = object.prototype.tostring.call(obj);\n\nconst cantraverse = {\n  '[object map]': true,\n  '[object set]': true,\n  '[object array]': true,\n  '[object object]': true,\n  '[object arguments]': true,\n};\n\nconst deepclone = (target, map = new map()) => {\n  if (!isobject(target)) return target;\n  let type = gettype(target);\n  let clonetarget;\n  if (!cantraverse[type]) {\n    // 处理不能遍历的对象\n    return;\n  } else {\n    // 这波操作相当关键，可以保证对象的原型不丢失！\n    let ctor = target.prototype;\n    clonetarget = new ctor();\n  }\n\n  if (map.get(target)) return target;\n  map.put(target, true);\n\n  if (type === maptag) {\n    //处理map\n    target.foreach((item, key) => {\n      clonetarget.set(deepclone(key), deepclone(item));\n    });\n  }\n\n  if (type === settag) {\n    //处理set\n    target.foreach((item) => {\n      target.add(deepclone(item));\n    });\n  }\n\n  // 处理数组和对象\n  for (let prop in target) {\n    if (target.hasownproperty(prop)) {\n      clonetarget[prop] = deepclone(target[prop]);\n    }\n  }\n  return clonetarget;\n};\n复制代码;\n\n\n# 不可遍历的对象\n\nconst booltag = '[object boolean]';\nconst numbertag = '[object number]';\nconst stringtag = '[object string]';\nconst datetag = '[object date]';\nconst errortag = '[object error]';\nconst regexptag = '[object regexp]';\nconst functag = '[object function]';\n复制代码;\n\n\n对于不可遍历的对象，不同的对象有不同的处理。\n\nconst handleregexp = (target) => {\n  const { source, flags } = target;\n  return new target.constructor(source, flags);\n};\n\nconst handlefunc = (target) => {\n  // 待会的重点部分\n};\n\nconst handlenottraverse = (target, tag) => {\n  const ctor = targe.constructor;\n  switch (tag) {\n    case booltag:\n    case numbertag:\n    case stringtag:\n    case errortag:\n    case datetag:\n      return new ctor(target);\n    case regexptag:\n      return handleregexp(target);\n    case functag:\n      return handlefunc(target);\n    default:\n      return new ctor(target);\n  }\n};\n复制代码;\n\n\n\n# 4. 拷贝函数\n\n虽然函数也是对象，但是它过于特殊，我们单独把它拿出来拆解。\n\n提到函数，在 js 种有两种函数，一种是普通函数，另一种是箭头函数。每个普通函数都是 function 的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用。那我们只需要 处理普通函数的情况，箭头函数直接返回它本身就好了。\n\n那么如何来区分两者呢？\n\n答案是: 利用原型。箭头函数是不存在原型的。\n\n代码如下:\n\nconst handlefunc = (func) => {\n  // 箭头函数直接返回自身\n  if (!func.prototype) return func;\n  const bodyreg = /(?<={)(.|\\n)+(?=})/m;\n  const paramreg = /(?<=\\().+(?=\\)\\s+{)/;\n  const funcstring = func.tostring();\n  // 分别匹配 函数参数 和 函数体\n  const param = paramreg.exec(funcstring);\n  const body = bodyreg.exec(funcstring);\n  if (!body) return null;\n  if (param) {\n    const paramarr = param[0].split(',');\n    return new function(...paramarr, body[0]);\n  } else {\n    return new function(body[0]);\n  }\n};\n复制代码;\n\n\n到现在，我们的深拷贝就实现地比较完善了。不过在测试的过程中，我也发现了一个小小的 bug。\n\n\n# 5. 小小的 bug\n\n如下所示:\n\nconst target = new boolean(false);\nconst ctor = target.constructor;\nnew ctor(target); // 结果为 boolean {true} 而不是 false。\n复制代码;\n\n\n对于这样一个 bug，我们可以对 boolean 拷贝做最简单的修改， 调用 valueof: new target.constructor(target.valueof())。\n\n但实际上，这种写法是不推荐的。因为在 es6 后不推荐使用【new 基本类型()】这 样的语法，所以 es6 中的新类型 symbol 是不能直接 new 的，只能通过 new object(symbeltype)。\n\n因此我们接下来统一一下:\n\nconst handlenottraverse = (target, tag) => {\n  const ctor = targe.constructor;\n  switch (tag) {\n    case booltag:\n      return new object(\n        boolean.prototype.valueof.call(target),\n      );\n    case numbertag:\n      return new object(\n        number.prototype.valueof.call(target),\n      );\n    case stringtag:\n      return new object(\n        string.prototype.valueof.call(target),\n      );\n    case errortag:\n    case datetag:\n      return new ctor(target);\n    case regexptag:\n      return handleregexp(target);\n    case functag:\n      return handlefunc(target);\n    default:\n      return new ctor(target);\n  }\n};\n复制代码;\n\n\n\n# 6. 完整代码展示\n\nok!是时候给大家放出完整版的深拷贝啦:\n\nconst gettype = (obj) =>\n  object.prototype.tostring.call(obj);\n\nconst isobject = (target) =>\n  (typeof target === 'object' ||\n    typeof target === 'function') &&\n  target !== null;\n\nconst cantraverse = {\n  '[object map]': true,\n  '[object set]': true,\n  '[object array]': true,\n  '[object object]': true,\n  '[object arguments]': true,\n};\nconst maptag = '[object map]';\nconst settag = '[object set]';\nconst booltag = '[object boolean]';\nconst numbertag = '[object number]';\nconst stringtag = '[object string]';\nconst symboltag = '[object symbol]';\nconst datetag = '[object date]';\nconst errortag = '[object error]';\nconst regexptag = '[object regexp]';\nconst functag = '[object function]';\n\nconst handleregexp = (target) => {\n  const { source, flags } = target;\n  return new target.constructor(source, flags);\n};\n\nconst handlefunc = (func) => {\n  // 箭头函数直接返回自身\n  if (!func.prototype) return func;\n  const bodyreg = /(?<={)(.|\\n)+(?=})/m;\n  const paramreg = /(?<=\\().+(?=\\)\\s+{)/;\n  const funcstring = func.tostring();\n  // 分别匹配 函数参数 和 函数体\n  const param = paramreg.exec(funcstring);\n  const body = bodyreg.exec(funcstring);\n  if (!body) return null;\n  if (param) {\n    const paramarr = param[0].split(',');\n    return new function(...paramarr, body[0]);\n  } else {\n    return new function(body[0]);\n  }\n};\n\nconst handlenottraverse = (target, tag) => {\n  const ctor = target.constructor;\n  switch (tag) {\n    case booltag:\n      return new object(\n        boolean.prototype.valueof.call(target),\n      );\n    case numbertag:\n      return new object(\n        number.prototype.valueof.call(target),\n      );\n    case stringtag:\n      return new object(\n        string.prototype.valueof.call(target),\n      );\n    case symboltag:\n      return new object(\n        symbol.prototype.valueof.call(target),\n      );\n    case errortag:\n    case datetag:\n      return new ctor(target);\n    case regexptag:\n      return handleregexp(target);\n    case functag:\n      return handlefunc(target);\n    default:\n      return new ctor(target);\n  }\n};\n\nconst deepclone = (target, map = new weakmap()) => {\n  if (!isobject(target)) return target;\n  let type = gettype(target);\n  let clonetarget;\n  if (!cantraverse[type]) {\n    // 处理不能遍历的对象\n    return handlenottraverse(target, type);\n  } else {\n    // 这波操作相当关键，可以保证对象的原型不丢失！\n    let ctor = target.constructor;\n    clonetarget = new ctor();\n  }\n\n  if (map.get(target)) return target;\n  map.set(target, true);\n\n  if (type === maptag) {\n    //处理map\n    target.foreach((item, key) => {\n      clonetarget.set(\n        deepclone(key, map),\n        deepclone(item, map),\n      );\n    });\n  }\n\n  if (type === settag) {\n    //处理set\n    target.foreach((item) => {\n      clonetarget.add(deepclone(item, map));\n    });\n  }\n\n  // 处理数组和对象\n  for (let prop in target) {\n    if (target.hasownproperty(prop)) {\n      clonetarget[prop] = deepclone(target[prop], map);\n    }\n  }\n  return clonetarget;\n};\n\n\n\n# 第 24 篇: javascript 内存机制之问——数据是如何存储的？\n\n网上的资料基本是这样说的: 基本数据类型用栈存储，引用数据类型用堆存储。\n\n看起来没有错误，但实际上是有问题的。可以考虑一下闭包的情况，如果变量存在栈中，那函数调用完栈顶空间销毁，闭包变量不就没了吗？\n\n其实还是需要补充一句:\n\n> 闭包变量是存在堆内存中的。\n\n具体而言，以下数据类型存储在栈中:\n\n * boolean\n * null\n * undefined\n * number\n * string\n * symbol\n * bigint\n\n而所有的对象数据类型存放在堆中。\n\n值得注意的是，对于赋值操作，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。\n\n因此会有下面的情况:\n\nlet obj = { a: 1 };\nlet newobj = obj;\nnewobj.a = 2;\nconsole.log(obj.a); //变成了2\n复制代码;\n\n\n之所以会这样，是因为 obj 和 newobj 是同一份堆空间的地址，改变 newobj，等于改变了共同的堆内存，这时候通过 obj 来获取这块内存的值当然会改变。\n\n当然，你可能会问: 为什么不全部用栈来保存呢？\n\n首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:\n\nfunction f(a) {\n  console.log(a);\n}\n\nfunction func(a) {\n  f(a);\n}\n\nfunc(1);\n复制代码;\n\n\n假设用 esp 指针来保存当前的执行状态，在系统栈中会产生如下的过程：\n\n 1. 调用 func, 将 func 函数的上下文压栈，esp 指向栈顶。\n 2. 执行 func，又调用 f 函数，将 f 函数的上下文压栈，esp 指针上移。\n 3. 执行完 f 函数，将 esp 下移，f 函数对应的栈顶空间被回收。\n 4. 执行完 func，esp 下移，func 对应的空间被回收。\n\n图示如下:\n\n\n\n因此你也看到了，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大！\n\n不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销，下一篇就来分析一下堆内存到底是如何进行垃圾回收并进行优化的。\n\n\n# 第 25 篇：v8 引擎如何进行垃圾内存的回收？\n\njs 语言不像 c/c++, 让程序员自己去开辟或者释放内存，而是类似 java，采用自己的一套垃圾回收算法进行自动的内存管理。作为一名资深的前端工程师，对于 js 内存回收的机制是需要非常清楚, 以便于在极端的环境下能够分析出系统性能的瓶颈，另一方面，学习这其中的机制，也对我们深入理解 js 的闭包特性、以及对内存的高效使用，都有很大的帮助。\n\n\n# v8 内存限制\n\n在其他的后端语言中，如 java/go, 对于内存的使用没有什么限制，但是 js 不一样，v8 只能使用系统的一部分内存，具体来说，在64位系统下，v8 最多只能分配1.4g, 在 32 位系统中，最多只能分配0.7g。你想想在前端这样的大内存需求其实并不大，但对于后端而言，nodejs 如果遇到一个 2g 多的文件，那么将无法全部将其读入内存进行各种操作了。\n\n我们知道对于栈内存而言，当 esp 指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析堆内存的垃圾回收。\n\n上一篇我们提到过了，所有的对象类型的数据在 js 中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断的这样创建对象，让 v8 为它分配空间，直到堆的大小达到上限。\n\n那么问题来了，v8 为什么要给它设置内存上限？明明我的机器大几十 g 的内存，只能让我用这么一点？\n\n究其根本，是由两个因素所共同决定的，一个是 js 单线程的执行机制，另一个是 js 垃圾回收机制的限制。\n\n首先 js 是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，v8 官方是这样形容的:\n\n> 以 1.5gb 的垃圾回收堆内存为例，v8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上。\n\n可见其耗时之久，而且在这么长的时间内，我们的 js 代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，v8 做了一个简单粗暴的选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个 g 内存这样的场景的。\n\n不过，如果你想调整这个内存的限制也不是不行。配置命令如下:\n\n// 这是调整老生代这部分的内存，单位是mb。后面会详细介绍新生代和老生代内存\nnode --max-old-space-size=2048 xxx.js\n复制代码\n\n\n或者\n\n// 这是调整新生代这部分的内存，单位是 kb。\nnode --max-new-space-size=2048 xxx.js\n复制代码\n\n\n\n# 新生代内存的回收\n\nv8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。v8 的堆内存，也就是两个内存之和。\n\n\n\n根据这两种不同种类的堆内存，v8 采用了不同的回收策略，来根据不同的场景做针对性的优化。\n\n首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32mb 和 16mb。够小吧，不过也很好理解，新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。\n\n那好了，新生代的垃圾回收是怎么做的呢？\n\n首先将新生代内存空间一分为二:\n\n\n\n其中 from 部分表示正在使用的内存，to 是目前闲置的内存。\n\n当进行垃圾回收时，v8 将 from 部分的对象检查一遍，如果是存活对象那么复制到 to 内存中(在 to 内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。\n\n当所有的 from 中的存活对象按照顺序进入到 to 内存之后，from 和 to 两者的角色对调，from 现在被闲置，to 为正在使用，如此循环。\n\n那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？\n\n注意，我刚刚特别说明了，在 to 内存中按照顺序从头放置的，这是为了应对这样的场景:\n\n\n\n深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做内存碎片。刚刚介绍的新生代垃圾回收算法也叫scavenge 算法。\n\nscavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，to 空间变成了这个样子:\n\n\n\n是不是整齐了许多？这样就大大方便了后续连续空间的分配。\n\n不过 scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。\n\n\n# 老生代内存的回收\n\n刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。\n\n发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:\n\n * 已经经历过一次 scavenge 回收。\n * to（闲置）空间的内存占用超过 25%。\n\n现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用scavenge算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是劳民伤财？\n\n那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？\n\n第一步，进行标记-清除。这个过程在《javascript 高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。\n\n当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？\n\n第二步，整理内存碎片。v8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。\n\n\n\n由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。\n\n\n# 增量标记\n\n由于 js 的单线程机制，v8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，v8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就\"歇\"一下，就 js 应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟 react fiber 的思路有点像，这里就不展开了。\n\n经过增量标记之后，垃圾回收过程对 js 应用的阻塞时间减少到原来了 1 / 6, 可以看到，这是一个非常成功的改进。\n\njs 垃圾回收的原理就介绍到这里了，其实理解起来是非常简单的，重要的是理解它为什么要这么做，而不仅仅是如何做的，希望这篇总结能够对你有所启发。\n\n\n# 第 26 篇: 描述一下 v8 执行一段 js 代码的过程？\n\n前端相对来说是一个比较新兴的领域，因此各种前端框架和工具层出不穷，让人眼花缭乱，尤其是各大厂商推出小程序之后各自制定标准，让前端开发的工作更加繁琐，在此背景下为了抹平平台之间的差异，诞生的各种编译工具/框架也数不胜数。但无论如何，想要赶上这些框架和工具的更新速度是非常难的，即使赶上了也很难产生自己的技术积淀，一个更好的方式便是学习那些本质的知识，抓住上层应用中不变的底层机制，这样我们便能轻松理解上层的框架而不仅仅是被动地使用，甚至能够在适当的场景下自己造出轮子，以满足开发效率的需求。\n\n站在 v8 的角度，理解其中的执行机制，也能够帮助我们理解很多的上层应用，包括 babel、eslint、前端框架的底层机制。那么，一段 javascript 代码放在 v8 当中究竟是如何执行的呢？\n\n首先需要明白的是，机器是读不懂 js 代码，机器只能理解特定的机器码，那如果要让 js 的逻辑在机器上运行起来，就必须将 js 的代码翻译成机器码，然后让机器识别。js 属于解释型语言，对于解释型的语言说，解释器会对源代码做如下分析:\n\n * 通过词法分析和语法分析生成 ast(抽象语法树)\n * 生成字节码\n\n然后解释器根据字节码来执行程序。但 js 整个执行的过程其实会比这个更加复杂，接下来就来一一地拆解。\n\n\n# 1.生成 ast\n\n生成 ast 分为两步——词法分析和语法分析。\n\n词法分析即分词，它的工作就是将一行行的代码分解成一个个 token。 比如下面一行代码:\n\nlet name = 'sanyuan';\n复制代码;\n\n\n其中会把句子分解成四个部分:\n\n\n\n即解析成了四个 token，这就是词法分析的作用。\n\n接下来语法分析阶段，将生成的这些 token 数据，根据一定的语法规则转化为 ast。举个例子:\n\nlet name = 'sanyuan';\nconsole.log(name);\n复制代码;\n\n\n最后生成的 ast 是这样的:\n\n\n\n当生成了 ast 之后，编译器/解释器后续的工作都要依靠 ast 而不是源代码。顺便补充一句，babel 的工作原理就是将 es6 的代码解析生成es6的ast，然后将 es6 的 ast 转换为 es5 的ast,最后才将 es5 的 ast 转化为具体的 es5 代码。由于本文着重阐述原理，关于 babel 编译的细节就不展开了，推荐大家去读一读荒山的babel 文章, 帮你打开新世界的大门: )\n\n回到 v8 本身，生成 ast 后，接下来会生成执行上下文，关于执行上下文，可以参考上上篇《javascript 内存机制之问——数据是如何存储的？》中对于上下文压栈出栈过程的讲解。\n\n\n# 2. 生成字节码\n\n开头就已经提到过了，生成 ast 之后，直接通过 v8 的解释器(也叫 ignition)来生成字节码。但是字节码并不能让机器直接运行，那你可能就会说了，不能执行还转成字节码干嘛，直接把 ast 转换成机器码不就得了，让机器直接执行。确实，在 v8 的早期是这么做的，但后来因为机器码的体积太大，引发了严重的内存占用问题。\n\n给一张对比图让大家直观地感受以下三者代码量的差异:\n\n\n\n很容易得出，字节码是比机器码轻量得多的代码。那 v8 为什么要使用字节码，字节码到底是个什么东西？\n\n> 字节码是介于 ast 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。\n\n字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。\n\n\n# 3. 执行代码\n\n接下来，就进入到字节码解释执行的阶段啦！\n\n在执行字节码的过程中，如果发现某一部分代码重复出现，那么 v8 将它记做热点代码(hotspot)，然后将这么代码编译成机器码保存起来，这个用来编译的工具就是 v8 的编译器(也叫做turbofan) , 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为热点代码，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。\n\n其实当你听到有人说 js 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 js 并不是完全的解释型语言。而编译器和解释器的 根本区别在于前者会编译生成二进制文件但后者不会。\n\n并且，这种字节码跟编译器和解释器结合的技术，我们称之为即时编译, 也就是我们经常听到的jit。\n\n这就是 v8 中执行一段 js 代码的整个过程，梳理一下:\n\n 1. 首先通过词法分析和语法分析生成 ast\n 2. 将 ast 转换为字节码\n 3. 由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率\n\n关于这个问题的拆解就到这里，希望对你有所启发。\n\n\n# 第 28 篇：如何理解 eventloop——宏任务和微任务篇\n\n\n# 宏任务(macrotask)引入\n\n在 js 中，大部分的任务都是在主线程上执行，常见的任务有:\n\n 1. 渲染事件\n 2. 用户交互事件\n 3. js 脚本执行\n 4. 网络请求、文件读写完成事件等等。\n\n为了让这些事件有条不紊地进行，js 引擎需要对之执行的顺序做一定的安排，v8 其实采用的是一种队列的方式来存储这些任务， 即先进来的先执行。模拟如下:\n\nbool keep_running = true;\nvoid maintherad(){\n  for(;;){\n    //执行队列中的任务\n    task task = task_queue.taketask();\n    processtask(task);\n\n    //执行延迟队列中的任务\n    processdelaytask()\n\n    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环\n        break;\n  }\n}\n复制代码\n\n\n这里用到了一个 for 循环，将队列中的任务一一取出，然后执行，这个很好理解。但是其中包含了两种任务队列，除了上述提到的任务队列， 还有一个延迟队列，它专门处理诸如 settimeout/setinterval 这样的定时器回调任务。\n\n上述提到的，普通任务队列和延迟队列中的任务，都属于宏任务。\n\n\n# 微任务(microtask)引入\n\n对于每个宏任务而言，其内部都有一个微任务队列。那为什么要引入微任务？微任务在什么时候执行呢？\n\n其实引入微任务的初衷是为了解决异步回调的问题。想一想，对于异步回调的处理，有多少种方式？总结起来有两点:\n\n 1. 将异步回调进行宏任务队列的入队操作。\n 2. 将异步回调放到当前宏任务的末尾。\n\n如果采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。\n\n为了规避这样的问题，v8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。\n\n常见的微任务有 mutationobserver、promise.then(或.reject) 以及以 promise 为基础开发的其他技术(比如 fetch api), 还包括 v8 的垃圾回收过程。\n\nok, 这便是宏任务和微任务的概念，接下来正式介绍 js 非常重要的运行机制——eventloop。\n\n\n# 第 29 篇: 如何理解 eventloop——浏览器篇\n\n干讲理论不容易理解，让我们直接以一个例子开始吧:\n\nconsole.log('start');\nsettimeout(() => {\n  console.log('timeout');\n});\npromise.resolve().then(() => {\n  console.log('resolve');\n});\nconsole.log('end');\n复制代码;\n\n\n我们来分析一下:\n\n 1. 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈(关于执行栈，若不了解请移步之前的文章《javascript 内存机制之问——数据是如何存储的？》)进行执行，因此先打印 start 和 end\n 2. settimeout 作为一个宏任务放入宏任务队列\n 3. promise.then 作为一个为微任务放入到微任务队列\n 4. 当本次宏任务执行完，检查微任务队列，发现一个 promise.then, 执行\n 5. 接下来进入到下一个宏任务——settimeout, 执行\n\n因此最后的顺序是:\n\nstart\nend\nresolve\ntimeout\n复制代码\n\n\n这样就带大家直观地感受到了浏览器环境下 eventloop 的执行流程。不过，这只是其中的一部分情况，接下来我们来做一个更完整的总结。\n\n 1. 一开始整段脚本作为第一个宏任务执行\n 2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列\n 3. 当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空\n 4. 执行浏览器 ui 线程的渲染工作\n 5. 检查是否有 web worker 任务，有则执行\n 6. 执行队首新的宏任务，回到 2，依此循环，直到宏任务和微任务队列都为空\n\n最后给大家留一道题目练习:\n\npromise.resolve().then(() => {\n  console.log('promise1');\n  settimeout(() => {\n    console.log('settimeout2');\n  }, 0);\n});\nsettimeout(() => {\n  console.log('settimeout1');\n  promise.resolve().then(() => {\n    console.log('promise2');\n  });\n}, 0);\nconsole.log('start');\n\n// start\n// promise1\n// settimeout1\n// promise2\n// settimeout2\n复制代码;\n\n\n\n# 第 30 篇: 如何理解 eventloop——nodejs 篇\n\nnodejs 和 浏览器的 eventloop 还是有很大差别的，值得单独拿出来说一说。\n\n不知你是否看过关于 nodejs 中 eventloop 的一些文章, 是否被这些流程图搞得眼花缭乱、一头雾水:\n\n\n\n看到这你不用紧张，这里会抛开这些晦涩的流程图，以最清晰浅显的方式来一步步拆解 nodejs 的事件循环机制。\n\n\n# 1. 三大关键阶段\n\n首先，梳理一下 nodejs 三个非常重要的执行阶段:\n\n 1. 执行 定时器回调 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是 settimeout、setinterval。这个阶段暂且叫它timer。\n 2. 轮询(英文叫poll)阶段。因为在 node 代码中难免会有异步操作，比如文件 i/o，网络 i/o 等等，那么当这些异步操作做完了，就会来通知 js 主线程，怎么通知呢？就是通过'data'、\n\n'connect'等事件使得事件循环到达 poll 阶段。到达了这个阶段后:\n\n如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventloop 将回到 timer 阶段。\n\n如果没有定时器, 会去看回调函数队列。\n\n * 如果队列不为空，拿出队列中的方法依次执行\n\n * 如果队列\n   \n   为空\n   \n   \n   ，检查是否有\n   \n   setimmdiate\n   \n   \n   的回调\n   \n   * 有则前往check阶段(下面会说)\n   * 没有则继续等待，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段。\n\n 1. check 阶段。这是一个比较简单的阶段，直接执行 setimmdiate 的回调。\n\n这三个阶段为一个循环过程。不过现在的 eventloop 并不完整，我们现在就来一一地完善。\n\n\n# 2. 完善\n\n首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 i/o异常的回调阶段。比如说 tcp 连接遇到 econnrefused，就会在这个时候执行回调。\n\n并且在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()， 'close' 事件的回调就会在这个阶段执行。\n\n梳理一下，nodejs 的 eventloop 分为下面的几个阶段:\n\n 1. timer 阶段\n 2. i/o 异常回调阶段\n 3. 空闲、预备状态(第 2 阶段结束，poll 未触发之前)\n 4. poll 阶段\n 5. check 阶段\n 6. 关闭事件的回调阶段\n\n是不是清晰了许多？\n\n\n# 3. 实例演示\n\n好，我们以上次的练习题来实践一把:\n\nsettimeout(() => {\n  console.log('timer1');\n  promise.resolve().then(function() {\n    console.log('promise1');\n  });\n}, 0);\nsettimeout(() => {\n  console.log('timer2');\n  promise.resolve().then(function() {\n    console.log('promise2');\n  });\n}, 0);\n复制代码;\n\n\n这里我要说，node 版本 >= 11 和在 11 以下的会有不同的表现。\n\n首先说 node 版本 >= 11 的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。\n\ntimer1\npromise1\ntime2\npromise2\n复制代码\n\n\n而 node 版本小于 11 的情况下，对于定时器的处理是:\n\n> 若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务。\n\n因此会打印出这样的结果:\n\ntimer1\ntimer2\npromise1\npromise2\n复制代码\n\n\n\n# 4.nodejs 和 浏览器关于 eventloop 的主要区别\n\n两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段之间执行的。\n\n\n# 5.关于 process.nexttick 的一点说明\n\nprocess.nexttick 是一个独立于 eventloop 的任务队列。\n\n在每一个 eventloop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。\n\n\n# 第 31 篇: nodejs 中的异步、非阻塞 i/o 是如何实现的？\n\n在听到 nodejs 相关的特性时，经常会对 异步i/o、非阻塞i/o有所耳闻，听起来好像是差不多的意思，但其实是两码事，下面我们就以原理的角度来剖析一下对 nodejs 来说，这两种技术底层是如何实现的？\n\n\n# 什么是 i/o？\n\n首先，我想有必要把 i/o 的概念解释一下。i/o 即 input/output, 输入和输出的意思。在浏览器端，只有一种 i/o，那就是利用 ajax 发送网络请求，然后读取返回的内容，这属于网络i/o。回到 nodejs 中，其实这种的 i/o 的场景就更加广泛了，主要分为两种:\n\n * 文件 i/o。比如用 fs 模块对文件进行读写操作。\n * 网络 i/o。比如 http 模块发起网络请求。\n\n\n# 阻塞和非阻塞 i/o\n\n阻塞和非阻塞 i/o 其实是针对操作系统内核而言的，而不是 nodejs 本身。阻塞 i/o 的特点就是一定要等到操作系统完成所有操作后才表示调用结束，而非阻塞 i/o 是调用后立马返回，不用等操作系统内核完成操作。\n\n对前者而言，在操作系统进行 i/o 的操作的过程中，我们的应用程序其实是一直处于等待状态的，什么都做不了。那如果换成非阻塞i/o，调用返回后我们的 nodejs 应用程序可以完成其他的事情，而操作系统同时也在进行 i/o。这样就把等待的时间充分利用了起来，提高了执行效率，但是同时又会产生一个问题，nodejs 应用程序怎么知道操作系统已经完成了 i/o 操作呢？\n\n为了让 nodejs 知道操作系统已经做完 i/o 操作，需要重复地去操作系统那里判断一下是否完成，这种重复判断的方式就是轮询。对于轮询而言，有以下这么几种方案:\n\n 1. 一直轮询检查 i/o 状态，直到 i/o 完成。这是最原始的方式，也是性能最低的，会让 cpu 一直耗用在等待上面。其实跟阻塞 i/o 的效果是一样的。\n 2. 遍历文件描述符(即 文件 i/o 时操作系统和 nodejs 之间的文件凭证)的方式来确定 i/o 是否完成，i/o 完成则文件描述符的状态改变。但 cpu 轮询消耗还是很大。\n 3. epoll 模式。即在进入轮询的时候如果 i/o 未完成 cpu 就休眠，完成之后唤醒 cpu。\n\n总之，cpu 要么重复检查 i/o，要么重复检查文件描述符，要么休眠，都得不到很好的利用，我们希望的是:\n\n> nodejs 应用程序发起 i/o 调用后可以直接去执行别的逻辑，操作系统默默地做完 i/o 之后给 nodejs 发一个完成信号，nodejs 执行回调操作。\n\n这是理想的情况，也是异步 i/o 的效果，那如何实现这样的效果呢？\n\n\n# 异步 i/o 的本质\n\nlinux 原生存在这样的一种方式，即(aio), 但两个致命的缺陷:\n\n 1. 只有 linux 下存在，在其他系统中没有异步 i/o 支持。\n 2. 无法利用系统缓存。\n\n# nodejs 中的异步 i/o 方案\n\n是不是没有办法了呢？在单线程的情况下确实是这样，但是如果把思路放开一点，利用多线程来考虑这个问题，就变得轻松多了。我们可以让一个进程进行计算操作，另外一些进行 i/o 调用，i/o 完成后把信号传给计算的线程，进而执行回调，这不就好了吗？没错，异步 i/o 就是使用这样的线程池来实现的。\n\n只不过在不同的系统下面表现会有所差异，在 linux 下可以直接使用线程池来完成，在 window 系统下则采用 iocp 这个系统 api(其内部还是用线程池完成的)。\n\n有了操作系统的支持，那 nodejs 如何来对接这些操作系统从而实现异步 i/o 呢？\n\n以文件为 i/o 我们以一段代码为例:\n\nlet fs = require('fs');\n\nfs.readfile('/test.txt', function(err, data) {\n  console.log(data);\n});\n复制代码;\n\n\n# 执行流程\n\n执行代码的过程中大概发生了这些事情:\n\n 1. 首先，fs.readfile 调用 node 的核心模块 fs.js ；\n 2. 接下来，node 的核心模块调用内建模块 node_file.cc，创建对应的文件 i/o 观察者对象(这个对象后面有大用！) ；\n 3. 最后，根据不同平台（linux 或者 window），内建模块通过 libuv 中间层进行系统调用\n\n\n\n# libuv 调用过程拆解\n\n重点来了！libuv 中是如何来进行进行系统调用的呢？也就是 uv_fs_open() 中做了些什么？\n\n# 1. 创建请求对象\n\n以 windows 系统为例来说，在这个函数的调用过程中，我们创建了一个文件 i/o 的请求对象，并往里面注入了回调函数。\n\nreq_wrap->object_->set(oncomplete_sym, callback);\n复制代码\n\n\nreqwrap 便是这个请求对象，req_wrap 中 object 的 oncomplete_sym 属性对应的值便是我们 nodejs 应用程序代码中传入的回调函数。\n\n# 2. 推入线程池，调用返回\n\n在这个对象包装完成后，queueuserworkitem() 方法将这个对象推进线程池中等待执行。\n\n好，至此现在 js 的调用就直接返回了，我们的 js 应用程序代码可以继续往下执行，当然，当前的 i/o 操作同时也在线程池中将被执行，这不就完成了异步么：）\n\n等等，别高兴太早，回调都还没执行呢！接下来便是执行回调通知的环节。\n\n# 3. 回调通知\n\n事实上现在线程池中的 i/o 无论是阻塞还是非阻塞都已经无所谓了，因为异步的目的已经达成。重要的是 i/o 完成后会发生什么。\n\n在介绍后续的故事之前，给大家介绍两个重要的方法: getqueuedcompletionstatus 和 postqueuedcompletionstatus。\n\n 1. 还记得之前讲过的 eventloop 吗？在每一个 tick 当中会调用getqueuedcompletionstatus检查线程池中是否有执行完的请求，如果有则表示时机已经成熟，可以执行回调了。\n 2. postqueuedcompletionstatus方法则是向 iocp 提交状态，告诉它当前 i/o 完成了。\n\n名字比较长，先介绍是为了让大家混个脸熟，至少后面出来不会感到太突兀：）\n\n我们言归正传，把后面的过程串联起来。\n\n当对应线程中的 i/o 完成后，会将获得的结果存储起来，保存到相应的请求对象中，然后调用postqueuedcompletionstatus()向 iocp 提交执行完成的状态，并且将线程还给操作系统。一旦 eventloop 的轮询操作中，调用getqueuedcompletionstatus检测到了完成的状态，就会把请求对象塞给 i/o 观察者(之前埋下伏笔，如今终于闪亮登场)。\n\ni/o 观察者现在的行为就是取出请求对象的存储结果，同时也取出它的oncomplete_sym属性，即回调函数(不懂这个属性的回看第 1 步的操作)。将前者作为函数参数传入后者，并执行后者。 这里，回调函数就成功执行啦！\n\n总结 :\n\n 1. 阻塞和非阻塞 i/o 其实是针对操作系统内核而言的。阻塞 i/o 的特点就是一定要等到操作系统完成所有操作后才表示调用结束，而非阻塞 i/o 是调用后立马返回，不用等操作系统内核完成操作。\n 2. nodejs 中的异步 i/o 采用多线程的方式，由 eventloop、i/o 观察者，请求对象、线程池四大要素相互配合，共同实现。\n\n\n# 第 32 篇：js 异步编程有哪些方案？为什么会出现这些方案？\n\n关于 js 单线程、eventloop 以及异步 i/o 这些底层的特性，我们之前做过了详细的拆解，不在赘述。在探究了底层机制之后，我们还需要对代码的组织方式有所理解，这是离我们最日常开发最接近的部分，异步代码的组织方式直接决定了开发和维护的效率，其重要性也不可小觑。尽管底层机制没变，但异步代码的组织方式却随着 es 标准的发展，一步步发生了巨大的变革。接着让我们来一探究竟吧！\n\n\n# 回调函数时代\n\n相信很多 nodejs 的初学者都或多或少踩过这样的坑，node 中很多原生的 api 就是诸如这样的:\n\nfs.readfile('xxx', (err, data) => {});\n复制代码;\n\n\n典型的高阶函数，将回调函数作为函数参数传给了 readfile。但久而久之，就会发现，这种传入回调的方式也存在大坑, 比如下面这样:\n\nfs.readfile('1.json', (err, data) => {\n  fs.readfile('2.json', (err, data) => {\n    fs.readfile('3.json', (err, data) => {\n      fs.readfile('4.json', (err, data) => {});\n    });\n  });\n});\n复制代码;\n\n\n回调当中嵌套回调，也称回调地狱。这种代码的可读性和可维护性都是非常差的，因为嵌套的层级太多。而且还有一个严重的问题，就是每次任务可能会失败，需要在回调里面对每个任务的失败情况进行处理，增加了代码的混乱程度。\n\n\n# promise 时代\n\nes6 中新增的 promise 就很好了解决了回调地狱的问题，同时了合并了错误处理。写出来的代码类似于下面这样:\n\nreadfilepromise('1.json')\n  .then((data) => {\n    return readfilepromise('2.json');\n  })\n  .then((data) => {\n    return readfilepromise('3.json');\n  })\n  .then((data) => {\n    return readfilepromise('4.json');\n  });\n复制代码;\n\n\n以链式调用的方式避免了大量的嵌套，也符合人的线性思维方式，大大方便了异步编程。\n\n\n# co + generator 方式\n\n利用协程完成 generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。\n\nco(function*() {\n  const r1 = yield readfilepromise('1.json');\n  const r2 = yield readfilepromise('2.json');\n  const r3 = yield readfilepromise('3.json');\n  const r4 = yield readfilepromise('4.json');\n});\n复制代码;\n\n\n\n# async + await 方式\n\n这是 es7 中新增的关键字，凡是加上 async 的函数都默认返回一个 promise 对象，而更重要的是 async + await 也能让异步代码以同步的方式来书写，而不需要借助第三方库的支持。\n\nconst readfileasync = async function() {\n  const f1 = await readfilepromise('1.json');\n  const f2 = await readfilepromise('2.json');\n  const f3 = await readfilepromise('3.json');\n  const f4 = await readfilepromise('4.json');\n};\n复制代码;\n\n\n这四种经典的异步编程方式就简单回顾完了，由于是鸟瞰大局，我觉得知道是什么比了解细节要重要, 因此也没有展开。不过没关系，接下来，让我们针对这些具体的解决方案，一步步深入异步编程，理解其中的本质。\n\n\n# 第 33 篇: 能不能简单实现一下 node 中回调函数的机制？\n\n回调函数的方式其实内部利用了发布-订阅模式，在这里我们以模拟实现 node 中的 event 模块为例来写实现回调函数的机制。\n\nfunction eventemitter() {\n  this.events = new map();\n}\n复制代码;\n\n\n这个 eventemitter 一共需要实现这些方法: addlistener, removelistener, once, removealllistener, emit。\n\n首先是 addlistener：\n\n// once 参数表示是否只是触发一次\nconst wrapcallback = (fn, once = false) => ({\n  callback: fn,\n  once,\n});\n\neventemitter.prototype.addlistener = function(\n  type,\n  fn,\n  once = false,\n) {\n  let handler = this.events.get(type);\n  if (!handler) {\n    // 为 type 事件绑定回调\n    this.events.set(type, wrapcallback(fn, once));\n  } else if (\n    handler &&\n    typeof handler.callback === 'function'\n  ) {\n    // 目前 type 事件只有一个回调\n    this.events.set(type, [\n      handler,\n      wrapcallback(fn, once),\n    ]);\n  } else {\n    // 目前 type 事件回调数 >= 2\n    handler.push(wrapcallback(fn, once));\n  }\n};\n复制代码;\n\n\nremovelisener 的实现如下:\n\neventemitter.prototype.removelistener = function(\n  type,\n  listener,\n) {\n  let handler = this.events.get(type);\n  if (!handler) return;\n  if (!array.isarray(handler)) {\n    if (handler.callback === listener.callback)\n      this.events.delete(type);\n    else return;\n  }\n  for (let i = 0; i < handler.length; i++) {\n    let item = handler[i];\n    if (item.callback === listener.callback) {\n      // 删除该回调，注意数组塌陷的问题，即后面的元素会往前挪一位。i 要 --\n      handler.splice(i, 1);\n      i--;\n      if (handler.length === 1) {\n        // 长度为 1 就不用数组存了\n        this.events.set(type, handler[0]);\n      }\n    }\n  }\n};\n复制代码;\n\n\nonce 实现思路很简单，先调用 addlistener 添加上了 once 标记的回调对象, 然后在 emit 的时候遍历回调列表，将标记了 once: true 的项 remove 掉即可。\n\neventemitter.prototype.once = function(type, fn) {\n  this.addlistener(type, fn, true);\n};\n\neventemitter.prototype.emit = function(type, ...args) {\n  let handler = this.events.get(type);\n  if (!handler) return;\n  if (array.isarray(handler)) {\n    // 遍历列表，执行回调\n    handler.map((item) => {\n      item.callback.apply(this, args);\n      // 标记的 once: true 的项直接移除\n      if (item.once) this.removelistener(type, item);\n    });\n  } else {\n    // 只有一个回调则直接执行\n    handler.callback.apply(this, args);\n  }\n  return true;\n};\n\n复制代码;\n\n\n最后是 removealllistener：\n\neventemitter.prototype.removealllistener = function(type) {\n  let handler = this.events.get(type);\n  if (!handler) return;\n  else this.events.delete(type);\n};\n复制代码;\n\n\n现在我们测试一下:\n\nlet e = new eventemitter();\ne.addlistener('type', () => {\n  console.log('type事件触发！');\n});\ne.addlistener('type', () => {\n  console.log('wow!type事件又触发了！');\n});\n\nfunction f() {\n  console.log('type事件我只触发一次');\n}\ne.once('type', f);\ne.emit('type');\ne.emit('type');\ne.removealllistener('type');\ne.emit('type');\n\n// type事件触发！\n// wow!type事件又触发了！\n// type事件我只触发一次\n// type事件触发！\n// wow!type事件又触发了！\n复制代码;\n\n\nok，一个简易的 event 就这样实现完成了，为什么说它简易呢？因为还有很多细节的部分没有考虑:\n\n 1. 在参数少的情况下，call 的性能优于 apply，反之 apply 的性能更好。因此在执行回调时候可以根据情况调用 call 或者 apply。\n 2. 考虑到内存容量，应该设置回调列表的最大值，当超过最大值的时候，应该选择部分回调进行删除操作。\n 3. 鲁棒性有待提高。对于参数的校验很多地方直接忽略掉了。\n\n不过，这个案例的目的只是带大家掌握核心的原理，如果在这里洋洋洒洒写三四百行意义也不大，有兴趣的可以去看看 node 中 event 模块 的源码，里面对各种细节和边界情况做了详细的处理。\n\n\n# 第 34 篇: promise 之问(一)——promise 凭借什么消灭了回调地狱？\n\n\n# 问题\n\n首先，什么是回调地狱:\n\n 1. 多层嵌套的问题。\n 2. 每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。\n\n这两种问题在回调函数时代尤为突出。promise 的诞生就是为了解决这两个问题。\n\n\n# 解决方法\n\npromise 利用了三大技术手段来解决回调地狱:\n\n * 回调函数延迟绑定。\n * 返回值穿透。\n * 错误冒泡。\n\n首先来举个例子:\n\nlet readfilepromise = (filename) => {\n  fs.readfile(filename, (err, data) => {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(data);\n    }\n  });\n};\nreadfilepromise('1.json').then((data) => {\n  return readfilepromise('2.json');\n});\n复制代码;\n\n\n看到没有，回调函数不是直接声明的，而是在通过后面的 then 方法传入的，即延迟传入。这就是回调函数延迟绑定。\n\n然后我们做以下微调:\n\nlet x = readfilepromise('1.json').then((data) => {\n  return readfilepromise('2.json'); //这是返回的promise\n});\nx.then(/* 内部逻辑省略 */);\n复制代码;\n\n\n我们会根据 then 中回调函数的传入值创建不同类型的 promise, 然后把返回的 promise 穿透到外层, 以供后续的调用。这里的 x 指的就是内部返回的 promise，然后在 x 后面可以依次完成链式调用。\n\n这便是返回值穿透的效果。\n\n这两种技术一起作用便可以将深层的嵌套回调写成下面的形式:\n\nreadfilepromise('1.json')\n  .then((data) => {\n    return readfilepromise('2.json');\n  })\n  .then((data) => {\n    return readfilepromise('3.json');\n  })\n  .then((data) => {\n    return readfilepromise('4.json');\n  });\n复制代码;\n\n\n这样就显得清爽了许多，更重要的是，它更符合人的线性思维模式，开发体验也更好。\n\n两种技术结合产生了链式调用的效果。\n\n这解决的是多层嵌套的问题，那另一个问题，即每次任务执行结束后分别处理成功和失败的情况怎么解决的呢？\n\npromise 采用了错误冒泡的方式。其实很简单理解，我们来看看效果:\n\nreadfilepromise('1.json')\n  .then((data) => {\n    return readfilepromise('2.json');\n  })\n  .then((data) => {\n    return readfilepromise('3.json');\n  })\n  .then((data) => {\n    return readfilepromise('4.json');\n  })\n  .catch((err) => {\n    // xxx\n  });\n复制代码;\n\n\n这样前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了。\n\n\n# 解决效果\n\n * 1. 实现链式调用，解决多层嵌套问题\n * 1. 实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题\n\n\n# 第 35 篇: promise 之问(二)——为什么 promise 要引入微任务？\n\n在这里，如果你还没有接触过 promise, 务必去看看 mdn 文档，了解使用方式，不然后面很会懵。\n\npromise 中的执行函数是同步进行的，但是里面存在着异步操作，在异步操作结束后会调用 resolve 方法，或者中途遇到错误调用 reject 方法，这两者都是作为微任务进入到 eventloop 中。但是你有没有想过，promise 为什么要引入微任务的方式来进行回调操作？\n\n\n# 解决方式\n\n回到问题本身，其实就是如何处理回调的问题。总结起来有三种方式:\n\n 1. 使用同步回调，直到异步任务进行完，再进行后面的任务。\n 2. 使用异步回调，将回调函数放在进行宏任务队列的队尾。\n 3. 使用异步回调，将回调函数放到当前宏任务中的最后面。\n\n\n# 优劣对比\n\n第一种方式显然不可取，因为同步的问题非常明显，会让整个脚本阻塞住，当前任务等待，后面的任务都无法得到执行，而这部分等待的时间是可以拿来完成其他事情的，导致 cpu 的利用率非常低，而且还有另外一个致命的问题，就是无法实现延迟绑定的效果。\n\n如果采用第二种方式，那么执行回调(resolve/reject)的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。\n\n为了解决上述方案的问题，另外也考虑到延迟绑定的需求，promise 采取第三种方式, 即引入微任务, 即把 resolve(reject) 回调的执行放在当前宏任务的末尾。\n\n这样，利用微任务解决了两大痛点:\n\n * 1. 采用异步回调替代同步回调解决了浪费 cpu 性能的问题。\n * 1. 放到当前宏任务最后执行，解决了回调执行的实时性问题。\n\n好，promise 的基本实现思想已经讲清楚了，相信大家已经知道了它为什么这么设计，接下来就让我们一步步弄清楚它内部到底是怎么设计的。\n\n\n# 第 36 篇: promise 之问(三)——promise 如何实现链式调用？\n\n从现在开始，我们就来动手实现一个功能完整的 promise，一步步深挖其中的细节。我们先从链式调用开始。\n\n\n# 简易版实现\n\n首先写出第一版的代码:\n\n//定义三种状态\nconst pending = 'pending';\nconst fulfilled = 'fulfilled';\nconst rejected = 'rejected';\n\nfunction mypromise(executor) {\n  let self = this; // 缓存当前promise实例\n  self.value = null;\n  self.error = null;\n  self.status = pending;\n  self.onfulfilled = null; //成功的回调函数\n  self.onrejected = null; //失败的回调函数\n\n  const resolve = (value) => {\n    if (self.status !== pending) return;\n    settimeout(() => {\n      self.status = fulfilled;\n      self.value = value;\n      self.onfulfilled(self.value); //resolve时执行成功回调\n    });\n  };\n\n  const reject = (error) => {\n    if (self.status !== pending) return;\n    settimeout(() => {\n      self.status = rejected;\n      self.error = error;\n      self.onrejected(self.error); //resolve时执行成功回调\n    });\n  };\n  executor(resolve, reject);\n}\nmypromise.prototype.then = function(\n  onfulfilled,\n  onrejected,\n) {\n  if (this.status === pending) {\n    this.onfulfilled = onfulfilled;\n    this.onrejected = onrejected;\n  } else if (this.status === fulfilled) {\n    //如果状态是fulfilled，直接执行成功回调，并将成功值传入\n    onfulfilled(this.value);\n  } else {\n    //如果状态是rejected，直接执行失败回调，并将失败原因传入\n    onrejected(this.error);\n  }\n  return this;\n};\n复制代码;\n\n\n可以看到，promise 的本质是一个有限状态机，存在三种状态:\n\n * pending(等待)\n * fulfilled(成功)\n * rejected(失败)\n\n状态改变规则如下图:\n\n\n\n对于 promise 而言，状态的改变不可逆，即由等待态变为其他的状态后，就无法再改变了。\n\n不过，回到目前这一版的 promise, 还是存在一些问题的。\n\n\n# 设置回调数组\n\n首先只能执行一个回调函数，对于多个回调的绑定就无能为力，比如下面这样:\n\nlet promise1 = new mypromise((resolve, reject) => {\n  fs.readfile('./001.txt', (err, data) => {\n    if (!err) {\n      resolve(data);\n    } else {\n      reject(err);\n    }\n  });\n});\n\nlet x1 = promise1.then((data) => {\n  console.log('第一次展示', data.tostring());\n});\n\nlet x2 = promise1.then((data) => {\n  console.log('第二次展示', data.tostring());\n});\n\nlet x3 = promise1.then((data) => {\n  console.log('第三次展示', data.tostring());\n});\n复制代码;\n\n\n这里我绑定了三个回调，想要在 resolve() 之后一起执行，那怎么办呢？\n\n需要将 onfulfilled 和 onrejected 改为数组，调用 resolve 时将其中的方法拿出来一一执行即可。\n\nself.onfulfilledcallbacks = [];\nself.onrejectedcallbacks = [];\n复制代码;\nmypromise.prototype.then = function(\n  onfulfilled,\n  onrejected,\n) {\n  if (this.status === pending) {\n    this.onfulfilledcallbacks.push(onfulfilled);\n    this.onrejectedcallbacks.push(onrejected);\n  } else if (this.status === fulfilled) {\n    onfulfilled(this.value);\n  } else {\n    onrejected(this.error);\n  }\n  return this;\n};\n复制代码;\n\n\n接下来将 resolve 和 reject 方法中执行回调的部分进行修改：\n\n// resolve 中\nself.onfulfilledcallbacks.foreach((callback) =>\n  callback(self.value),\n);\n//reject 中\nself.onrejectedcallbacks.foreach((callback) =>\n  callback(self.error),\n);\n复制代码;\n\n\n\n# 链式调用完成\n\n我们采用目前的代码来进行测试:\n\nlet fs = require('fs');\nlet readfilepromise = (filename) => {\n  return new mypromise((resolve, reject) => {\n    fs.readfile(filename, (err, data) => {\n      if (!err) {\n        resolve(data);\n      } else {\n        reject(err);\n      }\n    });\n  });\n};\nreadfilepromise('./001.txt')\n  .then((data) => {\n    console.log(data.tostring());\n    return readfilepromise('./002.txt');\n  })\n  .then((data) => {\n    console.log(data.tostring());\n  });\n// 001.txt的内容\n// 001.txt的内容\n复制代码;\n\n\n咦？怎么打印了两个 001，第二次不是读的 002 文件吗？\n\n问题出在这里:\n\nmypromise.prototype.then = function(\n  onfulfilled,\n  onrejected,\n) {\n  //...\n  return this;\n};\n复制代码;\n\n\n这么写每次返回的都是第一个 promise。then 函数当中返回的第二个 promise 直接被无视了！\n\n说明 then 当中的实现还需要改进, 我们现在需要对 then 中返回值重视起来。\n\nmypromise.prototype.then = function(\n  onfulfilled,\n  onrejected,\n) {\n  let bridgepromise;\n  let self = this;\n  if (self.status === pending) {\n    return (bridgepromise = new mypromise(\n      (resolve, reject) => {\n        self.onfulfilledcallbacks.push((value) => {\n          try {\n            // 看到了吗？要拿到 then 中回调返回的结果。\n            let x = onfulfilled(value);\n            resolve(x);\n          } catch (e) {\n            reject(e);\n          }\n        });\n        self.onrejectedcallbacks.push((error) => {\n          try {\n            let x = onrejected(error);\n            resolve(x);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      },\n    ));\n  }\n  //...\n};\n复制代码;\n\n\n假若当前状态为 pending，将回调数组中添加如上的函数，当 promise 状态变化后，会遍历相应回调数组并执行回调。\n\n但是这段程度还是存在一些问题:\n\n 1. 首先 then 中的两个参数不传的情况并没有处理，\n 2. 假如 then 中的回调执行后返回的结果(也就是上面的x)是一个 promise, 直接给 resolve 了，这是我们不希望看到的。\n\n怎么来解决这两个问题呢？\n\n先对参数不传的情况做判断:\n\n// 成功回调不传给它一个默认函数\nonfulfilled =\n  typeof onfulfilled === 'function'\n    ? onfulfilled\n    : (value) => value;\n// 对于失败回调直接抛错\nonrejected =\n  typeof onrejected === 'function'\n    ? onrejected\n    : (error) => {\n        throw error;\n      };\n复制代码;\n\n\n然后对返回promise的情况进行处理:\n\nfunction resolvepromise(bridgepromise, x, resolve, reject) {\n  //如果x是一个promise\n  if (x instanceof mypromise) {\n    // 拆解这个 promise ，直到返回值不为 promise 为止\n    if (x.status === pending) {\n      x.then(\n        (y) => {\n          resolvepromise(bridgepromise, y, resolve, reject);\n        },\n        (error) => {\n          reject(error);\n        },\n      );\n    } else {\n      x.then(resolve, reject);\n    }\n  } else {\n    // 非 promise 的话直接 resolve 即可\n    resolve(x);\n  }\n}\n复制代码;\n\n\n然后在 then 的方法实现中作如下修改:\n\nresolve(x)  ->  resolvepromise(bridgepromise, x, resolve, reject);\n复制代码\n\n\n在这里大家好好体会一下拆解 promise 的过程，其实不难理解，我要强调的是其中的递归调用始终传入的resolve和reject这两个参数是什么含义，其实他们控制的是最开始传入的bridgepromise的状态，这一点非常重要。\n\n紧接着，我们实现一下当 promise 状态不为 pending 时的逻辑。\n\n成功状态下调用 then：\n\nif (self.status === fulfilled) {\n  return (bridgepromise = new mypromise(\n    (resolve, reject) => {\n      try {\n        // 状态变为成功，会有相应的 self.value\n        let x = onfulfilled(self.value);\n        // 暂时可以理解为 resolve(x)，后面具体实现中有拆解的过程\n        resolvepromise(bridgepromise, x, resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n    },\n  ));\n}\n复制代码;\n\n\n失败状态下调用 then：\n\nif (self.status === rejected) {\n  return (bridgepromise = new mypromise(\n    (resolve, reject) => {\n      try {\n        // 状态变为失败，会有相应的 self.error\n        let x = onrejected(self.error);\n        resolvepromise(bridgepromise, x, resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n    },\n  ));\n}\n复制代码;\n\n\npromise a+中规定成功和失败的回调都是微任务，由于浏览器中 js 触碰不到底层微任务的分配，可以直接拿 settimeout(属于宏任务的范畴) 来模拟，用 settimeout将需要执行的任务包裹 ，当然，上面的 resolve 实现也是同理, 大家注意一下即可，其实并不是真正的微任务。\n\nif (self.status === fulfilled) {\n  return bridgepromise = new mypromise((resolve, reject) => {\n    settimeout(() => {\n      //...\n    })\n}\n复制代码\nif (self.status === rejected) {\n  return bridgepromise = new mypromise((resolve, reject) => {\n    settimeout(() => {\n      //...\n    })\n}\n复制代码\n\n\n好了，到这里, 我们基本实现了 then 方法，现在我们拿刚刚的测试代码做一下测试, 依次打印如下:\n\n(001).txt的内容;\n(002).txt的内容;\n复制代码;\n\n\n可以看到，已经可以顺利地完成链式调用。\n\n\n# 错误捕获及冒泡机制分析\n\n现在来实现 catch 方法:\n\npromise.prototype.catch = function(onrejected) {\n  return this.then(null, onrejected);\n};\n复制代码;\n\n\n对，就是这么几行，catch 原本就是 then 方法的语法糖。\n\n相比于实现来讲，更重要的是理解其中错误冒泡的机制，即中途一旦发生错误，可以在最后用 catch 捕获错误。\n\n我们回顾一下 promise 的运作流程也不难理解，贴上一行关键的代码:\n\n// then 的实现中\nonrejected =\n  typeof onrejected === 'function'\n    ? onrejected\n    : (error) => {\n        throw error;\n      };\n复制代码;\n\n\n一旦其中有一个pending状态的 promise 出现错误后状态必然会变为失败, 然后执行 onrejected函数，而这个 onrejected 执行又会抛错，把新的 promise 状态变为失败，新的 promise 状态变为失败后又会执行onrejected......就这样一直抛下去，直到用catch 捕获到这个错误，才停止往下抛。\n\n这就是 promise 的错误冒泡机制。\n\n至此，promise 三大法宝: 回调函数延迟绑定、回调返回值穿透和错误冒泡。\n\n\n# 第 37 篇: promise 之问(四)——实现 promise 的 resolve、reject 和 finally\n\n\n# 实现 promise.resolve\n\n实现 resolve 静态方法有三个要点:\n\n * 1. 传参为一个 promise, 则直接返回它。\n * 1. 传参为一个 thenable 对象，返回的 promise 会跟随这个对象，采用它的最终状态作为自己的状态。\n * 1. 其他情况，直接返回以该值为成功状态的 promise 对象。\n\n具体实现如下:\n\npromise.resolve = (param) => {\n  if (param instanceof promise) return param;\n  return new promise((resolve, reject) => {\n    if (\n      param &&\n      param.then &&\n      typeof param.then === 'function'\n    ) {\n      // param 状态变为成功会调用resolve，将新 promise 的状态变为成功，反之亦然\n      param.then(resolve, reject);\n    } else {\n      resolve(param);\n    }\n  });\n};\n复制代码;\n\n\n\n# 实现 promise.reject\n\npromise.reject 中传入的参数会作为一个 reason 原封不动地往下传, 实现如下:\n\npromise.reject = function(reason) {\n  return new promise((resolve, reject) => {\n    reject(reason);\n  });\n};\n复制代码;\n\n\n\n# 实现 promise.prototype.finally\n\n无论当前 promise 是成功还是失败，调用finally之后都会执行 finally 中传入的函数，并且将值原封不动的往下传。\n\npromise.prototype.finally = function(callback) {\n  this.then(\n    (value) => {\n      return promise.resolve(callback()).then(() => {\n        return value;\n      });\n    },\n    (error) => {\n      return promise.resolve(callback()).then(() => {\n        throw error;\n      });\n    },\n  );\n};\n复制代码;\n\n\n\n# 第 38 篇: promise 之问(五)——实现 promise 的 all 和 race\n\n\n# 实现 promise.all\n\n对于 all 方法而言，需要完成下面的核心功能:\n\n 1. 传入参数为一个空的可迭代对象，则直接进行resolve。\n 2. 如果参数中有一个promise 失败，那么 promise.all 返回的 promise 对象失败。\n 3. 在任何情况下，promise.all 返回的 promise 的完成状态的结果都是一个数组\n\n具体实现如下:\n\npromise.all = function(promises) {\n  return new promise((resolve, reject) => {\n    let result = [];\n    let index = 0;\n    let len = promises.length;\n    if (len === 0) {\n      resolve(result);\n      return;\n    }\n\n    for (let i = 0; i < len; i++) {\n      // 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise\n      promise.resolve(promise[i])\n        .then((data) => {\n          result[i] = data;\n          index++;\n          if (index === len) resolve(result);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    }\n  });\n};\n复制代码;\n\n\n\n# 实现 promise.race\n\nrace 的实现相比之下就简单一些，只要有一个 promise 执行完，直接 resolve 并停止执行。\n\npromise.race = function(promises) {\n  return new promise((resolve, reject) => {\n    let len = promises.length;\n    if (len === 0) return;\n    for (let i = 0; i < len; i++) {\n      promise.resolve(promise[i])\n        .then((data) => {\n          resolve(data);\n          return;\n        })\n        .catch((err) => {\n          reject(err);\n          return;\n        });\n    }\n  });\n};\n复制代码;\n\n\n到此为止，一个完整的 promise 就被我们实现完啦。从原理到细节，我们一步步拆解和实现，希望大家在知道 promise 设计上的几大亮点之后，也能自己手动实现一个 promise，让自己的思维层次和动手能力更上一层楼！\n\n\n# 第 39 篇: 谈谈你对生成器以及协程的理解。\n\n生成器(generator)是 es6 中的新语法，相对于之前的异步语法，上手的难度还是比较大的。因此这里我们先来好好熟悉一下 generator 语法。\n\n\n# 生成器执行流程\n\n上面是生成器函数？\n\n生成器是一个带星号的\"函数\"(注意：它并不是真正的函数)，可以通过yield关键字暂停执行和恢复执行的\n\n举个例子:\n\nfunction* gen() {\n  console.log('enter');\n  let a = yield 1;\n  let b = yield (function() {\n    return 2;\n  })();\n  return 3;\n}\nvar g = gen(); // 阻塞住，不会执行任何语句\nconsole.log(typeof g); // object  看到了吗？不是\"function\"\n\nconsole.log(g.next());\nconsole.log(g.next());\nconsole.log(g.next());\nconsole.log(g.next());\n\n// enter\n// { value: 1, done: false }\n\n// { value: 2, done: false }\n// { value: 3, done: true }\n// { value: undefined, done: true }\n复制代码;\n\n\n由此可以看到，生成器的执行有这样几个关键点:\n\n 1. 调用 gen() 后，程序会阻塞住，不会执行任何语句。\n 2. 调用 g.next() 后，程序继续执行，直到遇到 yield 程序暂停。\n 3. next 方法返回一个对象， 有两个属性: value 和 done。value 为当前 yield 后面的结果，done 表示是否执行完，遇到了return 后，done 会由false变为true。\n\n\n# yield*\n\n当一个生成器要调用另一个生成器时，使用 yield* 就变得十分方便。比如下面的例子:\n\nfunction* gen1() {\n  yield 1;\n  yield 4;\n}\nfunction* gen2() {\n  yield 2;\n  yield 3;\n}\n复制代码;\n\n\n我们想要按照1234的顺序执行，如何来做呢？\n\n在 gen1 中，修改如下:\n\nfunction* gen1() {\n  yield 1;\n  yield* gen2();\n  yield 4;\n}\n复制代码;\n\n\n这样修改之后，之后依次调用next即可。\n\n\n# 生成器实现机制——协程\n\n可能你会比较好奇，生成器究竟是如何让函数暂停, 又会如何恢复的呢？接下来我们就来对其中的执行机制——协程一探究竟。\n\n# 什么是协程？\n\n协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。\n\n# 协程的运作过程\n\n那你可能要问了，js 不是单线程执行的吗，开这么多协程难道可以一起执行吗？\n\n答案是：并不能。一个线程一次只能执行一个协程。比如当前执行 a 协程，另外还有一个 b 协程，如果想要执行 b 的任务，就必须在 a 协程中将js 线程的控制权转交给 b协程，那么现在 b 执行，a 就相当于处于暂停的状态。\n\n举个具体的例子:\n\nfunction* a() {\n  console.log('我是a');\n  yield b(); // a停住，在这里转交线程执行权给b\n  console.log('结束了');\n}\nfunction b() {\n  console.log('我是b');\n  return 100; // 返回，并且将线程执行权还给a\n}\nlet gen = a();\ngen.next();\ngen.next();\n\n// 我是a\n// 我是b\n// 结束了\n复制代码;\n\n\n在这个过程中，a 将执行权交给 b，也就是 a 启动 b，我们也称 a 是 b 的父协程。因此 b 当中最后return 100其实是将 100 传给了父协程。\n\n需要强调的是，对于协程来说，它并不受操作系统的控制，完全由用户自定义切换，因此并没有进程/线程上下文切换的开销，这是高性能的重要原因。\n\nok, 原理就说到这里。可能你还会有疑问: 这个生成器不就暂停-恢复、暂停-恢复这样执行的吗？它和异步有什么关系？而且，每次执行都要调用 next，能不能让它一次性执行完毕呢？下一节我们就来仔细拆解这些问题。\n\n\n# 第 40 篇: 如何让 generator 的异步代码按顺序执行完毕？\n\n这里面其实有两个问题:\n\n 1. generator 如何跟异步产生关系？\n 2. 怎么把 generator 按顺序执行完毕？\n\n\n# thunk 函数\n\n要想知道 generator 跟异步的关系，首先带大家搞清楚一个概念——thunk 函数(即偏函数)，虽然这只是实现两者关系的方式之一。(另一种方式是promise, 后面会讲到)\n\n举个例子，比如我们现在要判断数据类型。可以写如下的判断逻辑:\n\nlet isstring = (obj) => {\n  return (\n    object.prototype.tostring.call(obj) ===\n    '[object string]'\n  );\n};\nlet isfunction = (obj) => {\n  return (\n    object.prototype.tostring.call(obj) ===\n    '[object function]'\n  );\n};\nlet isarray = (obj) => {\n  return (\n    object.prototype.tostring.call(obj) === '[object array]'\n  );\n};\nlet isset = (obj) => {\n  return (\n    object.prototype.tostring.call(obj) === '[object set]'\n  );\n};\n// ...\n复制代码;\n\n\n可以看到，出现了非常多重复的逻辑。我们将它们做一下封装:\n\nlet istype = (type) => {\n  return (obj) => {\n    return (\n      object.prototype.tostring.call(obj) ===\n      `[object ${type}]`\n    );\n  };\n};\n复制代码;\n\n\n现在我们这样做即可:\n\nlet isstring = istype('string');\nlet isfunction = istype('function');\n//...\n复制代码;\n\n\n相应的 isstring和isfunction是由istype生产出来的函数，但它们依然可以判断出参数是否为 string（function），而且代码简洁了不少。\n\nisstring('123');\nisfunction((val) => val);\n复制代码;\n\n\nistype这样的函数我们称为thunk 函数。它的核心逻辑是接收一定的参数，生产出定制化的函数，然后使用定制化的函数去完成功能。thunk 函数的实现会比单个的判断函数复杂一点点，但就是这一点点的复杂，大大方便了后续的操作。\n\n\n# generator 和 异步\n\n# thunk 版本\n\n以文件操作为例，我们来看看 异步操作 如何应用于generator。\n\nconst readfilethunk = (filename) => {\n  return (callback) => {\n    fs.readfile(filename, callback);\n  };\n};\n复制代码;\n\n\nreadfilethunk就是一个thunk函数。异步操作核心的一环就是绑定回调函数，而thunk函数可以帮我们做到。首先传入文件名，然后生成一个针对某个文件的定制化函数。这个函数中传入回调，这个回调就会成为异步操作的回调。这样就让 generator 和异步关联起来了。\n\n紧接者我们做如下的操作:\n\nconst gen = function*() {\n  const data1 = yield readfilethunk('001.txt');\n  console.log(data1.tostring());\n  const data2 = yield readfilethunk('002.txt');\n  console.log(data2.tostring);\n};\n复制代码;\n\n\n接着我们让它执行完:\n\nlet g = gen();\n// 第一步: 由于进场是暂停的，我们调用next，让它开始执行。\n// next返回值中有一个value值，这个value是yield后面的结果，放在这里也就是是thunk函数生成的定制化函数，里面需要传一个回调函数作为参数\ng.next().value((err, data1) => {\n  // 第二步: 拿到上一次得到的结果，调用next, 将结果作为参数传入，程序继续执行。\n  // 同理，value传入回调\n  g.next(data1).value((err, data2) => {\n    g.next(data2);\n  });\n});\n\n复制代码;\n\n\n打印结果如下:\n\n001.txt的内容\n002.txt的内容\n复制代码\n\n\n上面嵌套的情况还算简单，如果任务多起来，就会产生很多层的嵌套，可操作性不强，有必要把执行的代码封装一下:\n\nfunction run(gen) {\n  const next = (err, data) => {\n    let res = gen.next(data);\n    if (res.done) return;\n    res.value(next);\n  };\n  next();\n}\nrun(g);\n复制代码;\n\n\nok,再次执行，依然打印正确的结果。代码虽然就这么几行，但包含了递归的过程，好好体会一下。\n\n这是通过thunk完成异步操作的情况。\n\n# promise 版本\n\n还是拿上面的例子，用promise来实现就轻松一些:\n\nconst readfilepromise = (filename) => {\n  return new promise((resolve, reject) => {\n    fs.readfile(filename, (err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  }).then((res) => res);\n};\nconst gen = function*() {\n  const data1 = yield readfilepromise('001.txt');\n  console.log(data1.tostring());\n  const data2 = yield readfilepromise('002.txt');\n  console.log(data2.tostring);\n};\n复制代码;\n\n\n执行的代码如下:\n\nlet g = gen();\nfunction getgenpromise(gen, data) {\n  return gen.next(data).value;\n}\ngetgenpromise(g)\n  .then((data1) => {\n    return getgenpromise(g, data1);\n  })\n  .then((data2) => {\n    return getgenpromise(g, data2);\n  });\n复制代码;\n\n\n打印结果如下:\n\n001.txt的内容\n002.txt的内容\n复制代码\n\n\n同样，我们可以对执行generator的代码加以封装:\n\nfunction run(g) {\n  const next = (data) => {\n    let res = g.next();\n    if (res.done) return;\n    res.value.then((data) => {\n      next(data);\n    });\n  };\n  next();\n}\n复制代码;\n\n\n同样能输出正确的结果。代码非常精炼，希望能参照刚刚链式调用的例子，仔细体会一下递归调用的过程。\n\n\n# 采用 co 库\n\n以上我们针对 thunk 函数和promise两种generator异步操作的一次性执行完毕做了封装，但实际场景中已经存在成熟的工具包了，如果大名鼎鼎的co库, 其实核心原理就是我们已经手写过了（就是刚刚封装的 promise 情况下的执行代码），只不过源码会各种边界情况做了处理。使用起来非常简单:\n\nconst co = require('co');\nlet g = gen();\nco(g).then((res) => {\n  console.log(res);\n});\n复制代码;\n\n\n打印结果如下:\n\n(001).txt的内容;\n(002).txt的内容;\n100;\n复制代码;\n\n\n简单几行代码就完成了generator所有的操作，真不愧co和generator天生一对啊！\n\n\n# 第 41 篇: 解释一下 async/await 的运行机制。\n\nasync/await被称为 js 中异步终极解决方案。它既能够像 co + generator 一样用同步的方式来书写异步代码，又得到底层的语法支持，无需借助任何第三方库。接下来，我们从原理的角度来重新审视这个语法糖背后究竟做了些什么。\n\n\n# async\n\n什么是 async ?\n\n> mdn 的定义: async 是一个通过异步执行并隐式返回 promise 作为结果的函数。\n\n注意重点: 返回结果为 promise。\n\n举个例子:\n\nasync function func() {\n  return 100;\n}\nconsole.log(func());\n// promise {<resolved>: 100}\n复制代码;\n\n\n这就是隐式返回 promise 的效果。\n\n\n# await\n\n我们来看看 await做了些什么事情。\n\n以一段代码为例:\n\nasync function test() {\n  console.log(100);\n  let x = await 200;\n  console.log(x);\n  console.log(200);\n}\nconsole.log(0);\ntest();\nconsole.log(300);\n复制代码;\n\n\n我们来分析一下这段程序。首先代码同步执行，打印出0，然后将test压入执行栈，打印出100, 下面注意了，遇到了关键角色await。\n\n放个慢镜头:\n\nawait 100;\n复制代码;\n\n\n被 js 引擎转换成一个 promise :\n\nlet promise = new promise((resolve, reject) => {\n  resolve(100);\n});\n复制代码;\n\n\n这里调用了 resolve，resolve 的任务进入微任务队列。\n\n然后，js 引擎将暂停当前协程的运行，把线程的执行权交给父协程(父协程不懂是什么的，上上篇才讲，回去补课)。\n\n回到父协程中，父协程的第一件事情就是对await返回的promise调用then, 来监听这个 promise 的状态改变 。\n\npromise.then((value) => {\n  // 相关逻辑，在resolve 执行之后来调用\n});\n复制代码;\n\n\n然后往下执行，打印出300。\n\n根据eventloop机制，当前主线程的宏任务完成，现在检查微任务队列, 发现还有一个 promise 的 resolve，执行，现在父协程在then中传入的回调执行。我们来看看这个回调具体做的是什么。\n\npromise.then((value) => {\n  // 1. 将线程的执行权交给test协程\n  // 2. 把 value 值传递给 test 协程\n});\n复制代码;\n\n\nok, 现在执行权到了test协程手上，test 接收到父协程传来的200, 赋值给 a ,然后依次执行后面的语句，打印200、200。\n\n最后的输出为:\n\n0;\n100;\n300;\n200;\n200;\n复制代码;\n\n\n总结一下，async/await利用协程和promise实现了同步方式编写异步代码的效果，其中generator是对协程的一种实现，虽然语法简单，但引擎在背后做了大量的工作，我们也对这些工作做了一一的拆解。用async/await写出的代码也更加优雅、美观，相比于之前的promise不断调用 then 的方式，语义化更加明显，相比于co + generator性能更高，上手成本也更低，不愧是 js 异步终极解决方案！\n\n\n# 第 42 篇: foreach 中用 await 会产生什么问题?怎么解决这个问题？\n\n\n# 问题\n\n问题:对于异步代码，foreach 并不能保证按顺序执行。\n\n举个例子:\n\nasync function test() {\n  let arr = [4, 2, 1];\n  arr.foreach(async (item) => {\n    const res = await handle(item);\n    console.log(res);\n  });\n  console.log('结束');\n}\n\nfunction handle(x) {\n  return new promise((resolve, reject) => {\n    settimeout(() => {\n      resolve(x);\n    }, 1000 * x);\n  });\n}\n\ntest();\n复制代码;\n\n\n我们期望的结果是:\n\n4;\n2;\n1;\n结束;\n复制代码;\n\n\n但是实际上会输出:\n\n结束;\n1;\n2;\n4;\n复制代码;\n\n\n\n# 问题原因\n\n这是为什么呢？我想我们有必要看看foreach底层怎么实现的。\n\n// 核心逻辑\nfor (var i = 0; i < length; i++) {\n  if (i in array) {\n    var element = array[i];\n    callback(element, i, array);\n  }\n}\n复制代码;\n\n\n可以看到，foreach 拿过来直接执行了，这就导致它无法保证异步任务的执行顺序。比如后面的任务用时短，那么就又可能抢在前面的任务之前执行。\n\n\n# 解决方案\n\n如何来解决这个问题呢？\n\n其实也很简单, 我们利用for...of就能轻松解决。\n\nasync function test() {\n  let arr = [4, 2, 1];\n  for (const item of arr) {\n    const res = await handle(item);\n    console.log(res);\n  }\n  console.log('结束');\n}\n复制代码;\n\n\n\n# 解决原理——iterator\n\n好了，这个问题看起来好像很简单就能搞定，你有想过这么做为什么可以成功吗？\n\n其实，for...of 并不像 foreach 那么简单粗暴的方式去遍历执行，而是采用一种特别的手段——迭代器去遍历。\n\n首先，对于数组来讲，它是一种可迭代数据类型。那什么是可迭代数据类型呢？\n\n> 原生具有[symbol.iterator]属性数据类型为可迭代数据类型。如数组、类数组（如 arguments、nodelist）、set 和 map。\n\n可迭代对象可以通过迭代器进行遍历。\n\nlet arr = [4, 2, 1];\n// 这就是迭代器\nlet iterator = arr[symbol.iterator]();\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\n\n// {value: 4, done: false}\n// {value: 2, done: false}\n// {value: 1, done: false}\n// {value: undefined, done: true}\n复制代码;\n\n\n因此，我们的代码可以这样来组织:\n\nasync function test() {\n  let arr = [4, 2, 1];\n  let iterator = arr[symbol.iterator]();\n  let res = iterator.next();\n  while (!res.done) {\n    let value = res.value;\n    console.log(value);\n    await handle(value);\n    res = iterater.next();\n  }\n  console.log('结束');\n}\n// 4\n// 2\n// 1\n// 结束\n复制代码;\n\n\n多个任务成功地按顺序执行！其实刚刚的 for...of 循环代码就是这段代码的语法糖。\n\n\n# 重新认识生成器\n\n回头再看看用 iterator 遍历[4,2,1]这个数组的代码。\n\nlet arr = [4, 2, 1];\n// 迭代器\nlet iterator = arr[symbol.iterator]();\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\n\n// {value: 4, done: false}\n// {value: 2, done: false}\n// {value: 1, done: false}\n// {value: undefined, done: true}\n复制代码;\n\n\n咦？返回值有value和done属性，生成器也可以调用 next,返回的也是这样的数据结构，这么巧?!\n\n没错，生成器本身就是一个迭代器。\n\n既然属于迭代器，那它就可以用 for...of 遍历了吧？\n\n当然没错，不信来写一个简单的斐波那契数列(50 以内)：\n\nfunction* fibonacci() {\n  let [prev, cur] = [0, 1];\n  console.log(cur);\n  while (true) {\n    [prev, cur] = [cur, prev + cur];\n    yield cur;\n  }\n}\n\nfor (let item of fibonacci()) {\n  if (item > 50) break;\n  console.log(item);\n}\n// 1\n// 1\n// 2\n// 3\n// 5\n// 8\n// 13\n// 21\n// 34\n复制代码;\n\n\n是不是非常酷炫？这就是迭代器的魅力：）同时又对生成器有了更深入的理解，没想到我们的老熟人generator还有这样的身份。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "React Hooks",
      "frontmatter": {
        "title": "React Hooks",
        "date": "2021-09-17T22:39:03.000Z",
        "permalink": "/pages/a29bb7/",
        "categories": [
          "note",
          "MV*",
          "React"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/MV*/React/ReactHooks.html",
      "relativePath": "note/MV*/React/ReactHooks.md",
      "key": "v-63397d7c",
      "path": "/pages/a29bb7/",
      "lastUpdated": "10/28/2021, 7:15:37 PM",
      "headersStr": null,
      "content": "React Hooks",
      "normalizedContent": "react hooks",
      "charsets": {}
    },
    {
      "title": "React Firber",
      "frontmatter": {
        "title": "React Firber",
        "date": "2021-09-16T20:04:11.000Z",
        "permalink": "/pages/e53db3/",
        "categories": [
          "note",
          "MV*",
          "React"
        ],
        "tags": [
          "React"
        ]
      },
      "regularPath": "/note/MV*/React/ReactFirber.html",
      "relativePath": "note/MV*/React/ReactFirber.md",
      "key": "v-609ed934",
      "path": "/pages/e53db3/",
      "headers": [
        {
          "level": 3,
          "title": "总结",
          "slug": "zong-jie",
          "normalizedTitle": "总结",
          "charIndex": 1000
        }
      ],
      "lastUpdated": "10/28/2021, 7:15:37 PM",
      "headersStr": "总结",
      "content": "React Fiber\n\n> 部分内容整理自网络资源\n\n\n\n\n\n\n\n 1. 接受输入事件\n 2. 执行事件回调\n 3. 开始一帧\n 4. 执行 RAF (RequestAnimationFrame)\n 5. 页面布局，样式计算\n 6. 渲染\n 7. 执行 RIC (RequestIdelCallback)\n    一帧包括了用户的交互行为的处理、js 的执行、requestAnimationFrame 的调用、layout 布局、paint 页面重绘等工作，假如某一帧里面要执行的任务不多，在不到 16ms（1000/60=16)的时间内就完成了上述任务的话，页面就会正常显示不会出现卡顿的现象，但是如果一旦 js 执行时间过长，超过了 16ms，这一帧的刷新就没有时间执 layout 和 paint 部分了，就可能会出现页面卡顿的现象。\n\n * js 引擎和页面渲染引擎是在同一个渲染线程之内，两者是互斥关系。\n * React16 中使用了 Fiber，但是 Vue 是没有 Fiber 的，为什么呢？原因是二者的优化思路不一样：\n   1. Vue 是基于 template 和 watcher 的组件级更新，把每个更新任务分割得足够小，不需要使用到 Fiber 架构，将任务进行更细粒度的拆分\n   2. React 是不管在哪里调用 setState，都是从根节点开始更新的，更新任务还是很大，需要使用到 Fiber 将大任务分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务\n * requestAnimationFrame\n * requestIdleCallback\n * \n\nreact 团队重写了核心算法 --reconciliation。即 fiber reconciler 的架构在原来的基础上增加了 Scheduler（调度器）的概念：\n\n * Scheduler（调度器）: 调度任务的优先级，高优任务优先进入Reconciler。\n\n浏览器有个 api 叫requestIdleCallback，就是指在浏览器的空闲时段内调用的一些函数的回调。React 实现了功能更完备的 requestIdleCallbackpolyfill，这就是Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。\n\n\n# 总结\n\n * 初始化渲染，调用函数组件、或 class 组件的 render 方法，将 JSX 代码编译成 ReactELement 对象，它描述当前组件内容的数据结构。\n\n * 根据生产的 ReactELement 对象构建 Fiber tree，它包含了组件 schedule、reconciler、render 所需的相关信息。\n\n * 一旦有状态变化，触发更新，Scheduler 在接收到更新后，根据任务的优先级高低来进行调度，决定要执行的任务是什么。\n\n * 接下来的工作交给 Reconciler 处理，Reconciler 通过对比找出变化了的 Virtual DOM ，为其打上代表增/删/更新的标记，当所有组件都完成 Reconciler 的工作，才会统一交给Renderer。\n\n * Renderer 根据 Reconciler 为 Virtual DOM 打的标记，同步执行对应的 DOM 更新操作。",
      "normalizedContent": "react fiber\n\n> 部分内容整理自网络资源\n\n\n\n\n\n\n\n 1. 接受输入事件\n 2. 执行事件回调\n 3. 开始一帧\n 4. 执行 raf (requestanimationframe)\n 5. 页面布局，样式计算\n 6. 渲染\n 7. 执行 ric (requestidelcallback)\n    一帧包括了用户的交互行为的处理、js 的执行、requestanimationframe 的调用、layout 布局、paint 页面重绘等工作，假如某一帧里面要执行的任务不多，在不到 16ms（1000/60=16)的时间内就完成了上述任务的话，页面就会正常显示不会出现卡顿的现象，但是如果一旦 js 执行时间过长，超过了 16ms，这一帧的刷新就没有时间执 layout 和 paint 部分了，就可能会出现页面卡顿的现象。\n\n * js 引擎和页面渲染引擎是在同一个渲染线程之内，两者是互斥关系。\n * react16 中使用了 fiber，但是 vue 是没有 fiber 的，为什么呢？原因是二者的优化思路不一样：\n   1. vue 是基于 template 和 watcher 的组件级更新，把每个更新任务分割得足够小，不需要使用到 fiber 架构，将任务进行更细粒度的拆分\n   2. react 是不管在哪里调用 setstate，都是从根节点开始更新的，更新任务还是很大，需要使用到 fiber 将大任务分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务\n * requestanimationframe\n * requestidlecallback\n * \n\nreact 团队重写了核心算法 --reconciliation。即 fiber reconciler 的架构在原来的基础上增加了 scheduler（调度器）的概念：\n\n * scheduler（调度器）: 调度任务的优先级，高优任务优先进入reconciler。\n\n浏览器有个 api 叫requestidlecallback，就是指在浏览器的空闲时段内调用的一些函数的回调。react 实现了功能更完备的 requestidlecallbackpolyfill，这就是scheduler。除了在空闲时触发回调的功能外，scheduler还提供了多种调度优先级供任务设置。\n\n\n# 总结\n\n * 初始化渲染，调用函数组件、或 class 组件的 render 方法，将 jsx 代码编译成 reactelement 对象，它描述当前组件内容的数据结构。\n\n * 根据生产的 reactelement 对象构建 fiber tree，它包含了组件 schedule、reconciler、render 所需的相关信息。\n\n * 一旦有状态变化，触发更新，scheduler 在接收到更新后，根据任务的优先级高低来进行调度，决定要执行的任务是什么。\n\n * 接下来的工作交给 reconciler 处理，reconciler 通过对比找出变化了的 virtual dom ，为其打上代表增/删/更新的标记，当所有组件都完成 reconciler 的工作，才会统一交给renderer。\n\n * renderer 根据 reconciler 为 virtual dom 打的标记，同步执行对应的 dom 更新操作。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "React Virtual DOM",
      "frontmatter": {
        "title": "React Virtual DOM",
        "date": "2021-09-17T22:19:11.000Z",
        "permalink": "/pages/1f970b/",
        "categories": [
          "note",
          "MV*",
          "React"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/MV*/React/ReactVirtualDOM.html",
      "relativePath": "note/MV*/React/ReactVirtualDOM.md",
      "key": "v-9ee5cc90",
      "path": "/pages/1f970b/",
      "headers": [
        {
          "level": 2,
          "title": "操作 DOM 是耗费性能的",
          "slug": "cao-zuo-dom-shi-hao-fei-xing-neng-de",
          "normalizedTitle": "操作 dom 是耗费性能的",
          "charIndex": 35
        },
        {
          "level": 2,
          "title": "什么是Virtual DOM",
          "slug": "shi-me-shi-virtual-dom",
          "normalizedTitle": "什么是virtual dom",
          "charIndex": 509
        },
        {
          "level": 2,
          "title": "Virtual DOM 的优势",
          "slug": "virtual-dom-de-you-shi",
          "normalizedTitle": "virtual dom 的优势",
          "charIndex": 1138
        },
        {
          "level": 2,
          "title": "ReactElement",
          "slug": "reactelement",
          "normalizedTitle": "reactelement",
          "charIndex": 1352
        },
        {
          "level": 2,
          "title": "Virtual DOM 安全",
          "slug": "virtual-dom-an-quan",
          "normalizedTitle": "virtual dom 安全",
          "charIndex": 1926
        }
      ],
      "lastUpdated": "10/28/2021, 7:15:37 PM",
      "headersStr": "操作 DOM 是耗费性能的 什么是Virtual DOM Virtual DOM 的优势 ReactElement Virtual DOM 安全",
      "content": "ReactVirtualDOM\n\n> 部分内容整理自网络资源\n\n\n# 操作 DOM 是耗费性能的\n\n由于 JS 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 线程和渲染线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 渲染线程 与 JS 引擎线程 为互斥的关系，当 JS 引擎执行时渲染线程会被挂起，GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。\n\n因此我们在操作 DOM 时，任何 DOM API 调用都要先将 JS 数据结构转为 DOM 数据结构，再挂起 JS 引擎线程并启动渲染引擎线程，执行过后再把可能的返回值反转数据结构，重启 JS 引擎继续执行。这种两个线程之间的上下文切换势必会很耗性能。\n\n另外很多 DOM API 的读写都涉及页面布局的 重绘（repaint）和回流（reflow） ，这会更加的耗费性能。\n\n综上所述，单次 DOM API 调用性能就不够好，频繁调用就会迅速积累上述损耗，但我们又不可能不去操作 DOM，因此解决问题的本质是要 减少不必要的 DOM API 调用。\n\n\n# 什么是Virtual DOM\n\nReact.js 相对于直接操作原生 DOM 最大的优势在于 batching 和 diff。\n\n\n\nVirtualDom 的本质是利用 JS 变量 对真实 DOM 进行抽象，既然每一次操作 DOM 都可能触发浏览器的重排消耗性能，那么就可以使用 VirtualDom 来缓存当前组件状态，对用户交互和数据的变动进行批次处理，直接计算出每一帧页面应该呈现的最终状态，而这个状态是以 JS 变量 的形式存在于内存中的。所以通过 VirtualDom 既能够保证用户看到的每一帧都响应了数据的变化，又能节约性能保证浏览器不出现卡顿。\n\nReact.js 相对于直接操作原生 DOM 最大的优势在于 batching 和 diff。为了尽量减少不必要的 DOM 操作， Virtual DOM 在执行 DOM 的更新操作后，不会直接操作真实 DOM，而是根据当前应用状态的数据，生成一个全新的 Virtual DOM，然后跟上一次生成 的 Virtual DOM 去 diff，得到一个 Patch，这样就可以找到变化了的 DOM 节点，只对变化的部分进行 DOM 更新，而不是重新渲染整个 DOM 树，这个过程就是 diff。还有所谓的batching就是将多次比较的结果合并后一次性更新到页面，从而有效地减少页面渲染的次数，提高渲染效率。batching 或者 diff, 说到底，都是为了尽量减少对 DOM 的调用。\n\n\n# Virtual DOM 的优势\n\n 1. 为函数式的 UI 编程方式打开了大门，我们不需要再去考虑具体 DOM 的操作，框架已经替我们做了，我们就可以用更加声明式的方式书写代码。\n 2. 减少页面渲染的次数，提高渲染效率。\n 3. 提供了更好的跨平台的能力，因为 virtual DOM 是以 JavaScript 对象为基础而不依赖具体的平台环境，因此可以适用于其他的平台，如 node、weex、native 等。\n\n\n# ReactElement\n\n 1. ReactElement 是通过 createElement 函数创建的。\n 2. createElement 函数接收 3 个参数，分别是 type, config, children\n\n * type 指代这个 ReactElement 的类型，它可以是 DOM 元素类型，也可以是 React 组件类型。\n * config 即是传入的 元素上的属性组成的对象。\n * children 是一个数组，代表该元素的子元素。\n\n\n\n * $$typeof 是一个常量 REACT_ELEMENT_TYPE，所有通过 React.createElement 生成的元素都有这个值，用来表示这是一个 React 元素。它还有一个取值，通过 createPortals 函数生成的 $$typeof 值就是 REACT_PORTAL_TYPE。\n * key 和 ref 从 config 对象中作为一个特殊的配置，被单独抽取出来，放在 ReactElement 下。\n * props 包含了两部分，第一部分是去除了 key 和 ref 的 config，第二部分是 children 数组，数组的成员也是通过 React.createElement 生成的对象。\n * _owner 就是 Fiber。\n\n\n# Virtual DOM 安全\n\n$$typeof ，这个属性会指向 Symbol(React.element) 。作为 React 元素的唯一标识的同时，这个标签也承担了安全方面的功能。我们已经知道了所谓的 ReactElement 其实就是一个 JS 对象。那么如果有用户恶意的向服务端数据库中存入了某个有侵入性功能的 伪 React 对象，在实际渲染过程中被当做页面元素渲染，那么将有可能威胁到用户的安全。而 Symbol 是无法在数据库中被存储的，换句话说， React 所渲染的所有元素，都必须是由 JSX 编译的拥有 Symbol 标识的元素。（如果在低版本不支持 Symbol 的浏览器中，将会使用字符串替代，也就没有这层安排保护了）",
      "normalizedContent": "reactvirtualdom\n\n> 部分内容整理自网络资源\n\n\n# 操作 dom 是耗费性能的\n\n由于 js 是可操纵 dom 的，如果在修改这些元素属性同时渲染界面（即 js 线程和渲染线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 渲染线程 与 js 引擎线程 为互斥的关系，当 js 引擎执行时渲染线程会被挂起，gui 更新则会被保存在一个队列中等到 js 引擎线程空闲时立即被执行。\n\n因此我们在操作 dom 时，任何 dom api 调用都要先将 js 数据结构转为 dom 数据结构，再挂起 js 引擎线程并启动渲染引擎线程，执行过后再把可能的返回值反转数据结构，重启 js 引擎继续执行。这种两个线程之间的上下文切换势必会很耗性能。\n\n另外很多 dom api 的读写都涉及页面布局的 重绘（repaint）和回流（reflow） ，这会更加的耗费性能。\n\n综上所述，单次 dom api 调用性能就不够好，频繁调用就会迅速积累上述损耗，但我们又不可能不去操作 dom，因此解决问题的本质是要 减少不必要的 dom api 调用。\n\n\n# 什么是virtual dom\n\nreact.js 相对于直接操作原生 dom 最大的优势在于 batching 和 diff。\n\n\n\nvirtualdom 的本质是利用 js 变量 对真实 dom 进行抽象，既然每一次操作 dom 都可能触发浏览器的重排消耗性能，那么就可以使用 virtualdom 来缓存当前组件状态，对用户交互和数据的变动进行批次处理，直接计算出每一帧页面应该呈现的最终状态，而这个状态是以 js 变量 的形式存在于内存中的。所以通过 virtualdom 既能够保证用户看到的每一帧都响应了数据的变化，又能节约性能保证浏览器不出现卡顿。\n\nreact.js 相对于直接操作原生 dom 最大的优势在于 batching 和 diff。为了尽量减少不必要的 dom 操作， virtual dom 在执行 dom 的更新操作后，不会直接操作真实 dom，而是根据当前应用状态的数据，生成一个全新的 virtual dom，然后跟上一次生成 的 virtual dom 去 diff，得到一个 patch，这样就可以找到变化了的 dom 节点，只对变化的部分进行 dom 更新，而不是重新渲染整个 dom 树，这个过程就是 diff。还有所谓的batching就是将多次比较的结果合并后一次性更新到页面，从而有效地减少页面渲染的次数，提高渲染效率。batching 或者 diff, 说到底，都是为了尽量减少对 dom 的调用。\n\n\n# virtual dom 的优势\n\n 1. 为函数式的 ui 编程方式打开了大门，我们不需要再去考虑具体 dom 的操作，框架已经替我们做了，我们就可以用更加声明式的方式书写代码。\n 2. 减少页面渲染的次数，提高渲染效率。\n 3. 提供了更好的跨平台的能力，因为 virtual dom 是以 javascript 对象为基础而不依赖具体的平台环境，因此可以适用于其他的平台，如 node、weex、native 等。\n\n\n# reactelement\n\n 1. reactelement 是通过 createelement 函数创建的。\n 2. createelement 函数接收 3 个参数，分别是 type, config, children\n\n * type 指代这个 reactelement 的类型，它可以是 dom 元素类型，也可以是 react 组件类型。\n * config 即是传入的 元素上的属性组成的对象。\n * children 是一个数组，代表该元素的子元素。\n\n\n\n * $$typeof 是一个常量 react_element_type，所有通过 react.createelement 生成的元素都有这个值，用来表示这是一个 react 元素。它还有一个取值，通过 createportals 函数生成的 $$typeof 值就是 react_portal_type。\n * key 和 ref 从 config 对象中作为一个特殊的配置，被单独抽取出来，放在 reactelement 下。\n * props 包含了两部分，第一部分是去除了 key 和 ref 的 config，第二部分是 children 数组，数组的成员也是通过 react.createelement 生成的对象。\n * _owner 就是 fiber。\n\n\n# virtual dom 安全\n\n$$typeof ，这个属性会指向 symbol(react.element) 。作为 react 元素的唯一标识的同时，这个标签也承担了安全方面的功能。我们已经知道了所谓的 reactelement 其实就是一个 js 对象。那么如果有用户恶意的向服务端数据库中存入了某个有侵入性功能的 伪 react 对象，在实际渲染过程中被当做页面元素渲染，那么将有可能威胁到用户的安全。而 symbol 是无法在数据库中被存储的，换句话说， react 所渲染的所有元素，都必须是由 jsx 编译的拥有 symbol 标识的元素。（如果在低版本不支持 symbol 的浏览器中，将会使用字符串替代，也就没有这层安排保护了）",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "优化使用context带来的不必要渲染问题",
      "frontmatter": {
        "title": "优化使用context带来的不必要渲染问题",
        "date": "2021-08-06T20:08:37.000Z",
        "permalink": "/pages/context/",
        "categories": [
          "note"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/context.html",
      "relativePath": "note/context.md",
      "key": "v-38fd5eec",
      "path": "/pages/context/",
      "headers": [
        {
          "level": 2,
          "title": "预览",
          "slug": "yu-lan",
          "normalizedTitle": "预览",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "说明",
          "slug": "shuo-ming",
          "normalizedTitle": "说明",
          "charIndex": 9
        },
        {
          "level": 2,
          "title": "Stage1",
          "slug": "stage1",
          "normalizedTitle": "stage1",
          "charIndex": 153
        }
      ],
      "lastUpdated": "9/7/2021, 10:55:52 PM",
      "headersStr": "预览 说明 Stage1",
      "content": "# 预览\n\n\n# 说明\n\n如何体现出组件是否发生 render\n\nconst getBg = (color) => {\n  return {\n    backgroundColor: `rgba(${color || \"255,1,1\"}, ${Math.random()})`\n  };\n};\n\n\n\n# Stage1\n\nsetState 会让所有子组件更新（因为 createElement 重新执行）\n\nimport React, { useState } from \"react\";\nimport { getBg } from \"../getColor\";\n\nconst Count = (props) => {\n  return <div style={getBg()}>{props.count}</div>;\n};\n\nconst Pure = () => {\n  return <div style={getBg()}>pure</div>;\n};\n\nconst SetCount = (props) => {\n  return (\n    <Button\n      style={getBg()}\n      onClick={() => props.setCount((count) => count + 1)}\n    >\n      SetCount\n    </Button>\n  );\n};\n\nconst Stage1 = () => {\n  const [count, setCount] = useState(0);\n  const [, forceReRender] = useState({});\n  console.log(\"render\");\n  return (\n    <>\n      <Button style={getBg()} onClick={() => forceReRender({})}>\n        FORCE_RE_RENDER\n      </Button>\n      <Count count={count} />\n      <SetCount setCount={setCount} />\n      <Pure />\n    </>\n  );\n};\n\nexport default Stage1;\n\n",
      "normalizedContent": "# 预览\n\n\n# 说明\n\n如何体现出组件是否发生 render\n\nconst getbg = (color) => {\n  return {\n    backgroundcolor: `rgba(${color || \"255,1,1\"}, ${math.random()})`\n  };\n};\n\n\n\n# stage1\n\nsetstate 会让所有子组件更新（因为 createelement 重新执行）\n\nimport react, { usestate } from \"react\";\nimport { getbg } from \"../getcolor\";\n\nconst count = (props) => {\n  return <div style={getbg()}>{props.count}</div>;\n};\n\nconst pure = () => {\n  return <div style={getbg()}>pure</div>;\n};\n\nconst setcount = (props) => {\n  return (\n    <button\n      style={getbg()}\n      onclick={() => props.setcount((count) => count + 1)}\n    >\n      setcount\n    </button>\n  );\n};\n\nconst stage1 = () => {\n  const [count, setcount] = usestate(0);\n  const [, forcererender] = usestate({});\n  console.log(\"render\");\n  return (\n    <>\n      <button style={getbg()} onclick={() => forcererender({})}>\n        force_re_render\n      </button>\n      <count count={count} />\n      <setcount setcount={setcount} />\n      <pure />\n    </>\n  );\n};\n\nexport default stage1;\n\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "test",
      "frontmatter": {
        "title": "test",
        "date": "2021-09-09T21:46:09.000Z",
        "permalink": "/pages/0088df/",
        "categories": [
          "note"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/test.html",
      "relativePath": "note/test.md",
      "key": "v-432c973c",
      "path": "/pages/0088df/",
      "lastUpdated": "9/17/2021, 10:21:49 PM",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "todo",
      "frontmatter": {
        "title": "todo",
        "date": "2021-09-07T22:28:49.000Z",
        "permalink": "/pages/9276fb/",
        "categories": [
          "note"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/todo.html",
      "relativePath": "note/todo.md",
      "key": "v-9b4c403c",
      "path": "/pages/9276fb/",
      "headers": [
        {
          "level": 3,
          "title": "📒 待整理",
          "slug": "dai-zheng-li",
          "normalizedTitle": "📒 待整理",
          "charIndex": 2
        }
      ],
      "headersStr": "📒 待整理",
      "content": "# 📒 待整理\n\n * vscode 自动格式化md文件，搞得很是郁闷，加入 [markdown] 自定义配置 \"editor.formatOnSave\": false 搞定了。 https://www.cnblogs.com/pengchenggang/p/14917817.html\n * vuepress markdown 拓展 https://blog.dbplayer.org/my-blog/",
      "normalizedContent": "# 📒 待整理\n\n * vscode 自动格式化md文件，搞得很是郁闷，加入 [markdown] 自定义配置 \"editor.formatonsave\": false 搞定了。 https://www.cnblogs.com/pengchenggang/p/14917817.html\n * vuepress markdown 拓展 https://blog.dbplayer.org/my-blog/",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "top-level await",
      "frontmatter": {
        "title": "top-level await",
        "date": "2021-07-26T16:04:15.000Z",
        "permalink": "/pages/top-level-await/",
        "categories": [
          "note"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/top-levelAwait.html",
      "relativePath": "note/top-levelAwait.md",
      "key": "v-6a10a6a2",
      "path": "/pages/top-level-await/",
      "headers": [
        {
          "level": 2,
          "title": "top-level await",
          "slug": "top-level-await",
          "normalizedTitle": "top-level await",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "1. 在引入 top-level await 之前",
          "slug": "1.-zai-yin-ru-top-level-await-zhi-qian",
          "normalizedTitle": "1. 在引入 top-level await 之前",
          "charIndex": 350
        },
        {
          "level": 3,
          "title": "2.使用 Export Promise 来代替初始化",
          "slug": "2.shi-yong-export-promise-lai-dai-ti-chu-shi-hua",
          "normalizedTitle": "2.使用 export promise 来代替初始化",
          "charIndex": 1314
        },
        {
          "level": 3,
          "title": "3. 使用 top-level await",
          "slug": "3.-shi-yong-top-level-await",
          "normalizedTitle": "3. 使用 top-level await",
          "charIndex": 2208
        },
        {
          "level": 3,
          "title": "4. 过去",
          "slug": "4.-guo-qu",
          "normalizedTitle": "4. 过去",
          "charIndex": 3002
        },
        {
          "level": 3,
          "title": "5. 现在",
          "slug": "5.-xian-zai",
          "normalizedTitle": "5. 现在",
          "charIndex": 3285
        },
        {
          "level": 3,
          "title": "6. 何时使用",
          "slug": "6.-he-shi-shi-yong",
          "normalizedTitle": "6. 何时使用",
          "charIndex": 3448
        },
        {
          "level": 3,
          "title": "结尾",
          "slug": "jie-wei",
          "normalizedTitle": "结尾",
          "charIndex": 3882
        }
      ],
      "lastUpdated": "9/7/2021, 10:55:52 PM",
      "headersStr": "top-level await 1. 在引入 top-level await 之前 2.使用 Export Promise 来代替初始化 3. 使用 top-level await 4. 过去 5. 现在 6. 何时使用 结尾",
      "content": "# top-level await\n\n我们都知道在异步编程中， await 只能在 aysnc function 里进行使用。await 提升了异步编程的体验，使我们能像同步函数那样处理异步函数。同时我们也会好奇 await 只能在 aysnc 中使用\n\nECMAScript 提案 Top-level await 允许开发者在 async 函数外使用 await 字段,目前已进入 tc39 Stage 3。\n\nTop-level await 允许你将整个 JS 模块视为一个巨大的 async 函数，这样就可以直接在顶层使用 await，而不必用 async 函数包一层。\n\n> 早在 2020-08-11 node 发布 14.8.0 版本开始支持 top-level await\n\n\n\n\n# 1. 在引入 top-level await 之前\n\n// ------ method.js\nexport function double(num) {\n  return num * 2;\n}\n\nexport function square(num) {\n  return num * num;\n}\n\n// ------ middleware.js\nimport { double, square } from './method.js';\n\nlet doubleOutput;\nlet squareOutput;\n\n// IIFE\n(async () => {\n  await requestData();\n  doubleOutput = double(10);\n  squareOutput = square(10);\n})();\n\n// 模拟接口请求\nfunction requestData(delays = 1000) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(console.log('❤️'));\n    }, delays);\n  });\n}\n\nexport { doubleOutput, squareOutput };\n\n// ------ index.js\nimport {\n  doubleOutput,\n  squareOutput,\n} from './middleware.js';\n\nconsole.log('doubleOutput-init', doubleOutput); // undefined\nconsole.log('squareOutput-init', squareOutput); // undefined\n\nsetTimeout(\n  () => console.log('doubleOutput-delay', doubleOutput),\n  2000,\n); // 20\nsetTimeout(\n  () => console.log('squareOutput-delay', squareOutput),\n  2000,\n); // 100\n\n\n\n# 2.使用 Export Promise 来代替初始化\n\n// ------ method.js\nexport function double(num) {\n  return num * 2;\n}\n\nexport function square(num) {\n  return num * num;\n}\n\n// ------ middleware.js\nimport { double, square } from './method.js';\n\nlet doubleOutput;\nlet squareOutput;\n\n// IIFE\nexport default (async () => {\n  await requestData();\n  doubleOutput = double(10);\n  squareOutput = square(10);\n  return { doubleOutput, squareOutput };\n})();\n\n// 模拟接口请求\nfunction requestData(delays = 1000) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(console.log('❤️'));\n    }, delays);\n  });\n}\n\nexport { doubleOutput, squareOutput };\n\n// ------ index.js\nimport promise from './middleware.js';\n\npromise.then(({ doubleOutput, squareOutput }) => {\n  console.log('doubleOutput-delay', doubleOutput); // 20\n  console.log('squareOutput-delay', squareOutput); // 100\n});\n\n\n所有引用都要写成 promise 结构，十分不方便\n\n\n# 3. 使用 top-level await\n\n// ------ method.js\nexport function double(num) {\n  return num * 2;\n}\n\nexport function square(num) {\n  return num * num;\n}\n\n// ------ middleware.js\nimport { double, square } from './method.js';\n\nlet doubleOutput;\nlet squareOutput;\n\n// \"plugins\": [\"@babel/plugin-syntax-top-level-await\"]\nawait requestData();\n\ndoubleOutput = double(10);\nsquareOutput = square(10);\n\n// 模拟接口请求\nfunction requestData(delays = 1000) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(console.log('❤️'));\n    }, delays);\n  });\n}\n\nexport { doubleOutput, squareOutput };\n\n// ------ index.js\nimport {\n  doubleOutput,\n  squareOutput,\n} from './middleware.js';\n\nconsole.log('doubleOutput-init', doubleOutput); // 20\nconsole.log('squareOutput-init', squareOutput); // 100\n\n\n\n# 4. 过去\n\n当 async/await 首次引用时，尝试在 async 函数外部使用 await 的结果是产生 SyntaxError。大多数开发者使用立即执行异步函数表达式的方式来使用该功能。\n\nawait Promise.resolve(console.log('🎉'));\n// → SyntaxError: await is only valid in async function\n(async function() {\n  await Promise.resolve(console.log('🎉'));\n  // → 🎉\n})();\n\n\n\n# 5. 现在\n\n在 top-level await 的支持下，下面代码可以替换模块中常见代码\n\nawait Promise.resolve(console.log('🎉'));\n// → 🎉\n\n\n> 注意： top-level await 仅能工作在模块的顶层。在 class 代码块或非 async 函数不支持。\n\n\n# 6. 何时使用\n\n参考 spec proposal repository\n\n# 6.1 动态依赖导入\n\nconst strings = await import(`/i18n/${navigator.language}`);\n\n\n这允许在模块的运行时环境中确认依赖项。\n\n# 6.2 资源初始化\n\nconst connection = await dbConnector();\n\n\n允许模块申请资源，同时也可以在模块不能使用时抛出错误。\n\n# 6.3 依赖回退\n\nlet jQuery;\ntry {\n  jQuery = await import('https://cdn-a.example.com/jQuery');\n} catch {\n  jQuery = await import('https://cdn-b.example.com/jQuery');\n}\n\n\n希望从 CDN A 加载 JavaScript 库，如果它加载失败，将加载 CDN B\n\n\n# 结尾\n\ntop-level await 在某些特定场景有很方便的作用，但是目前这个一特性还没有很好的运用到生产代码中\n\n\n\n> 本文整理自作者 Myles Borins 「Top-level await」，转载请注明来源链接\n> \n> https://v8.dev/features/top-level-await\n\n相关资源：\n\n * # @babel/plugin-syntax-top-level-await\n\n * # https://github.com/tc39/proposal-top-level-await",
      "normalizedContent": "# top-level await\n\n我们都知道在异步编程中， await 只能在 aysnc function 里进行使用。await 提升了异步编程的体验，使我们能像同步函数那样处理异步函数。同时我们也会好奇 await 只能在 aysnc 中使用\n\necmascript 提案 top-level await 允许开发者在 async 函数外使用 await 字段,目前已进入 tc39 stage 3。\n\ntop-level await 允许你将整个 js 模块视为一个巨大的 async 函数，这样就可以直接在顶层使用 await，而不必用 async 函数包一层。\n\n> 早在 2020-08-11 node 发布 14.8.0 版本开始支持 top-level await\n\n\n\n\n# 1. 在引入 top-level await 之前\n\n// ------ method.js\nexport function double(num) {\n  return num * 2;\n}\n\nexport function square(num) {\n  return num * num;\n}\n\n// ------ middleware.js\nimport { double, square } from './method.js';\n\nlet doubleoutput;\nlet squareoutput;\n\n// iife\n(async () => {\n  await requestdata();\n  doubleoutput = double(10);\n  squareoutput = square(10);\n})();\n\n// 模拟接口请求\nfunction requestdata(delays = 1000) {\n  return new promise((resolve) => {\n    settimeout(() => {\n      resolve(console.log('❤️'));\n    }, delays);\n  });\n}\n\nexport { doubleoutput, squareoutput };\n\n// ------ index.js\nimport {\n  doubleoutput,\n  squareoutput,\n} from './middleware.js';\n\nconsole.log('doubleoutput-init', doubleoutput); // undefined\nconsole.log('squareoutput-init', squareoutput); // undefined\n\nsettimeout(\n  () => console.log('doubleoutput-delay', doubleoutput),\n  2000,\n); // 20\nsettimeout(\n  () => console.log('squareoutput-delay', squareoutput),\n  2000,\n); // 100\n\n\n\n# 2.使用 export promise 来代替初始化\n\n// ------ method.js\nexport function double(num) {\n  return num * 2;\n}\n\nexport function square(num) {\n  return num * num;\n}\n\n// ------ middleware.js\nimport { double, square } from './method.js';\n\nlet doubleoutput;\nlet squareoutput;\n\n// iife\nexport default (async () => {\n  await requestdata();\n  doubleoutput = double(10);\n  squareoutput = square(10);\n  return { doubleoutput, squareoutput };\n})();\n\n// 模拟接口请求\nfunction requestdata(delays = 1000) {\n  return new promise((resolve) => {\n    settimeout(() => {\n      resolve(console.log('❤️'));\n    }, delays);\n  });\n}\n\nexport { doubleoutput, squareoutput };\n\n// ------ index.js\nimport promise from './middleware.js';\n\npromise.then(({ doubleoutput, squareoutput }) => {\n  console.log('doubleoutput-delay', doubleoutput); // 20\n  console.log('squareoutput-delay', squareoutput); // 100\n});\n\n\n所有引用都要写成 promise 结构，十分不方便\n\n\n# 3. 使用 top-level await\n\n// ------ method.js\nexport function double(num) {\n  return num * 2;\n}\n\nexport function square(num) {\n  return num * num;\n}\n\n// ------ middleware.js\nimport { double, square } from './method.js';\n\nlet doubleoutput;\nlet squareoutput;\n\n// \"plugins\": [\"@babel/plugin-syntax-top-level-await\"]\nawait requestdata();\n\ndoubleoutput = double(10);\nsquareoutput = square(10);\n\n// 模拟接口请求\nfunction requestdata(delays = 1000) {\n  return new promise((resolve) => {\n    settimeout(() => {\n      resolve(console.log('❤️'));\n    }, delays);\n  });\n}\n\nexport { doubleoutput, squareoutput };\n\n// ------ index.js\nimport {\n  doubleoutput,\n  squareoutput,\n} from './middleware.js';\n\nconsole.log('doubleoutput-init', doubleoutput); // 20\nconsole.log('squareoutput-init', squareoutput); // 100\n\n\n\n# 4. 过去\n\n当 async/await 首次引用时，尝试在 async 函数外部使用 await 的结果是产生 syntaxerror。大多数开发者使用立即执行异步函数表达式的方式来使用该功能。\n\nawait promise.resolve(console.log('🎉'));\n// → syntaxerror: await is only valid in async function\n(async function() {\n  await promise.resolve(console.log('🎉'));\n  // → 🎉\n})();\n\n\n\n# 5. 现在\n\n在 top-level await 的支持下，下面代码可以替换模块中常见代码\n\nawait promise.resolve(console.log('🎉'));\n// → 🎉\n\n\n> 注意： top-level await 仅能工作在模块的顶层。在 class 代码块或非 async 函数不支持。\n\n\n# 6. 何时使用\n\n参考 spec proposal repository\n\n# 6.1 动态依赖导入\n\nconst strings = await import(`/i18n/${navigator.language}`);\n\n\n这允许在模块的运行时环境中确认依赖项。\n\n# 6.2 资源初始化\n\nconst connection = await dbconnector();\n\n\n允许模块申请资源，同时也可以在模块不能使用时抛出错误。\n\n# 6.3 依赖回退\n\nlet jquery;\ntry {\n  jquery = await import('https://cdn-a.example.com/jquery');\n} catch {\n  jquery = await import('https://cdn-b.example.com/jquery');\n}\n\n\n希望从 cdn a 加载 javascript 库，如果它加载失败，将加载 cdn b\n\n\n# 结尾\n\ntop-level await 在某些特定场景有很方便的作用，但是目前这个一特性还没有很好的运用到生产代码中\n\n\n\n> 本文整理自作者 myles borins 「top-level await」，转载请注明来源链接\n> \n> https://v8.dev/features/top-level-await\n\n相关资源：\n\n * # @babel/plugin-syntax-top-level-await\n\n * # https://github.com/tc39/proposal-top-level-await",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "typescript不完整指南",
      "frontmatter": {
        "title": "typescript不完整指南",
        "date": "2021-07-26T14:00:49.000Z",
        "permalink": "/pages/typeScript/",
        "categories": [
          "note"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/typescript.html",
      "relativePath": "note/typescript.md",
      "key": "v-76ab9602",
      "path": "/pages/typeScript/",
      "headers": [
        {
          "level": 2,
          "title": "1、为什么要学习 TypeScript",
          "slug": "1-wei-shi-me-yao-xue-xi-typescript",
          "normalizedTitle": "1、为什么要学习 typescript",
          "charIndex": 112
        },
        {
          "level": 2,
          "title": "2、基础类型",
          "slug": "2-ji-chu-lei-xing",
          "normalizedTitle": "2、基础类型",
          "charIndex": 717
        },
        {
          "level": 2,
          "title": "3、枚举",
          "slug": "3-mei-ju",
          "normalizedTitle": "3、枚举",
          "charIndex": 1635
        },
        {
          "level": 2,
          "title": "4、函数 Function",
          "slug": "4-han-shu-function",
          "normalizedTitle": "4、函数 function",
          "charIndex": 2417
        },
        {
          "level": 2,
          "title": "5、断言",
          "slug": "5-duan-yan",
          "normalizedTitle": "5、断言",
          "charIndex": 2975
        },
        {
          "level": 2,
          "title": "6、接口 interface",
          "slug": "6-jie-kou-interface",
          "normalizedTitle": "6、接口 interface",
          "charIndex": 3701
        },
        {
          "level": 2,
          "title": "7、类 Class",
          "slug": "7-lei-class",
          "normalizedTitle": "7、类 class",
          "charIndex": 4186
        },
        {
          "level": 2,
          "title": "8、泛类 generic",
          "slug": "8-fan-lei-generic",
          "normalizedTitle": "8、泛类 generic",
          "charIndex": 5619
        },
        {
          "level": 2,
          "title": "9、高级类型",
          "slug": "9-gao-ji-lei-xing",
          "normalizedTitle": "9、高级类型",
          "charIndex": 6623
        },
        {
          "level": 2,
          "title": "10、tsconfig.json",
          "slug": "10-tsconfig.json",
          "normalizedTitle": "10、tsconfig.json",
          "charIndex": 7622
        },
        {
          "level": 2,
          "title": "参考资源",
          "slug": "can-kao-zi-yuan",
          "normalizedTitle": "参考资源",
          "charIndex": 10575
        }
      ],
      "lastUpdated": "9/7/2021, 10:55:52 PM",
      "headersStr": "1、为什么要学习 TypeScript 2、基础类型 3、枚举 4、函数 Function 5、断言 6、接口 interface 7、类 Class 8、泛类 generic 9、高级类型 10、tsconfig.json 参考资源",
      "content": "TypeScript\n\n> 怎样熟练使用 TypeScript ？\n\n👨‍💻 用了一段时间的 TypeScript,深感 ts 的必要性，结合最近的项目开发经历，整理了一篇关于 typescript 的使用心得\n\n\n# 1、为什么要学习 TypeScript\n\nTypeScript 在推出之初就备受追捧又备受质疑，质疑如下：\n\n * 静态语言会丧失 JavaScript 灵活性\n * TypeScript 必定赴 coffeescript 后尘，会被标准取代\n\n# 优点\n\n * typescript 的超集 JavaScript\n\n\n\n * 静态类型\n   \n   一门语言在编译时报错，那么就是静态语言，如果在运行时报错，那么就是动态语言\n   \n   typescript 就是一门静态类型语言，它能够提前在编译期避免许多 bug，如很恶心的拼写问题等\n\n很多项目，尤其是中大型项目，我们是需要团队多人协作的，那么如何保证协作呢?这个时候可能需要大量的文档和注释，显式类型就是最好的注释，而通过 TypeScript 提供的类型提示功能我们可以非常舒服地调用同伴的代码，由于 TypeScript 的存在我们可以节省大量沟通成本、代码阅读成本等等（各人认为不认同，是对 ts 学习的最大阻碍 🈲）。\n\n# 缺点\n\n * 与实际框架结合会有很多坑\n * 配置学习成本高\n * TypeScript 的类型系统其实比较复杂\n\n# 使用总结\n\n 1. ⌛️ 规避大量低级错误，避免时间浪费，省时\n 2. 💪 减少多人协作项目的成本，大型项目友好，省力\n 3. ❤️ 良好代码提示，不用反复文件跳转或者翻文档，省心\n\n\n# 2、基础类型\n\nundefined | null | boolean | number | bigint | string | symbol | void | object | unknown | never | any\n\n * 布尔类型：boolean\n * 数字类型：number\n * 字符串类型：string\n * 空值：void\n * Null and Undefined：null undefined\n * Symbol 类型：symbol\n\n# 类型声明技巧\n\n * 声明一个 void 类型的只能将它赋值为 undefined 和 null\n   \n   let unusable: void = undefined;\n   \n\n * 没有声明的变量 ts 也会进行类型推到不一定所有的变量都需要声明类型\n   \n   let name = 'xiaodong';\n   // 等价于\n   let name: string = 'xiaodong';\n   \n\n * 联合类型\n   \n   function getString(something: string | number): string {\n     return something.toString();\n   }\n   \n\n * any 类型的使用要慎重，是多人项目协作的大忌，稍有不慎就会变成 anyscript，（本人深有感触 🙄，同事备受摧残 💀 ）\n\n * never 表示那些永远不存在的值，never 是任何类型的子类型，也可以赋值给任何类型\n   \n   // 抛出异常的函数没有返回值\n   function error(message: string): never {\n     throw new Error(message);\n   }\n   \n\n * 数组分为两种类型定义:\n   \n   // 使用泛类\n   const list: Array<number> = [1, 2, 3];\n   // 元素类型后面直接加 []\n   const list: number[] = [1, 2, 3];\n   \n\n\n# 3、枚举\n\n# 数组枚举\n\n当我们声明一个枚举类型，虽然没有赋值，但是它们的值其实是默认数字类型，默认从 0 开始依次累加：\n\nenum Days {\n  Sun,\n  Mon,\n  Tue,\n  Wed,\n  ...\n}\nconsole.log(Days[\"Sun\"]); // 0\n// 反向映射\nconsole.log(Days[0]); // 'Sun'\n\nconsole.log(Days[\"Mon\"]); // 1\nconsole.log(Days[1]); // 'Mon'\n\n\n因此我们给第一个值赋值后面也会根据第一个值进行累加：\n\nenum Days2 {\n  Sun = 7,\n  Mon,\n  Tue = 1,\n  Wed,\n\t...\n}\nconsole.log(Days2[\"Sun\"]); // 7\nconsole.log(Days2[\"Mon\"]); // 8\nconsole.log(Days2[\"Tue\"]); // 1\nconsole.log(Days2[\"Wed\"]); // 2\n\n\n# 字符串枚举\n\nenum Days3 {\n  Sun = 'SUN',\n  Mon = 'MON',\n  Tue = 'TUE',\n  Wed = 'WED',\n\t...\n}\nconsole.log(Days3['Sun'], Days3.MON); // SUN Mon\n\n\n# 枚举的本质\n\n'use strict';\nvar Days3;\n(function(Days3) {\n  Days3['Sun'] = 'SUN';\n  Days3['Mon'] = 'MON';\n  Days3['Tue'] = 'TUE';\n  Days3['Wed'] = 'WED';\n})(Days3 || (Days3 = {}));\n\n\n\n# 4、函数 Function\n\n函数的作用就不在这里过多叙述了，typescript 里函数仍然是主要的定义行为的地方。\n\n# 定义类型函数\n\nconst add = (x: number, y: number) => {\n  return x + y;\n};\n\n\n# 可选参数\n\n❌ 可选参数后面不允许再出现必须参数\n\nconst add = (x: number, y?: number) => {\n  return x + (y ? y : 0);\n};\n\n\n# 默认参数\n\nconst add = (x: number, y: number = 1) => {\n  return x + y;\n};\n\n\n# 剩余参数\n\n// rest 参数只能是最后一个参数，关于 rest 参数,是一个数组\nconst add = (x: number, ...rest: number[]) => {\n  return rest.reduce((x, y) => x + y, x);\n};\nfunction push(array: any[], ...items: any[]) {\n  items.forEach(function(item) {\n    array.push(item);\n  });\n}\n\n\n\n# 5、断言\n\n处使用 ts 可能会遇到一些问题，比如：\n\nconst person = {};\nperson.name = 'xiaodong'; // Error: 'name' ‘{}’\nperson.age = 23; // Error: 'age' ‘{}’\n\n\n由于类型推断，此时 person 的类型就是{},不存在其他属性，开发者知道 person 有这个属性只是一开始没有声明，此时就需要类型断言：\n\n# as 语法\n\ninterface Person {\n  name: string;\n  age: number;\n}\nconst person = {} as Person;\nperson.name = 'xiaodong';\nperson.age = 23;\n\n\n# 尖括号语法\n\ninterface Person {\n  name: string;\n  age: number;\n}\nconst person = <Person>{};\nperson.name = 'xiaodong';\nperson.age = 20;\n\n\n# 双重断言\n\n双重断言有个前提，子类型可以被断言为父类型\n\n双重断言断言可以实现子类型转换为另外一种子类型（ 子类型->父类型->子类型）\n\n❌ 尽量不使用双重断言，会破坏原有类型关系\n\ninterface Person {\n  name: string;\n  age: number;\n}\nconst person = 'xiaodong' as Person; // Error\nconst person = ('xiaodong' as any) as Person; // ok\n\n\n\n# 6、接口 interface\n\n在 ts 中，接口的作用就为你的代码或者第三方代码定义锲约\n\n# 接口的使用\n\n注意：一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集\n\ninterface Person {\n  readonly id: number; // 直读属性\n  name: string;\n  age?: number;\n  say: () => void;\n  // [propName: string]: string; // 错误示范\n  [propName: string]: any; //任意属性\n}\n\nlet xiaodong: Person = {\n  id: 1013, // 只读\n  name: 'ErDong',\n  age: 25,\n  gender: 'GG',\n  say() {\n    console.log('hello');\n  },\n};\n\n\n# 接口继承\n\ninterface VIP extends Person {\n  playBasketball: () => void;\n}\n\n\n\n# 7、类 Class\n\n# 成员属性与静态属性\n\nclass Game {\n  // 静态属性\n  static gName: string = '王者荣耀';\n  // 成员属性\n  playing: string;\n\n  // 构造函数 - 执行初始化操作\n  constructor(type: string) {\n    this.playing = type;\n  }\n\n  // 静态方法\n  static getName(): string {\n    return 'GameName is 王者荣耀';\n  }\n\n  // 成员方法\n  play() {\n    return '玩' + this.playing;\n  }\n}\n\n\n如何解释成员属性与静态属性\n\n'use strict';\nvar Game = /** @class */ (function() {\n  // 构造函数 - 执行初始化操作\n  function Game(type) {\n    this.playing = type;\n  }\n  // 静态方法\n  Game.getName = function() {\n    return 'GameName is 王者荣耀';\n  };\n  // 成员方法\n  Game.prototype.play = function() {\n    return '玩' + this.playing;\n  };\n  // 静态属性\n  Game.gName = '王者荣耀';\n  return Game;\n})();\n\n\n# 访问限定符\n\n# public\n\n修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\n\n# private （#）\n\n修饰的属性或方法是私有的，不能在声明它的类的外部访问\n\n# protected\n\n修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\n# class 可以作为接口\n\n通常我们会使用 interface 作为接口，实际上类 class 也可以作为接口使用\n\n由于组件需要传入props的类型Props，同时还需要设置 defaultProps，这时候我们使用 class 来作为接口就会方便很多\n\n我们先声明一个类，然后这个类包含 props 所需的类型和初始值：\n\nexport default class Props {\n  public children:\n    | Array<React.ReactElement<any>>\n    | React.ReactElement<any>\n    | never[] = [];\n  public height: number = 181;\n  public bodyWeight: string = '70KG';\n  public handsome: boolean = true;\n  public basketball: () => {};\n}\n\n\n当我们需要设置 props 的初始值事\n\npublic static defaultProps = new Props()\n\n\nProps 的实例就是 defaultProps 的初始值，所有 class 作为类既可以当做接口还可以设置默认值，方便了统一管理，还减少了代码量。\n\n\n# 8、泛类 generic\n\n（图片来源：https://medium.com/better-programming/typescript-generics-90be93d8c292）\n\n泛型就是解决类、接口方法的复用性、以及对不特定数据类型的支持\n\ninterface IStingLength {\n  length: number;\n}\nfunction test<T extends IStingLength>(res: T): T {\n  console.log(res.length); // 12\n  return res;\n}\n\nconst str = 'typescript学习';\n// result 就是 string 类型\nconst result = test<string>(str);\nconsole.log(result); // typescript学习\n\n\n# 多个类型参数\n\nfunction swap<T, U>(tuple: [T, U]): [U, T] {\n  return [tuple[1], tuple[0]];\n}\nswap([0, 'hello']); // ['hello', 0]\n\n\n# 泛类接口\n\ninterface ReturnItemFn<K> {\n  (res: K): K;\n}\nconst returnItem: ReturnItemFn<number> = (res) => res;\n\n\n# 泛型类\n\nclass GenericNumber<T> {\n  zeroValue: T;\n  add: (x: T, y: T) => T;\n}\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) {\n  return x + y;\n};\nconsole.log(myGenericNumber.add(20, 10)); // 30\n\n\n# 常见泛类变量\n\n * T（Type）：表示一个 TypeScript 类型\n * K（Key）：表示对象中的键类型\n * V（Value）：表示对象中的值类型\n * E（Element）：表示元素类型\n\n\n# 9、高级类型\n\n# 索引类型\n\n我们需要一个 pick 函数 ，这个函数可以从对象上取出指定属性，实现方法如下\n\n# JavaScript 版本\n\nfunction pick(obj, names) {\n  return names.map((item) => obj[item]);\n}\nconst user = {\n  username: '晓冬',\n  age: 24,\n  height: 181,\n};\nconst res = pick(user, ['username']);\nconsole.log(res); // [\"晓冬\"]\n\n\n# TypeScript 简版\n\ninterface Obj {\n  [key: string]: any;\n}\nfunction pick(obj: Obj, names: string[]) {\n  return names.map((n) => obj[n]);\n}\n\n\n# TypeScript 高级版\n\nfunction pick<T, K extends keyof T>(\n  obj: T,\n  names: K[],\n): T[K][] {\n  return names.map((n) => obj[n]);\n}\nconst res = pick(user, ['username', 'height']);\n\n\n# 映射类型\n\n当我们有一个接口，现在需要把接口所有成员变成可选的，当然我们不可能一个一个在：前添加问号，作为程序猿当然会有更懒的方法，这时候就需要我们的映射了，映射类型的语法：[P in Keys]\n\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n\n\n# 常见工具类\n\n其实，TypeScript 提供一些工具类型来帮助常见的类型转换。这些类型是全局可见的\n\n# Partial<T>\n\n构造类型 T，并将它所有的属性设置为可选的。它的返回类型表示输入类型的所有子类型。\n\n# Readonly <T>\n\n构造类型 T，并将它所有的属性设置为 readonly，也就是说构造出的类型的属性不能被再次赋值。\n\n# Record<K,T>\n\n构造一个类型，其属性名的类型为 K，属性值的类型为 T。这个工具可用来将某个类型的属性映射到另一个类型上。\n\n……\n\n\n# 10、tsconfig.json\n\n编译选项 （https://www.tslang.cn/docs/handbook/compiler-options.html）\n\n> 引用「深入理解 TypeScript-编译选项」\n\n{\n  \"compilerOptions\": {\n    /* 基本选项 */\n    \"target\": \"es5\",                       // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'\n    \"module\": \"commonjs\",                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"lib\": [],                             // 指定要包含在编译中的库文件\n    \"allowJs\": true,                       // 允许编译 javascript 文件\n    \"checkJs\": true,                       // 报告 javascript 文件中的错误\n    \"jsx\": \"preserve\",                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'\n    \"declaration\": true,                   // 生成相应的 '.d.ts' 文件\n    \"sourceMap\": true,                     // 生成相应的 '.map' 文件\n    \"outFile\": \"./\",                       // 将输出文件合并为一个文件\n    \"outDir\": \"./\",                        // 指定输出目录\n    \"rootDir\": \"./\",                       // 用来控制输出目录结构 --outDir.\n    \"removeComments\": true,                // 删除编译后的所有的注释\n    \"noEmit\": true,                        // 不生成输出文件\n    \"importHelpers\": true,                 // 从 tslib 导入辅助工具函数\n    \"isolatedModules\": true,               // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                        // 启用所有严格类型检查选项\n    \"noImplicitAny\": true,                 // 在表达式和声明上有隐含的 any类型时报错\n    \"strictNullChecks\": true,              // 启用严格的 null 检查\n    \"noImplicitThis\": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误\n    \"alwaysStrict\": true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'\n\n    /* 额外的检查 */\n    \"noUnusedLocals\": true,                // 有未使用的变量时，抛出错误\n    \"noUnusedParameters\": true,            // 有未使用的参数时，抛出错误\n    \"noImplicitReturns\": true,             // 并不是所有函数里的代码都有返回值时，抛出错误\n    \"noFallthroughCasesInSwitch\": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）\n\n    /* 模块解析选项 */\n    \"moduleResolution\": \"node\",            // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)\n    \"baseUrl\": \"./\",                       // 用于解析非相对模块名称的基目录\n    \"paths\": {},                           // 模块名到基于 baseUrl 的路径映射的列表\n    \"rootDirs\": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容\n    \"typeRoots\": [],                       // 包含类型声明的文件列表\n    \"types\": [],                           // 需要包含的类型声明文件名列表\n    \"allowSyntheticDefaultImports\": true,  // 允许从没有设置默认导出的模块中默认导入。\n\n    /* Source Map Options */\n    \"sourceRoot\": \"./\",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置\n    \"mapRoot\": \"./\",                       // 指定调试器应该找到映射文件而不是生成文件的位置\n    \"inlineSourceMap\": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件\n    \"inlineSources\": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性\n\n    /* 其他选项 */\n    \"experimentalDecorators\": true,        // 启用装饰器\n    \"emitDecoratorMetadata\": true          // 为装饰器提供元数据的支持\n  }\n\n\n\n# 参考资源\n\n * 深入理解 TypeScript\n * TypeScript 中文文档\n\n----------------------------------------\n\n/_ TODO _/\n\n更多内容待补充",
      "normalizedContent": "typescript\n\n> 怎样熟练使用 typescript ？\n\n👨‍💻 用了一段时间的 typescript,深感 ts 的必要性，结合最近的项目开发经历，整理了一篇关于 typescript 的使用心得\n\n\n# 1、为什么要学习 typescript\n\ntypescript 在推出之初就备受追捧又备受质疑，质疑如下：\n\n * 静态语言会丧失 javascript 灵活性\n * typescript 必定赴 coffeescript 后尘，会被标准取代\n\n# 优点\n\n * typescript 的超集 javascript\n\n\n\n * 静态类型\n   \n   一门语言在编译时报错，那么就是静态语言，如果在运行时报错，那么就是动态语言\n   \n   typescript 就是一门静态类型语言，它能够提前在编译期避免许多 bug，如很恶心的拼写问题等\n\n很多项目，尤其是中大型项目，我们是需要团队多人协作的，那么如何保证协作呢?这个时候可能需要大量的文档和注释，显式类型就是最好的注释，而通过 typescript 提供的类型提示功能我们可以非常舒服地调用同伴的代码，由于 typescript 的存在我们可以节省大量沟通成本、代码阅读成本等等（各人认为不认同，是对 ts 学习的最大阻碍 🈲）。\n\n# 缺点\n\n * 与实际框架结合会有很多坑\n * 配置学习成本高\n * typescript 的类型系统其实比较复杂\n\n# 使用总结\n\n 1. ⌛️ 规避大量低级错误，避免时间浪费，省时\n 2. 💪 减少多人协作项目的成本，大型项目友好，省力\n 3. ❤️ 良好代码提示，不用反复文件跳转或者翻文档，省心\n\n\n# 2、基础类型\n\nundefined | null | boolean | number | bigint | string | symbol | void | object | unknown | never | any\n\n * 布尔类型：boolean\n * 数字类型：number\n * 字符串类型：string\n * 空值：void\n * null and undefined：null undefined\n * symbol 类型：symbol\n\n# 类型声明技巧\n\n * 声明一个 void 类型的只能将它赋值为 undefined 和 null\n   \n   let unusable: void = undefined;\n   \n\n * 没有声明的变量 ts 也会进行类型推到不一定所有的变量都需要声明类型\n   \n   let name = 'xiaodong';\n   // 等价于\n   let name: string = 'xiaodong';\n   \n\n * 联合类型\n   \n   function getstring(something: string | number): string {\n     return something.tostring();\n   }\n   \n\n * any 类型的使用要慎重，是多人项目协作的大忌，稍有不慎就会变成 anyscript，（本人深有感触 🙄，同事备受摧残 💀 ）\n\n * never 表示那些永远不存在的值，never 是任何类型的子类型，也可以赋值给任何类型\n   \n   // 抛出异常的函数没有返回值\n   function error(message: string): never {\n     throw new error(message);\n   }\n   \n\n * 数组分为两种类型定义:\n   \n   // 使用泛类\n   const list: array<number> = [1, 2, 3];\n   // 元素类型后面直接加 []\n   const list: number[] = [1, 2, 3];\n   \n\n\n# 3、枚举\n\n# 数组枚举\n\n当我们声明一个枚举类型，虽然没有赋值，但是它们的值其实是默认数字类型，默认从 0 开始依次累加：\n\nenum days {\n  sun,\n  mon,\n  tue,\n  wed,\n  ...\n}\nconsole.log(days[\"sun\"]); // 0\n// 反向映射\nconsole.log(days[0]); // 'sun'\n\nconsole.log(days[\"mon\"]); // 1\nconsole.log(days[1]); // 'mon'\n\n\n因此我们给第一个值赋值后面也会根据第一个值进行累加：\n\nenum days2 {\n  sun = 7,\n  mon,\n  tue = 1,\n  wed,\n\t...\n}\nconsole.log(days2[\"sun\"]); // 7\nconsole.log(days2[\"mon\"]); // 8\nconsole.log(days2[\"tue\"]); // 1\nconsole.log(days2[\"wed\"]); // 2\n\n\n# 字符串枚举\n\nenum days3 {\n  sun = 'sun',\n  mon = 'mon',\n  tue = 'tue',\n  wed = 'wed',\n\t...\n}\nconsole.log(days3['sun'], days3.mon); // sun mon\n\n\n# 枚举的本质\n\n'use strict';\nvar days3;\n(function(days3) {\n  days3['sun'] = 'sun';\n  days3['mon'] = 'mon';\n  days3['tue'] = 'tue';\n  days3['wed'] = 'wed';\n})(days3 || (days3 = {}));\n\n\n\n# 4、函数 function\n\n函数的作用就不在这里过多叙述了，typescript 里函数仍然是主要的定义行为的地方。\n\n# 定义类型函数\n\nconst add = (x: number, y: number) => {\n  return x + y;\n};\n\n\n# 可选参数\n\n❌ 可选参数后面不允许再出现必须参数\n\nconst add = (x: number, y?: number) => {\n  return x + (y ? y : 0);\n};\n\n\n# 默认参数\n\nconst add = (x: number, y: number = 1) => {\n  return x + y;\n};\n\n\n# 剩余参数\n\n// rest 参数只能是最后一个参数，关于 rest 参数,是一个数组\nconst add = (x: number, ...rest: number[]) => {\n  return rest.reduce((x, y) => x + y, x);\n};\nfunction push(array: any[], ...items: any[]) {\n  items.foreach(function(item) {\n    array.push(item);\n  });\n}\n\n\n\n# 5、断言\n\n处使用 ts 可能会遇到一些问题，比如：\n\nconst person = {};\nperson.name = 'xiaodong'; // error: 'name' ‘{}’\nperson.age = 23; // error: 'age' ‘{}’\n\n\n由于类型推断，此时 person 的类型就是{},不存在其他属性，开发者知道 person 有这个属性只是一开始没有声明，此时就需要类型断言：\n\n# as 语法\n\ninterface person {\n  name: string;\n  age: number;\n}\nconst person = {} as person;\nperson.name = 'xiaodong';\nperson.age = 23;\n\n\n# 尖括号语法\n\ninterface person {\n  name: string;\n  age: number;\n}\nconst person = <person>{};\nperson.name = 'xiaodong';\nperson.age = 20;\n\n\n# 双重断言\n\n双重断言有个前提，子类型可以被断言为父类型\n\n双重断言断言可以实现子类型转换为另外一种子类型（ 子类型->父类型->子类型）\n\n❌ 尽量不使用双重断言，会破坏原有类型关系\n\ninterface person {\n  name: string;\n  age: number;\n}\nconst person = 'xiaodong' as person; // error\nconst person = ('xiaodong' as any) as person; // ok\n\n\n\n# 6、接口 interface\n\n在 ts 中，接口的作用就为你的代码或者第三方代码定义锲约\n\n# 接口的使用\n\n注意：一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集\n\ninterface person {\n  readonly id: number; // 直读属性\n  name: string;\n  age?: number;\n  say: () => void;\n  // [propname: string]: string; // 错误示范\n  [propname: string]: any; //任意属性\n}\n\nlet xiaodong: person = {\n  id: 1013, // 只读\n  name: 'erdong',\n  age: 25,\n  gender: 'gg',\n  say() {\n    console.log('hello');\n  },\n};\n\n\n# 接口继承\n\ninterface vip extends person {\n  playbasketball: () => void;\n}\n\n\n\n# 7、类 class\n\n# 成员属性与静态属性\n\nclass game {\n  // 静态属性\n  static gname: string = '王者荣耀';\n  // 成员属性\n  playing: string;\n\n  // 构造函数 - 执行初始化操作\n  constructor(type: string) {\n    this.playing = type;\n  }\n\n  // 静态方法\n  static getname(): string {\n    return 'gamename is 王者荣耀';\n  }\n\n  // 成员方法\n  play() {\n    return '玩' + this.playing;\n  }\n}\n\n\n如何解释成员属性与静态属性\n\n'use strict';\nvar game = /** @class */ (function() {\n  // 构造函数 - 执行初始化操作\n  function game(type) {\n    this.playing = type;\n  }\n  // 静态方法\n  game.getname = function() {\n    return 'gamename is 王者荣耀';\n  };\n  // 成员方法\n  game.prototype.play = function() {\n    return '玩' + this.playing;\n  };\n  // 静态属性\n  game.gname = '王者荣耀';\n  return game;\n})();\n\n\n# 访问限定符\n\n# public\n\n修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\n\n# private （#）\n\n修饰的属性或方法是私有的，不能在声明它的类的外部访问\n\n# protected\n\n修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\n# class 可以作为接口\n\n通常我们会使用 interface 作为接口，实际上类 class 也可以作为接口使用\n\n由于组件需要传入props的类型props，同时还需要设置 defaultprops，这时候我们使用 class 来作为接口就会方便很多\n\n我们先声明一个类，然后这个类包含 props 所需的类型和初始值：\n\nexport default class props {\n  public children:\n    | array<react.reactelement<any>>\n    | react.reactelement<any>\n    | never[] = [];\n  public height: number = 181;\n  public bodyweight: string = '70kg';\n  public handsome: boolean = true;\n  public basketball: () => {};\n}\n\n\n当我们需要设置 props 的初始值事\n\npublic static defaultprops = new props()\n\n\nprops 的实例就是 defaultprops 的初始值，所有 class 作为类既可以当做接口还可以设置默认值，方便了统一管理，还减少了代码量。\n\n\n# 8、泛类 generic\n\n（图片来源：https://medium.com/better-programming/typescript-generics-90be93d8c292）\n\n泛型就是解决类、接口方法的复用性、以及对不特定数据类型的支持\n\ninterface istinglength {\n  length: number;\n}\nfunction test<t extends istinglength>(res: t): t {\n  console.log(res.length); // 12\n  return res;\n}\n\nconst str = 'typescript学习';\n// result 就是 string 类型\nconst result = test<string>(str);\nconsole.log(result); // typescript学习\n\n\n# 多个类型参数\n\nfunction swap<t, u>(tuple: [t, u]): [u, t] {\n  return [tuple[1], tuple[0]];\n}\nswap([0, 'hello']); // ['hello', 0]\n\n\n# 泛类接口\n\ninterface returnitemfn<k> {\n  (res: k): k;\n}\nconst returnitem: returnitemfn<number> = (res) => res;\n\n\n# 泛型类\n\nclass genericnumber<t> {\n  zerovalue: t;\n  add: (x: t, y: t) => t;\n}\nlet mygenericnumber = new genericnumber<number>();\nmygenericnumber.zerovalue = 0;\nmygenericnumber.add = function(x, y) {\n  return x + y;\n};\nconsole.log(mygenericnumber.add(20, 10)); // 30\n\n\n# 常见泛类变量\n\n * t（type）：表示一个 typescript 类型\n * k（key）：表示对象中的键类型\n * v（value）：表示对象中的值类型\n * e（element）：表示元素类型\n\n\n# 9、高级类型\n\n# 索引类型\n\n我们需要一个 pick 函数 ，这个函数可以从对象上取出指定属性，实现方法如下\n\n# javascript 版本\n\nfunction pick(obj, names) {\n  return names.map((item) => obj[item]);\n}\nconst user = {\n  username: '晓冬',\n  age: 24,\n  height: 181,\n};\nconst res = pick(user, ['username']);\nconsole.log(res); // [\"晓冬\"]\n\n\n# typescript 简版\n\ninterface obj {\n  [key: string]: any;\n}\nfunction pick(obj: obj, names: string[]) {\n  return names.map((n) => obj[n]);\n}\n\n\n# typescript 高级版\n\nfunction pick<t, k extends keyof t>(\n  obj: t,\n  names: k[],\n): t[k][] {\n  return names.map((n) => obj[n]);\n}\nconst res = pick(user, ['username', 'height']);\n\n\n# 映射类型\n\n当我们有一个接口，现在需要把接口所有成员变成可选的，当然我们不可能一个一个在：前添加问号，作为程序猿当然会有更懒的方法，这时候就需要我们的映射了，映射类型的语法：[p in keys]\n\ntype partial<t> = {\n  [p in keyof t]?: t[p];\n};\n\n\n# 常见工具类\n\n其实，typescript 提供一些工具类型来帮助常见的类型转换。这些类型是全局可见的\n\n# partial<t>\n\n构造类型 t，并将它所有的属性设置为可选的。它的返回类型表示输入类型的所有子类型。\n\n# readonly <t>\n\n构造类型 t，并将它所有的属性设置为 readonly，也就是说构造出的类型的属性不能被再次赋值。\n\n# record<k,t>\n\n构造一个类型，其属性名的类型为 k，属性值的类型为 t。这个工具可用来将某个类型的属性映射到另一个类型上。\n\n……\n\n\n# 10、tsconfig.json\n\n编译选项 （https://www.tslang.cn/docs/handbook/compiler-options.html）\n\n> 引用「深入理解 typescript-编译选项」\n\n{\n  \"compileroptions\": {\n    /* 基本选项 */\n    \"target\": \"es5\",                       // 指定 ecmascript 目标版本: 'es3' (default), 'es5', 'es6'/'es2015', 'es2016', 'es2017', or 'esnext'\n    \"module\": \"commonjs\",                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"lib\": [],                             // 指定要包含在编译中的库文件\n    \"allowjs\": true,                       // 允许编译 javascript 文件\n    \"checkjs\": true,                       // 报告 javascript 文件中的错误\n    \"jsx\": \"preserve\",                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'\n    \"declaration\": true,                   // 生成相应的 '.d.ts' 文件\n    \"sourcemap\": true,                     // 生成相应的 '.map' 文件\n    \"outfile\": \"./\",                       // 将输出文件合并为一个文件\n    \"outdir\": \"./\",                        // 指定输出目录\n    \"rootdir\": \"./\",                       // 用来控制输出目录结构 --outdir.\n    \"removecomments\": true,                // 删除编译后的所有的注释\n    \"noemit\": true,                        // 不生成输出文件\n    \"importhelpers\": true,                 // 从 tslib 导入辅助工具函数\n    \"isolatedmodules\": true,               // 将每个文件做为单独的模块 （与 'ts.transpilemodule' 类似）.\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                        // 启用所有严格类型检查选项\n    \"noimplicitany\": true,                 // 在表达式和声明上有隐含的 any类型时报错\n    \"strictnullchecks\": true,              // 启用严格的 null 检查\n    \"noimplicitthis\": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误\n    \"alwaysstrict\": true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'\n\n    /* 额外的检查 */\n    \"nounusedlocals\": true,                // 有未使用的变量时，抛出错误\n    \"nounusedparameters\": true,            // 有未使用的参数时，抛出错误\n    \"noimplicitreturns\": true,             // 并不是所有函数里的代码都有返回值时，抛出错误\n    \"nofallthroughcasesinswitch\": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）\n\n    /* 模块解析选项 */\n    \"moduleresolution\": \"node\",            // 选择模块解析策略： 'node' (node.js) or 'classic' (typescript pre-1.6)\n    \"baseurl\": \"./\",                       // 用于解析非相对模块名称的基目录\n    \"paths\": {},                           // 模块名到基于 baseurl 的路径映射的列表\n    \"rootdirs\": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容\n    \"typeroots\": [],                       // 包含类型声明的文件列表\n    \"types\": [],                           // 需要包含的类型声明文件名列表\n    \"allowsyntheticdefaultimports\": true,  // 允许从没有设置默认导出的模块中默认导入。\n\n    /* source map options */\n    \"sourceroot\": \"./\",                    // 指定调试器应该找到 typescript 文件而不是源文件的位置\n    \"maproot\": \"./\",                       // 指定调试器应该找到映射文件而不是生成文件的位置\n    \"inlinesourcemap\": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件\n    \"inlinesources\": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlinesourcemap 或 --sourcemap 属性\n\n    /* 其他选项 */\n    \"experimentaldecorators\": true,        // 启用装饰器\n    \"emitdecoratormetadata\": true          // 为装饰器提供元数据的支持\n  }\n\n\n\n# 参考资源\n\n * 深入理解 typescript\n * typescript 中文文档\n\n----------------------------------------\n\n/_ todo _/\n\n更多内容待补充",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "🚗 JavaScript基础篇",
      "frontmatter": {
        "title": "🚗 JavaScript基础篇",
        "date": "2021-09-07T20:02:54.000Z",
        "permalink": "/pages/javascript/",
        "categories": [
          "note"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/note/JavaScript/JavaScript%E5%9F%BA%E7%A1%80.html",
      "relativePath": "note/JavaScript/JavaScript基础.md",
      "key": "v-66f614ac",
      "path": "/pages/javascript/",
      "headers": [
        {
          "level": 2,
          "title": "👨🏻‍💻 导图",
          "slug": "dao-tu",
          "normalizedTitle": "👨🏻‍💻 导图",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "📒 整理",
          "slug": "zheng-li",
          "normalizedTitle": "📒 整理",
          "charIndex": 17
        }
      ],
      "lastUpdated": "10/28/2021, 7:15:37 PM",
      "headersStr": "👨🏻‍💻 导图 📒 整理",
      "content": "# 👨🏻‍💻 导图\n\n\n# 📒 整理\n\n# 执行上下文\n\n * JavaScript 深入之从原型到原型链——冴羽 https://github.com/mqyqingfeng/Blog/issues/2\n\n# 作用域链\n\n * JavaScript 深入之作用域链——冴羽 https://github.com/mqyqingfeng/Blog/issues/6\n\n# 闭包\n\n * JavaScript 深入之闭包——冴羽 https://github.com/mqyqingfeng/Blog/issues/9\n\n# this\n\n * JavaScript深入之从ECMAScript规范解读this——冴羽 https://github.com/mqyqingfeng/Blog/issues/7\n\n# call/apply/bind\n\n * 细说 call、apply 以及 bind 的区别和用法——segmentfault https://segmentfault.com/a/1190000018017796\n * JavaScript深入之bind的模拟实现——冴羽 https://github.com/mqyqingfeng/Blog/issues/12\n\n# 原型\n\n * JavaScript深入之从原型到原型链——冴羽 https://github.com/mqyqingfeng/Blog/issues/2\n\n# 继承\n\n# 深浅拷贝\n\n# Promise\n\n * 这一次，彻底弄懂 Promise 原理——掘金 https://juejin.cn/post/6844904063570542599\n\n# Event Loop\n\n * 详解JavaScript中的Event Loop（事件循环）机制——知乎 https://zhuanlan.zhihu.com/p/33058983",
      "normalizedContent": "# 👨🏻‍💻 导图\n\n\n# 📒 整理\n\n# 执行上下文\n\n * javascript 深入之从原型到原型链——冴羽 https://github.com/mqyqingfeng/blog/issues/2\n\n# 作用域链\n\n * javascript 深入之作用域链——冴羽 https://github.com/mqyqingfeng/blog/issues/6\n\n# 闭包\n\n * javascript 深入之闭包——冴羽 https://github.com/mqyqingfeng/blog/issues/9\n\n# this\n\n * javascript深入之从ecmascript规范解读this——冴羽 https://github.com/mqyqingfeng/blog/issues/7\n\n# call/apply/bind\n\n * 细说 call、apply 以及 bind 的区别和用法——segmentfault https://segmentfault.com/a/1190000018017796\n * javascript深入之bind的模拟实现——冴羽 https://github.com/mqyqingfeng/blog/issues/12\n\n# 原型\n\n * javascript深入之从原型到原型链——冴羽 https://github.com/mqyqingfeng/blog/issues/2\n\n# 继承\n\n# 深浅拷贝\n\n# promise\n\n * 这一次，彻底弄懂 promise 原理——掘金 https://juejin.cn/post/6844904063570542599\n\n# event loop\n\n * 详解javascript中的event loop（事件循环）机制——知乎 https://zhuanlan.zhihu.com/p/33058983",
      "charsets": {
        "cjk": true
      }
    }
  ],
  "themeConfig": {
    "author": {
      "name": "ErDong",
      "link": "https://github.com/MuBai1104"
    },
    "blogger": {
      "avatar": "https://tva1.sinaimg.cn/large/008i3skNly1gvu8gtq9lkj31400u00xv.jpg",
      "name": "ErDong",
      "slogan": "略懂点前端"
    },
    "social": {
      "icons": [
        {
          "iconClass": "icon-github",
          "title": "GitHub",
          "link": "https://github.com/MuBai1104"
        }
      ]
    },
    "footer": {
      "createYear": 2021,
      "copyrightInfo": "ErDong | <a href=\"https://github.com/MuBai1104/erdong-notes/blob/master/LICENSE\" target=\"_blank\">MIT License</a>"
    },
    "bodyBgImg": [
      "https://images.unsplash.com/photo-1561160767-6bbd75de51b8?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=2851&q=80"
    ],
    "bodyBgImgOpacity": 0.1,
    "contentBgStyle": 6,
    "lastUpdated": "上次更新",
    "nav": [
      {
        "text": "指南",
        "link": "/note/typescript"
      },
      {
        "text": "Interview",
        "link": "/interview/Integration/"
      },
      {
        "text": "关于我",
        "link": "/about/"
      },
      {
        "text": "归档",
        "link": "/archives/"
      }
    ],
    "repo": "MuBai1104/erdong-notes",
    "sidebarDepth": 3,
    "sidebar": {
      "/note": [
        {
          "title": "JavaScript 语言",
          "children": [
            "/note/JavaScript/JavaScript基础.md"
          ],
          "collapsable": false
        },
        {
          "title": "React",
          "children": [
            "/note/MV*/React/ReactVirtualDOM.md",
            "/note/MV*/React/ReactFirber.md",
            "/note/MV*/React/ReactHooks.md"
          ],
          "collapsable": false
        },
        {
          "title": "Browser",
          "children": [
            "/note/Browser/EventLoop.md",
            "/note/Browser/V8.md"
          ],
          "collapsable": false
        },
        {
          "title": "瞎写",
          "children": [
            "/note/top-levelAwait.md",
            "/note/context.md"
          ],
          "collapsable": false
        },
        {
          "title": "其他语言",
          "children": [
            "/note/typescript.md"
          ],
          "collapsable": false
        },
        {
          "title": "开发生活/杂谈",
          "children": [
            "/note/Daily/PlantUML.md"
          ],
          "collapsable": false
        }
      ],
      "/interview": [
        {
          "title": "复习",
          "children": [
            "/interview/Integration.md",
            "/interview/JavaScriptInterview.md"
          ],
          "collapsable": false
        },
        {
          "title": "题库",
          "children": [
            "/interview/Library/Questionlibrary.md"
          ],
          "collapsable": false
        }
      ],
      "/about": false
    }
  }
}